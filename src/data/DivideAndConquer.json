{
    "questions": [
        {
          "id": 1,
          "title": "Binary Search",
          "description": "Search element in a sorted array.\n\n| Test Case | Input Array         | Target | Expected Output | Notes                  |\n|-----------|----------------------|--------|------------------|-------------------------|\n| 1         | [1,3,5,7,9]          | 5      | 2                | Found at middle         |\n| 2         | [1,2,3,4,5,6]        | 1      | 0                | Found at beginning      |\n| 3         | [1,2,3,4,5,6]        | 6      | 5                | Found at end            |\n| 4         | [1,2,3,4,5,6]        | 4      | 3                | Middle element          |\n| 5         | [10,20,30,40,50]     | 35     | -1               | Not present             |\n| 6         | [2,4,6,8,10,12,14]   | 7      | -1               | Not found               |\n| 7         | [1]                  | 1      | 0                | Single element match    |\n| 8         | [1]                  | 0      | -1               | Single element no match |\n| 9         | []                   | 1      | -1               | Empty array             |\n| 10        | [1,2,3,4,5,6,7,8,9]  | 8      | 7                | Found at second last    |",
          "example": {
            "input": "[1,3,5,7,9], Target: 5",
            "output": "2",
            "explanation": "Element 5 is present at index 2."
          },
          "answer": "print((lambda a: (lambda t, arr: (lambda f: f(f, 0, len(arr)-1))(lambda f,l,h: -1 if l>h else (m:=(l+h)//2, m if arr[m]==t else f(f,m+1,h) if arr[m]<t else f(f,l,m-1))[1]))(a[0],a[1:]))(list(map(int,input().split()))))"
        },
        {
            "id": 2,
            "title": "Merge Sort",
            "description": "Sort array using merge sort.\n\n| Test Case | Input         | Expected Output | Notes                    |\n|-----------|---------------|-----------------|--------------------------|\n| 1         | [5,2,3,1]     | [1,2,3,5]       | Basic unsorted input     |\n| 2         | [1]           | [1]             | Single element           |\n| 3         | [2,1]         | [1,2]           | Two elements             |\n| 4         | [4,3,2,1]     | [1,2,3,4]       | Reversed list            |\n| 5         | []            | []              | Empty input              |\n| 6         | [10,9,8,7,6]  | [6,7,8,9,10]    | Odd-length reversed list |\n| 7         | [1,2,3,4]     | [1,2,3,4]       | Already sorted           |\n| 8         | [4,5,2,3,1]   | [1,2,3,4,5]     | Unordered list           |\n| 9         | [0,0,0]       | [0,0,0]         | Duplicates               |\n| 10        | [3,1,2,2]     | [1,2,2,3]       | Repeated elements        |",
            "example": {
              "input": "[5,2,3,1]",
              "output": "[1,2,3,5]",
              "explanation": "Merge sort recursively divides and merges arrays to sort them."
            },
            "answer": "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr)//2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\n# Read input from user or test case system\narr = list(map(int, input().split()))\nsorted_arr = mergeSort(arr)\nprint(\" \".join(map(str, sorted_arr)))"
          },
          {
            "id": 3,
            "title": "Quick Sort",
            "description": "Sort using quick sort.\n\n| Test Case | Input                       | Expected Output    | Notes                        |\n|-----------|-----------------------------|---------------------|------------------------------|\n| 1         | [3,6,8,10,1,2,1]            | [1,1,2,3,6,8,10]    | Random unsorted array        |\n| 2         | [5,4,3,2,1]                 | [1,2,3,4,5]         | Reverse sorted               |\n| 3         | [1,2,3,4,5]                 | [1,2,3,4,5]         | Already sorted               |\n| 4         | [7]                         | [7]                | Single element               |\n| 5         | []                          | []                 | Empty array                  |\n| 6         | [10, -1, 2, 5, 0, -3]       | [-3,-1,0,2,5,10]    | Includes negatives           |\n| 7         | [5,5,5,5]                   | [5,5,5,5]          | All elements equal           |\n| 8         | [9,8,7,6,5,4,3,2,1,0]       | [0,1,2,3,4,5,6,7,8,9] | Large reverse sorted       |\n| 9         | [3,1,2,1,3,1,2]             | [1,1,1,2,2,3,3]     | Duplicates and random order  |\n| 10        | [100, 10, 1]                | [1,10,100]         | Power of 10 variation        |",
            "example": {
              "input": "[3,6,8,10,1,2,1]",
              "output": "[1,1,2,3,6,8,10]",
              "explanation": "def quickSort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quickSort(left) + middle + quickSort(right)\n\n# Read input as space-separated integers\narr = list(map(int, input().split()))\n\n# Sort using quickSort\nsorted_arr = quickSort(arr)\n\n# Print result space-separated\nprint(\" \".join(map(str, sorted_arr)))"
            },
            "answer": "def quickSort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr)//2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quickSort(left) + middle + quickSort(right)"
          },
          {
            "id": 4,
            "title": "Find Minimum and Maximum in Array",
            "description": "Find the minimum and maximum values in an array using Divide & Conquer approach.\n\n| Test Case | Input                            | Expected Output  | Notes                        |\n|-----------|----------------------------------|------------------|------------------------------|\n| 1         | [100, 11, 445, 1, 330, 3000]     | Min: 1, Max: 3000| Example with random values   |\n| 2         | [5, 1, 4, 7, 3, 2]               | Min: 1, Max: 7   | Random values                |\n| 3         | [-10, -20, -30, -5]              | Min: -30, Max: -5 | All negative values          |\n| 4         | [1, 1, 1, 1]                    | Min: 1, Max: 1   | Identical elements           |\n| 5         | [9, 5, 3, 6, 8, 7]               | Min: 3, Max: 9   | Random values                |\n| 6         | [45, 67, 32, 89, 21, 3]          | Min: 3, Max: 89  | Random values                |\n| 7         | [0, -1, -5, -2, -3]              | Min: -5, Max: 0  | Mixed negative and zero      |\n| 8         | [1000, 500, 3000, 100, 900]      | Min: 100, Max: 3000| Example with large numbers  |\n| 9         | [10, 20, 30, 40, 50, 60]         | Min: 10, Max: 60 | Increasing order             |\n| 10        | [2, 3, 7, 9, 0, 1]               | Min: 0, Max: 9   | Random values                |",
            "example": {
              "input": "[100, 11, 445, 1, 330, 3000]",
              "output": "Min: 1, Max: 3000",
              "explanation": "The minimum value is 1, and the maximum value is 3000."
            },
            "answer": "def findMinMax(arr, low, high):\n    if low == high:\n        return (arr[low], arr[low])\n    if high == low + 1:\n        return (min(arr[low], arr[high]), max(arr[low], arr[high]))\n    mid = (low + high) // 2\n    min1, max1 = findMinMax(arr, low, mid)\n    min2, max2 = findMinMax(arr, mid + 1, high)\n    return (min(min1, min2), max(max1, max2))\n\n# Read input\narr = list(map(int, input().split()))\n\n# Call the function\nminimum, maximum = findMinMax(arr, 0, len(arr) - 1)\n\n# Print output\nprint(minimum, maximum)"
          },
          {
            "id": 5,
            "title": "Majority Element (More than n/2 times)",
            "description": "Find the majority element in an array, i.e., the element that appears more than n/2 times.\n\n| Test Case | Input                              | Expected Output | Notes               |\n|-----------|------------------------------------|-----------------|---------------------|\n| 1         | [2,2,1,1,1,2,2]                   | 2               | Standard test case   |\n| 2         | [3,3,4,2,4,4,2,4,4]               | 4               | Majority element     |\n| 3         | [1,2,3,4,5]                       | 1               | No majority element  |\n| 4         | [5,5,5,5,5,1,2,3]                 | 5               | Single majority      |\n| 5         | [10,10,10,20,20,30,30,10]         | 10              | Majority on left     |\n| 6         | [7,7,7,9,9,9,7,7]                 | 7               | Majority on right    |\n| 7         | [8,8,9,9,9,9,8]                   | 9               | Majority in middle   |\n| 8         | [4,4,4,4,1,1,1,1]                 | 4               | Majority of 4's      |\n| 9         | [2,2,2,2,1,1,1]                   | 2               | Majority of 2's      |\n| 10        | [1,1,1,2,3,4,5]                   | 1               | Clear majority       |",
            "example": {
              "input": "[2,2,1,1,1,2,2]",
              "output": "2",
              "explanation": "The majority element (appearing more than n/2 times) in the array is 2."
            },
            "answer": "def majorityElement(nums):\n    count, candidate = 0, None\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    # After finding the candidate, check if it really is a majority\n    if nums.count(candidate) > len(nums) // 2:\n        return candidate\n    else:\n        return nums[0]  # Return the first element if no majority exists\n\n# Read input\nnums = list(map(int, input().strip().split()))\n\n# Print result\nprint(majorityElement(nums))"
          },
          {
            "id": 6,
            "title": "Count Inversions in Array",
            "description": "Count the number of pairs (i, j) such that arr[i] > arr[j] and i < j.\n\n| Test Case | Input                            | Expected Output | Notes                     |\n|-----------|----------------------------------|-----------------|---------------------------|\n| 1         | [2,4,1,3,5]                      | 3               | Standard test case         |\n| 2         | [1,20,6,4,5]                     | 5               | Inversions in sequence     |\n| 3         | [1,2,3,4,5]                      | 0               | No inversions              |\n| 4         | [5,4,3,2,1]                      | 10              | Reverse sorted             |\n| 5         | [10,9,8,7,6,5]                   | 15              | Reverse sorted large       |\n| 6         | [1,3,2,3,1]                      | 4               | Multiple inversions        |\n| 7         | [1,1,1,1,1]                      | 0               | All elements equal         |\n| 8         | [1,3,5,2,4,6]                    | 3               | Some inversions present    |\n| 9         | [7,5,6,4,3,2]                    | 10              | Larger number of inversions|\n| 10        | [9,8,7,6,5,4,3,2,1]              | 36              | Fully reversed sequence    |",
            "example": {
              "input": "[2,4,1,3,5]",
              "output": "3",
              "explanation": "There are 3 inversions: (2,1), (4,1), (4,3)."
            },
            "answer": "def mergeSortCount(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr)//2\n    left, invLeft = mergeSortCount(arr[:mid])\n    right, invRight = mergeSortCount(arr[mid:])\n    merged, invSplit = mergeCount(left, right)\n    return merged, invLeft + invRight + invSplit\n\ndef mergeCount(left, right):\n    result, i, j, inv = [], 0, 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            inv += len(left) - i\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result, inv\n\narr = list(map(int, input().split()))\n_, inv_count = mergeSortCount(arr)\nprint(inv_count)"
          },
        {
            "id": 7,
            "title": "Find Element in Rotated Sorted Array",
            "description": "Search an element in a rotated sorted array.\n\n | Test Cases | Input                     | Target | Expected Output | Notes                           |\n|------------|----------------------------|--------|-----------------|---------------------------------|\n| 1          | [4,5,6,7,0,1,2]             | 0      | 4               | Element present at rotated index|\n| 2          | [4,5,6,7,0,1,2]             | 5      | 1               | Element found in the rotated part|\n| 3          | [4,5,6,7,0,1,2]             | 2      | 6               | Element found at end             |\n| 4          | [7,0,1,2,3,4,5,6]           | 6      | 7               | Element present at start        |\n| 5          | [1,2,3,4,5,6,7]             | 4      | 3               | Element found in non-rotated part|\n| 6          | [3,4,5,6,7,8,9,10,1,2]      | 1      | 8               | Element in second rotated part  |\n| 7          | [1,2,3,4,5,6]               | 4      | 3               | Element in the first half        |\n| 8          | [8,9,10,11,12,13,14,15,16]   | 15     | 13              | Searching in sorted rotated array|\n| 9          | [1,2,3,4,5,6]               | 5      | 4               | Element found in second part    |\n| 10         | [1,2,3,4,5,6,7,8,9,10]      | 10     | 9               | Element at the end               |\n| 11         | [7,8,9,10,11,12]             | 9      | 2               | Searching through rotated sorted array|\n| 12         | [7,6,5,4,3,2,1]             | 3      | 2               | Searching reversed sorted array  |\n| 13         | [10,20,30,40,50]             | 40     | 3               | Test for unrotated array         |\n| 14         | [1]                         | 1      | 0               | Only one element                |\n| 15         | [1,2,3,4]                   | 2      | 1               | Simple sorted array             |\n| 16         | [8,7,6,5,4,3,2,1]            | 1      | 7               | Searching through reversed array|\n| 17         | [3,2,1,0,9,8,7,6,5,4]        | 5      | 9               | Reversed array search            |\n| 18         | [1,1,1,2,3,4,5]              | 5      | 6               | Test with duplicates            |\n| 19         | [2,4,6,8,10,12,14,16]        | 12     | 5               | Test with larger numbers         |\n| 20         | [1, 2, 3, 4, 5, 6, 7]        | 4      | 3               | Simple case                      |\n| 21         | [4,5,6,7,0,1,2]             | 1      | 5               | Testing rotated array again      |\n| 22         | [3,4,5,6,7,8,9,10]           | 6      | 3               | Array not rotated                |\n| 23         | [1,4,6,8,10,12,14]           | 10     | 4               | Sorted elements                  |\n| 24         | [2,4,5,6,7,8,10]             | 7      | 5               | Simple rotation test             |\n| 25         | [10,20,30,40,50]             | 20     | 1               | Test for larger numbers          |\n| 26         | [50, 40, 30, 20, 10]         | 30     | 2               | Reversed array search            |\n| 27         | [20,40,60,80,100]            | 100    | 4               | Test array with larger numbers   |\n| 28         | [2,4,6,8,10,12]              | 12     | 5               | Sorted array with larger numbers |",
            "example": {
                "input": "[4,5,6,7,0,1,2], Target: 0",
                "output": "4",
                "explanation": "The target 0 is found at index 4 in the rotated sorted array."
            },
            "answer": "def search(nums, target):\n    low, high = 0, len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[low] == nums[mid] == nums[high]:\n            low += 1\n            high -= 1\n        elif nums[low] <= nums[mid]:  # Left half is sorted\n            if nums[low] <= target < nums[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        else:  # Right half is sorted\n            if nums[mid] < target <= nums[high]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return -1\n\n# Input: target is first number, rest is rotated sorted array\nfull_input = list(map(int, input().split()))\ntarget = full_input[0]\nnums = full_input[1:]\n\n# Do search in nums (no slicing needed), and output directly\nprint(search(nums, target))"
        },
    {
      "id": 8,
      "title": "Number of Rotations in Sorted Array",
      "description": "Find number of rotations (index of minimum element).\n\n | Test Cases | Input            | Expected Output | Notes           |\n|------------|------------------|-----------------|-----------------|\n| 1          | [15,18,2,3,6,12]  | 2               | Basic test      |\n| 2          | [5,6,7,9,1,2,3]   | 4               | Rotated array  |\n| 3          | [11,12,15,18,2,3] | 4               | Small test case |\n| 4          | [7,8,9,10,1,2]    | 4               | Rotated middle  |\n| 5          | [2,3,4,5,6,7,8]   | 0               | No rotation     |\n| 6          | [3,4,5,6,7,8,9]   | 0               | Already sorted  |\n| 7          | [1,2,3,4,5]       | 0               | No rotation     |\n| 8          | [9,10,11,12,13,1] | 5               | Rotation in middle|\n| 9          | [5,6,7,1,2,3]     | 3               | Simple rotation |\n| 10         | [0,1,2,3,4,5]     | 0               | No rotation     |\n| 11         | [2,3,4,5,1]       | 4               | Small case      |\n| 12         | [4,5,6,7,8,9,0,1] | 6               | Large rotated   |\n| 13         | [12,13,14,15,16,17,18,1] | 7            | Large case      |\n| 14         | [11,12,13,14,15]  | 0               | Sorted case     |\n| 15         | [7,9,11,12,14]    | 0               | Small sorted    |\n| 16         | [5,7,9,10,1]      | 4               | Simple test     |\n| 17         | [10,11,12,13,1,2] | 4               | Rotated part    |\n| 18         | [15,16,17,18,1,2] | 4               | Basic test      |\n| 19         | [5,6,7,8,1]       | 4               | Rotation in middle|\n| 20         | [0,1,2,3,4]       | 0               | No rotation     |\n| 21         | [3,4,5,6,7]       | 0               | Sorted         |\n| 22         | [2,3,4,5]         | 0               | Small rotation  |\n| 23         | [8,9,10,11,12,1]  | 5               | Large rotation  |\n| 24         | [6,7,8,9,10,11]   | 0               | No rotation     |\n| 25         | [9,10,11,12,1,2]  | 4               | Mid case        |\n| 26         | [10,11,12,13,14,1]| 5               | Large rotation  |\n| 27         | [7,8,9,10,11,12,1]| 5               | Rotation in middle|\n| 28         | [4,5,6,7,8]       | 0               | Simple case     |\n| 29         | [13,14,15,16,17]  | 0               | No rotation     |\n| 30         | [5,6,7,8,1]       | 4               | Mid case        |\n| 31         | [2,3,4,5,6]       | 0               | No rotation     |\n| 32         | [8,9,10,11,1,2]   | 4               | Large rotation  |\n| 33         | [4,5,6,7]         | 0               | Small test      |\n| 34         | [3,4,5,6,7,8]     | 0               | Simple case     |\n| 35         | [1,2,3,4,5,6]     | 0               | No rotation     |\n| 36         | [6,7,8,9,10]      | 0               | No rotation     |\n| 37         | [10,11,12,13,14]  | 0               | Sorted array    |\n| 38         | [7,8,9,10]        | 0               | Small rotation  |\n| 39         | [9,10,11,12,13]   | 0               | No rotation     |\n| 40         | [1,2,3,4,5,6,7,8] | 0               | No rotation     |",
      "example": {
        "input": "[15,18,2,3,6,12]",
        "output": "2",
        "explanation": "The array is rotated 2 times, the minimum element is at index 2."
      },
      "answer": "def find_rotation(arr):\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] > arr[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Example usage:\narr = list(map(int, input().split()))\nprint(find_rotation(arr))"
    },
    {
    "id": 9,
    "title": "Find Integer Square Root (Binary Search)",
    "description": "Find the floor value of sqrt(n) using binary search.\n\n | Test Cases | Input  | Expected Output | Notes       |\n|------------|--------|-----------------|-------------|\n| 1          | 8      | 2               | Basic test  |\n| 2          | 4      | 2               | Perfect square|\n| 3          | 10     | 3               | Non-perfect square|\n| 4          | 1      | 1               | Smallest value|\n| 5          | 16     | 4               | Perfect square|\n| 6          | 25     | 5               | Perfect square|\n| 7          | 3      | 1               | Small test  |\n| 8          | 100    | 10              | Larger value|\n| 9          | 1024   | 32              | Larger test |\n| 10         | 99999  | 316             | Large value |\n| 11         | 49     | 7               | Perfect square|\n| 12         | 36     | 6               | Perfect square|\n| 13         | 50     | 7               | Non-perfect square|\n| 14         | 2      | 1               | Small test  |\n| 15         | 20     | 4               | Medium case |\n| 16         | 999    | 31              | Medium large |\n| 17         | 81     | 9               | Perfect square|\n| 18         | 400    | 20              | Large value |\n| 19         | 784    | 28              | Perfect square|\n| 20         | 12345  | 111             | Medium test |\n| 21         | 9876   | 99              | Large value |\n| 22         | 999    | 31              | Medium test |\n| 23         | 256    | 16              | Perfect square|\n| 24         | 1000   | 31              | Large value |\n| 25         | 81     | 9               | Perfect square|\n| 26         | 8000   | 89              | Larger number|\n| 27         | 50000  | 223             | Large value |\n| 28         | 7000   | 83              | Large value |\n| 29         | 23     | 4               | Small test  |\n| 30         | 1      | 1               | Edge case   |\n| 31         | 99     | 9               | Medium test |\n| 32         | 121    | 11              | Perfect square|\n| 33         | 9      | 3               | Perfect square|\n| 34         | 4500   | 67              | Larger case |\n| 35         | 100    | 10              | Round number|\n| 36         | 12     | 3               | Small test  |\n| 37         | 800    | 28              | Medium case |\n| 38         | 200    | 14              | Medium case |\n| 39         | 1500   | 38              | Larger case |\n| 40         | 2500   | 50              | Larger case |\n",
    "example": {
        "input": "8",
        "output": "2",
        "explanation": "The floor value of sqrt(8) is 2."
    },
    "answer": "def sqrt(n):\n    low, high = 0, n\n    ans = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return mid\n        if mid * mid < n:\n            low = mid + 1\n            ans = mid\n        else:\n            high = mid - 1\n    \n    return ans\n\n# Read input and compute result\nn = int(input())\nprint(sqrt(n))"
},
{
  "id": 10,
  "title": "Longest Equal 0s and 1s Substring",
  "description": "Find the longest substring with an equal number of 0s and 1s.\n\n | Test Cases | Input         | Expected Output | Notes       |\n|------------|---------------|-----------------|-------------|\n| 1          | [0,1,0]       | 2               | Basic test  |\n| 2          | [1,0,1,1,0]    | 4               | Mixed sequence |\n| 3          | [0,0,1,1]      | 4               | Equal 0s and 1s |\n| 4          | [1,0,1,0,1]    | 4               | Alternating 0 and 1 |\n| 5          | [0,1,1,0,0,1]  | 6               | Equal length | \n| 6          | [1,1,0,0,1,0]  | 4               | Different lengths | \n| 7          | [0,0,0,0]      | 0               | All zeros  |\n| 8          | [1,1,1,1]      | 0               | All ones |\n| 9          | [1,0,0,1,0]    | 4               | Alternating 1s and 0s |\n| 10         | [0,1,1,0]      | 4               | Equal sequence |\n| 11         | [1,1,0,1,0]    | 4               | Mixed sequence |\n| 12         | [1,0,0,0,1]    | 2               | More 0s than 1s |\n| 13         | [0,1,0,1,0,0]  | 4               | Equal mix |\n| 14         | [1,0,1,0,0,1]  | 4               | Alternating sequence |\n| 15         | [1,0,1,1,0]    | 4               | Mixed sequence |\n| 16         | [1,0,0,1,1,0]  | 4               | Equal subsequence |\n| 17         | [0,0,0,1,1,1]  | 4               | Consecutive ones and zeros |\n| 18         | [1,1,0,0,1]    | 4               | Mixed values |\n| 19         | [1,0,1,0,1]    | 4               | Alternating sequence |\n| 20         | [0,1,0,0,1]    | 4               | Balanced sequence |\n| 21         | [1,1,0,0]      | 4               | Equal count |\n| 22         | [1,0,1,1]      | 4               | Balanced subsequence |\n| 23         | [0,1,1,1,0]    | 4               | More 1s than 0s |\n| 24         | [0,1,0,0,1]    | 4               | Balanced subsequence |\n| 25         | [1,0,1,0]      | 2               | Alternating 0 and 1 |\n| 26         | [1,0,1,1,0]    | 4               | Mixed sequence |\n| 27         | [0,1,1,0,0]    | 4               | Equal subsequence |\n| 28         | [1,1,1,0]      | 2               | Imbalanced count |\n| 29         | [1,0,1]        | 2               | Subsequence with equal 1s and 0s |\n| 30         | [0,1,1]        | 2               | Equal subsequence |\n| 31         | [0,1,1,1]      | 4               | Balanced sequence |\n| 32         | [1,1,0,1]      | 2               | Imbalanced subsequence |\n| 33         | [1,0,1,0,1,0]  | 4               | Alternating sequence |\n| 34         | [1,0,1,0,1]    | 4               | Alternating subsequence |\n| 35         | [0,1,1,0]      | 4               | Equal subsequence |\n| 36         | [1,1,0,1,1]    | 4               | Sequence with more 1s |\n| 37         | [0,1,0,1,0]    | 4               | Equal subsequence |\n| 38         | [1,0,1,1,1]    | 4               | Balanced subsequence |\n| 39         | [0,1,1,1,0]    | 4               | Balanced mix |\n| 40         | [1,0,1,0,1,1]  | 4               | Equal 1s and 0s |\n",
  "example": {
    "input": "[0,1,0]",
    "output": "2",
    "explanation": "The longest substring with equal number of 0s and 1s is [0,1] or [1,0], which has length 2."
  },
  "answer": "def findMaxLength(nums):\n    counter = {0:-1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counter:\n            max_len = max(max_len, i - counter[count])\n        else:\n            counter[count] = i\n    return max_len"
},
{
  "id": 11,
  "title": "Count 1's in a Sorted Binary Array",
  "description": "Count the number of 1s in a sorted binary array.\n\n | Test Cases | Input              | Expected Output | Notes           |\n|------------|--------------------|-----------------|-----------------|\n| 1          | [0,0,0,1,1,1,1]     | 4               | Basic test      |\n| 2          | [0,1,1,1,1,1]       | 5               | All 1's after 0  |\n| 3          | [0,0,1,1,1,1,1]     | 5               | 0's followed by 1's |\n| 4          | [0,0,0,0]           | 0               | No 1's          |\n| 5          | [1,1,1,1]           | 4               | All 1's         |\n| 6          | [1,1,0,0]           | 2               | Half 1's        |\n| 7          | [1,0,0,1]           | 2               | 1's at both ends|\n| 8          | [1,0,1,1,1]         | 4               | Random input    |\n| 9          | [1,1,1,1,1,1]       | 6               | All 1's         |\n| 10         | [0,1,0,1,0,1]       | 3               | Alternating 0's and 1's |\n| 11         | [0,0,0,1]           | 1               | Small sequence  |\n| 12         | [1,1,0,1]           | 3               | Random input    |\n| 13         | [1,0,1,0]           | 2               | Mixed 0's and 1's |\n| 14         | [0,0,1,1]           | 2               | Small array     |\n| 15         | [1,0,0,0,1]         | 2               | Random test     |\n| 16         | [0,1,1,1,0,0]       | 3               | Mixed order     |\n| 17         | [0,1,0,1]           | 2               | Small mix       |\n| 18         | [1,0,1,1,1,1]       | 5               | Mix of 0's and 1's |\n| 19         | [0,0,1,1,1,0]       | 3               | Alternating test |\n| 20         | [0,1,1,1,1]         | 4               | Simple test     |\n| 21         | [1,0,1,1,0,1]       | 4               | Mix with edges  |\n| 22         | [0,0,0,0,1]         | 1               | Single 1 at the end|\n| 23         | [1,0,0,1,1,1]       | 4               | Mixed input     |\n| 24         | [0,1,0,0,1]         | 2               | Mixed case      |\n| 25         | [1,1,0,1,0,1]       | 4               | Mixed input     |\n| 26         | [0,1,1,0,0]         | 2               | Mixed order     |\n| 27         | [0,1,1,1]           | 3               | Small sequence  |\n| 28         | [1,0,1,0,1]         | 3               | Alternating case|\n| 29         | [1,1,1,1,0]         | 4               | Mix with zeros  |\n| 30         | [0,1,1,1,0,1]       | 4               | Random case     |\n| 31         | [0,0,0,1,1]         | 2               | Simple test     |\n| 32         | [1,1,1,0,0]         | 3               | Random mix      |\n| 33         | [1,1,0,1]           | 3               | Small input     |\n| 34         | [1,0,0,1,0,1]       | 3               | Small random    |\n| 35         | [1,0,1,1,1]         | 4               | Random test     |\n| 36         | [0,0,1,1,1,0]       | 3               | Mixed 0's       |\n| 37         | [0,1,1,1,1,1]       | 5               | Large test      |\n| 38         | [0,0,0,1,1,0]       | 2               | Mixed test      |\n| 39         | [1,0,1,0,1,0]       | 3               | Alternating test|\n| 40         | [1,1,0,0,1]         | 3               | Mixed test      |",
  "example": {
    "input": "[0,0,0,1,1,1,1]",
    "output": "4",
    "explanation": "There are 4 1's in the sorted binary array."
  },
  "answer": "def countOnes(arr):\n    # Check if the array is sorted\n    if arr == sorted(arr):\n        # If sorted, use binary search\n        low = 0\n        high = len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == 0:\n                low = mid + 1  # Move to the right half\n            else:\n                high = mid - 1  # Move to the left half\n        return len(arr) - low  # The count of ones is the remaining elements from 'low'\n    else:\n        # If unsorted, count the number of 1's directly\n        return arr.count(1)\n\n# Accept input from the user\narr = list(map(int, input().split()))\n\n# Print the result\nprint(countOnes(arr))"
},
{
  "id": 12,
  "title": "Merge Two Sorted Arrays Without Extra Space",
  "description": "Given two sorted arrays `arr1` and `arr2`, merge them into one sorted array **without using extra space**.\n\n| Test Case | Input | Output | Notes |\n|-----------|----------------------------|--------------------------|----------------------------|\n| 1 | [1, 3, 5], [2, 4, 6] | [1, 2, 3, 4, 5, 6] | Equal sizes |\n| 2 | [1, 4], [2, 3, 5] | [1, 2, 3, 4, 5] | Unequal sizes |\n| 3 | [1, 2], [] | [1, 2] | One empty array |\n| 4 | [], [1, 2] | [1, 2] | Other empty array |\n| 5 | [5, 6, 7], [1, 2, 3] | [1, 2, 3, 5, 6, 7] | Reverse ordered inputs |\n| 6 | [2, 3], [1, 4, 5, 6] | [1, 2, 3, 4, 5, 6] | Mix of values |\n| 7 | [10], [1] | [1, 10] | Single elements |\n| 8 | [1, 3, 5], [7, 9] | [1, 3, 5, 7, 9] | No overlap |\n| 9 | [1, 2, 2], [2, 3, 4] | [1, 2, 2, 2, 3, 4] | With duplicates |\n| 10 | [0], [0] | [0, 0] | Same elements |\n| 11 | [1, 5], [2, 3, 4] | [1, 2, 3, 4, 5] | Interleaved values |\n| 12 | [1, 1, 1], [1, 1] | [1, 1, 1, 1, 1] | All duplicates |\n| 13 | [5], [] | [5] | One element only |\n| 14 | [6, 7, 8], [0, 1, 2] | [0, 1, 2, 6, 7, 8] | Lower values second |\n| 15 | [1, 3, 8], [2, 4, 9] | [1, 2, 3, 4, 8, 9] | Intermixed sorted arrays |\n",
  "example": {
    "input": "[1, 3, 5], [2, 4, 6]",
    "output": "[1, 2, 3, 4, 5, 6]",
    "explanation": "Merge both arrays in-place without extra space."
  },
  "answer": "def merge_without_extra_space(arr1, arr2):\n    n, m = len(arr1), len(arr2)\n    i, j = n - 1, 0\n    while i >= 0 and j < m and arr1[i] > arr2[j]:\n        arr1[i], arr2[j] = arr2[j], arr1[i]\n        i -= 1\n        j += 1\n    arr1.sort()\n    arr2.sort()\n    return arr1 + arr2\n\ntry:\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\nexcept EOFError:\n    arr2 = []\n\nmerged = merge_without_extra_space(arr1, arr2)\nif merged:\n    print(*merged)\nelse:\n    print(0)"

},
{
  "id": 13,
  "title": "Find the Peak Element in an Array",
  "description": "A peak element is an element that is strictly greater than its neighbors. Given an array, find a peak element using a divide and conquer approach.\n\n| Test Case | Input | Output | Notes |\n|-----------|-----------------------|--------|--------------------------|\n| 1 | [1, 2, 3, 1] | 3 | Peak is at index 2 |\n| 2 | [1, 2, 1, 3, 5, 6, 4] | 6 | One of the peaks |\n| 3 | [5] | 5 | Single element |\n| 4 | [1, 2] | 2 | Last element is peak |\n| 5 | [3, 2] | 3 | First element is peak |\n| 6 | [1, 3, 20, 4, 1, 0] | 20 | High middle peak |\n| 7 | [10, 20, 15, 2, 23, 90, 67] | 90 | One of the peaks |\n| 8 | [2, 1] | 2 | First is peak |\n| 9 | [1, 3, 20, 4, 5] | 20 | Middle peak |\n| 10 | [1, 2, 3, 4, 5] | 5 | Peak is last |\n| 11 | [5, 4, 3, 2, 1] | 5 | Peak is first |\n| 12 | [2, 3, 4, 3, 2, 1] | 4 | Peak at center |\n| 13 | [1, 2, 3, 4, 3] | 4 | Peak before decrease |\n| 14 | [5, 10, 20, 15, 7] | 20 | Tallest peak |\n| 15 | [1, 1, 1, 2, 1] | 2 | Single peak |\n",
  "example": {
    "input": "[1, 2, 3, 1]",
    "output": "3",
    "explanation": "3 is greater than both neighbors (2 and 1)."
  },
  "answer": "def find_peak(nums):\n    def binary_search(low, high):\n        if low == high:\n            return nums[low]\n        mid = (low + high) // 2\n        if nums[mid] < nums[mid + 1]:\n            return binary_search(mid + 1, high)\n        else:\n            return binary_search(low, mid)\n    return binary_search(0, len(nums) - 1)\n\nnums = list(map(int, input().split()))\nprint(find_peak(nums))"
},
{
  "id": 14,
  "title": "Find the Kth Smallest Element in Two Sorted Arrays",
  "description": "Given two sorted arrays `arr1` and `arr2`, find the Kth smallest element in the merged array without merging them.\n\n| Test Case | Input | Output | Notes |\n|-----------|--------------------------------------|--------|--------------------------|\n| 1 | [2,3,6,7], [1,4,8,10], k=5 | 6 | 5th smallest |\n| 2 | [1,3,5], [2,4,6], k=4 | 4 | Equal lengths |\n| 3 | [1], [2,3,4,5], k=3 | 3 | One small array |\n| 4 | [1,2], [3,4], k=4 | 4 | k = total length |\n| 5 | [2], [1], k=1 | 1 | k = 1 |\n| 6 | [], [1,2,3], k=2 | 2 | One empty array |\n| 7 | [1,2,3], [], k=3 | 3 | Other empty |\n| 8 | [1,2,3], [4,5,6], k=6 | 6 | Largest element |\n| 9 | [10,20], [5,15], k=2 | 10 | Mixed arrays |\n| 10 | [1,1,1], [1,1,1], k=4 | 1 | All same elements |\n| 11 | [1,2,3], [4,5,6], k=5 | 5 | Standard case |\n| 12 | [1], [2], k=2 | 2 | Tiny arrays |\n| 13 | [1,3,5], [2,4,6], k=6 | 6 | Max k |\n| 14 | [1,2], [3,4], k=1 | 1 | Min k |\n| 15 | [1,4,7,10], [2,3,5,6], k=7 | 7 | Complex case |\n",
  "example": {
    "input": "[2,3,6,7], [1,4,8,10], k=5",
    "output": "6",
    "explanation": "5th smallest element in the merged array is 6."
  },
  "answer": "def kth_smallest(arr1, arr2, k):\n    def helper(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        ia = min(k // 2, len(a))\n        ib = k - ia\n        if a[ia - 1] < b[ib - 1]:\n            return helper(a[ia:], b, k - ia)\n        else:\n            return helper(a, b[ib:], k - ib)\n    return helper(arr1, arr2, k)\n\nk = int(input())\narr1 = list(map(int, input().split()))\narr2 = list(map(int, input().split()))\n\nprint(kth_smallest(arr1, arr2, k))"
},
{
  "id": 15,
  "title": "Count Occurrences of an Element in a Sorted Array",
  "description": "Given a sorted array and a number `x`, count how many times `x` occurs in the array using binary search.\n\n| Test Case | Input | Output | Notes |\n|-----------|--------------------------|--------|----------------------------|\n| 1 | [1,2,2,2,3,4], x=2 | 3 | 2 appears 3 times |\n| 2 | [1,1,2,2,2,3,3], x=1 | 2 | Count 1s |\n| 3 | [1,2,3,4,5], x=6 | 0 | x not in array |\n| 4 | [2,2,2,2,2], x=2 | 5 | All are x |\n| 5 | [1,2,3,4,5], x=3 | 1 | Single occurrence |\n| 6 | [1], x=1 | 1 | One element |\n| 7 | [], x=1 | 0 | Empty array |\n| 8 | [5,5,5,5,6,7,8], x=5 | 4 | Consecutive occurrences |\n| 9 | [1,2,3,4,5], x=4 | 1 | Mid-position x |\n| 10 | [1,2,2,2,2,2,3], x=2 | 5 | Multiple occurrences |\n| 11 | [1,2,3,4,4,4,5], x=4 | 3 | Tail-end |\n| 12 | [3,3,3,4,5], x=3 | 3 | Head-end |\n| 13 | [1,2,3,3,3,4,5], x=3 | 3 | Middle x |\n| 14 | [1,2,3,4,5], x=2 | 1 | Small k |\n| 15 | [1,2,3,4,5], x=5 | 1 | x at end |\n",
  "example": {
    "input": "[1,2,2,2,3,4], x=2",
    "output": "3",
    "explanation": "Element 2 appears 3 times between indices 1 and 3."
  },
  "answer": "def count_occurrences(arr, x):\n    def find_first():\n        low, high = 0, len(arr) - 1\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                res = mid\n                high = mid - 1\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return res\n\n    def find_last():\n        low, high = 0, len(arr) - 1\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                res = mid\n                low = mid + 1\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return res\n\n    first = find_first()\n    last = find_last()\n    return 0 if first == -1 else last - first + 1\n\nx = int(input())\narr = list(map(int, input().split()))\nprint(count_occurrences(arr, x))"
},
{
  "id": 16,
  "title": "Median of Two Sorted Arrays (Simplified Easy Version)",
  "description": "Given two sorted arrays of equal size `n`, find the median of the merged array without merging them.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------------|--------|----------------------------|\n| 1 | [1, 3], [2, 4] | 2.5 | Median of [1,2,3,4] |\n| 2 | [1, 2], [3, 4] | 2.5 | Even total size |\n| 3 | [1, 5], [2, 3] | 2.5 | Unsorted merge |\n| 4 | [1, 2, 3], [4, 5, 6] | 3.5 | Longer input |\n| 5 | [1, 1], [1, 1] | 1.0 | All equal elements |\n| 6 | [1], [2] | 1.5 | Single elements |\n| 7 | [5, 6], [7, 8] | 6.5 | Larger values |\n| 8 | [2, 3], [1, 4] | 2.5 | Interleaved values |\n| 9 | [10, 20], [15, 25] | 17.5 | Spread out values |\n| 10 | [0, 0], [0, 0] | 0.0 | All zeros |\n| 11 | [1, 4], [2, 3] | 2.5 | Reverse sorted merge |\n| 12 | [1, 2, 3], [7, 8, 9] | 5.0 | No overlap |\n| 13 | [1, 3, 5], [2, 4, 6] | 3.5 | Alternating values |\n| 14 | [100, 200], [150, 250] | 175.0 | Big values |\n| 15 | [1, 2], [1, 2] | 1.5 | Duplicates in both |\n",
  "example": {
    "input": "[1, 3], [2, 4]",
    "output": "2.5",
    "explanation": "Merged array is [1,2,3,4] â†’ median is (2+3)/2 = 2.5"
  },
  "answer":"def find_median_sorted_arrays(arr1, arr2):\n    n = len(arr1)\n    i = j = 0\n    count = 0\n    m1 = m2 = -1\n\n    while count <= n:\n        if i < n and (j >= n or arr1[i] <= arr2[j]):\n            m1 = m2\n            m2 = arr1[i]\n            i += 1\n        else:\n            m1 = m2\n            m2 = arr2[j]\n            j += 1\n        count += 1\n    print((m1 + m2) / 2)\n\narr1 = list(map(int, input().split()))\narr2 = list(map(int, input().split()))\nfind_median_sorted_arrays(arr1, arr2)"
},
{
  "id": 17,
  "title": "Search in a Nearly Sorted Array",
  "description": "In a nearly sorted array, an element at index `i` could be at `i-1`, `i`, or `i+1`. Given such an array and a key, find the index of the key using modified binary search.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------------|--------|-------------------------------|\n| 1 | [10, 3, 40, 20, 50, 80, 70], key=40 | 2 | Found at index 2 |\n| 2 | [10, 3, 40, 20, 50, 80, 70], key=10 | 0 | First element |\n| 3 | [10, 3, 40, 20, 50, 80, 70], key=70 | 6 | Last element |\n| 4 | [10, 3, 40, 20, 50, 80, 70], key=20 | 3 | Middle value |\n| 5 | [2, 1, 3], key=1 | 1 | Swapped adjacent |\n| 6 | [1, 2, 3], key=3 | 2 | Normal sorted |\n| 7 | [1, 3, 2], key=2 | 2 | Swap at end |\n| 8 | [3, 1, 2], key=1 | 1 | Key at i-1 |\n| 9 | [1], key=1 | 0 | Single element |\n| 10 | [1, 2, 3, 4], key=5 | -1 | Not found |\n| 11 | [], key=1 | -1 | Empty array |\n| 12 | [1, 2], key=2 | 1 | Small size |\n| 13 | [3, 2, 1], key=1 | 2 | Reverse sorted |\n| 14 | [10, 20, 30, 40, 50], key=30 | 2 | Regular sorted |\n| 15 | [10, 20, 30, 40, 50], key=60 | -1 | Missing key |\n",
  "example": {
    "input": "[10, 3, 40, 20, 50, 80, 70], key=40",
    "output": "2",
    "explanation": "40 is at index 2 even in the nearly sorted array."
  },
  "answer": "def search_nearly_sorted(arr, key):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == key:\n            return mid\n        if mid - 1 >= low and arr[mid - 1] == key:\n            return mid - 1\n        if mid + 1 <= high and arr[mid + 1] == key:\n            return mid + 1\n        if key < arr[mid]:\n            high = mid - 2\n        else:\n            low = mid + 2\n    return -1\nkey = int(input())\narr = list(map(int, input().split()))\nprint(search_nearly_sorted(arr, key))"
},
{
  "id": 18,
  "title": "Search in a Bitonic Array",
  "description": "A Bitonic array is first increasing and then decreasing. Given a bitonic array and a key, find the index of the key in O(log n) time.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------------|--------|-------------------------------|\n| 1 | [1, 3, 8, 12, 4, 2], key=4 | 4 | Found in decreasing part |\n| 2 | [1, 3, 8, 12, 4, 2], key=5 | -1 | Not present |\n| 3 | [1, 3, 8, 12, 4, 2], key=12 | 3 | Peak element |\n| 4 | [1, 3, 8, 12, 4, 2], key=1 | 0 | First element |\n| 5 | [10, 20, 30, 40, 50, 35, 25, 5], key=35 | 5 | Mid-decreasing part |\n| 6 | [10, 20, 30, 40, 50, 35, 25, 5], key=10 | 0 | Leftmost |\n| 7 | [10, 20, 30, 40, 50, 35, 25, 5], key=5 | 7 | Rightmost |\n| 8 | [1, 2, 3, 4, 3, 2, 1], key=3 | 2 | Left occurrence |\n| 9 | [1, 2, 3, 4, 3, 2, 1], key=2 | 1 | First 2 |\n| 10 | [1, 2, 3, 4, 3, 2, 1], key=7 | -1 | Absent |\n| 11 | [5, 10, 15, 20, 25, 20, 15, 10, 5], key=25 | 4 | Peak element |\n| 12 | [5, 10, 15, 20, 25, 20, 15, 10, 5], key=15 | 2 | First 15 |\n| 13 | [1, 3, 8, 12, 4], key=8 | 2 | Middle |\n| 14 | [1, 3, 8, 12, 4], key=100 | -1 | Large not present |\n| 15 | [10], key=10 | 0 | Single element |\n",
  "example": {
    "input": "[1, 3, 8, 12, 4, 2], key=4",
    "output": "4",
    "explanation": "4 is found at index 4 in the bitonic array."
  },
  "answer": "def search_bitonic_array(arr, key):\n    def find_peak():\n        low, high = 0, len(arr) - 1\n        while low < high:\n            mid = (low + high) // 2\n            if arr[mid] > arr[mid + 1]:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n    def binary_search(start, end, asc=True):\n        while start <= end:\n            mid = (start + end) // 2\n            if arr[mid] == key:\n                return mid\n            if asc:\n                if key < arr[mid]:\n                    end = mid - 1\n                else:\n                    start = mid + 1\n            else:\n                if key > arr[mid]:\n                    end = mid - 1\n                else:\n                    start = mid + 1\n        return -1\n\n    peak = find_peak()\n    index = binary_search(0, peak)\n    if index != -1:\n        return index\n    return binary_search(peak + 1, len(arr) - 1, asc=False)\n\nkey = int(input())\narr = list(map(int, input().split()))\nprint(search_bitonic_array(arr, key))"
},
{
  "id": 19,
  "title": "Closest Pair of Points in 1D",
  "description": "Given a list of integers representing positions on a line, find the minimum absolute difference between any two points.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------------|--------|-------------------------------|\n| 1 | [1, 5, 3, 19, 18, 25] | 1 | Closest: 18 and 19 |\n| 2 | [30, 5, 20, 9] | 4 | Closest: 5 and 9 |\n| 3 | [1, 19, -4, 31, 38, 25, 100] | 5 | Closest: 31 and 25 |\n| 4 | [10, 10, 10] | 0 | All same |\n| 5 | [1, 2] | 1 | Only two |\n| 6 | [100, 80, 60, 40, 20, 0] | 20 | Decreasing order |\n| 7 | [1, 1000] | 999 | Large difference |\n| 8 | [-10, -1, 0, 1, 2] | 1 | Negative numbers too |\n| 9 | [-5, -4, -3, -2] | 1 | All negatives |\n| 10 | [5] | None | Only one element |\n| 11 | [] | None | Empty list |\n| 12 | [2, 4, 1, 3] | 1 | Random small list |\n| 13 | [7, 14, 10] | 3 | Closest: 10 and 7 |\n| 14 | [9, 3, 6] | 3 | Closest: 6 and 3 |\n| 15 | [0, 5, 3, 2] | 1 | Closest: 2 and 3 |\n",
  "example": {
    "input": "[1, 5, 3, 19, 18, 25]",
    "output": "1",
    "explanation": "The closest pair is 18 and 19, with a difference of 1."
  },
  "answer": "def closest_pair_1d(arr):\n    if len(arr) < 2:\n        return None\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff\narr = list(map(int, input().split()))\nprint(closest_pair_1d(arr))\n"
},
{
  "id": 20,
  "title": "Find the Element That Appears Once When Others Appear Twice",
  "description": "Given an array of integers where every element appears twice except for one, find that single one in linear time without extra memory.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------------|--------|-------------------------------|\n| 1 | [2, 3, 5, 4, 5, 3, 4] | 2 | 2 is the unique one |\n| 2 | [1, 1, 2, 2, 3] | 3 | Only 3 remains |\n| 3 | [10, 10, 20, 30, 20] | 30 | Solo 30 |\n| 4 | [0, 0, -1] | -1 | Negative unique |\n| 5 | [99] | 99 | Only one element |\n| 6 | [7, 3, 3, 7, 1, 1, 6] | 6 | Unique at end |\n| 7 | [1, 2, 1, 2, 3, 4, 4] | 3 | Unique in middle |\n| 8 | [8, 9, 9, 8, 10] | 10 | Clean end |\n| 9 | [5, 5, 5, 5, 6, 6, 7, 7, 8] | 8 | Only 8 is solo |\n| 10 | [2, 2, 3, 3, 4, 4, 5] | 5 | End unique |\n| 11 | [100, 200, 100, 300, 300] | 200 | Solo 200 |\n| 12 | [0, 1, 0] | 1 | Middle |\n| 13 | [2, 1, 2] | 1 | Unique in center |\n| 14 | [9, 9, 8, 8, 7] | 7 | Last one |\n| 15 | [4, 4, 5, 5, 6] | 6 | Remains |\n",
  "example": {
    "input": "[2, 3, 5, 4, 5, 3, 4]",
    "output": "2",
    "explanation": "Every number appears twice except 2."
  },
  "answer": "def find_single_number(arr):\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\narr = list(map(int, input().split()))\nprint(find_single_number(arr))"
},
{
  "id": 21,
  "title": "Find the Majority Element Using Divide and Conquer",
  "description": "Given an array of size `n`, find the element that appears more than `n/2` times using the divide and conquer approach.\n\n| Test Case | Input | Output | Notes |\n|-----------|---------------------|--------|------------------------------|\n| 1 | [3, 3, 4, 2, 4, 4, 2, 4, 4] | 4 | Majority is 4 |\n| 2 | [2, 2, 1, 1, 1, 2, 2] | 2 | Majority is 2 |\n| 3 | [1, 1, 1, 1, 2, 3, 4] | 1 | Majority is 1 |\n| 4 | [1, 2, 3] | -1 | No majority |\n| 5 | [5, 5, 5, 5, 5] | 5 | All elements same |\n| 6 | [1] | 1 | Single element |\n| 7 | [] | -1 | Empty array |\n",
  "example": {
    "input": "[3, 3, 4, 2, 4, 4, 2, 4, 4]",
    "output": "4",
    "explanation": "The majority element is 4 as it appears more than n/2 times."
  },
  "answer": "def majority_element(nums):\n    def count_in_range(num, left, right):\n        return sum(1 for i in range(left, right + 1) if nums[i] == num)\n\n    def majority_rec(left, right):\n        if left == right:\n            return nums[left]\n\n        mid = (left + right) // 2\n        left_major = majority_rec(left, mid)\n        right_major = majority_rec(mid + 1, right)\n\n        if left_major == right_major:\n            return left_major\n\n        left_count = count_in_range(left_major, left, right)\n        right_count = count_in_range(right_major, left, right)\n\n        return left_major if left_count > right_count else right_major\n\n    candidate = majority_rec(0, len(nums) - 1)\n    return candidate if nums.count(candidate) > len(nums) // 2 else -1\n\nnums = list(map(int, input().split()))\nprint(majority_element(nums))"
},
{
  "id": 22,
  "title": "Find the Missing Number in an Arithmetic Progression",
  "description": "Given a sorted array representing an arithmetic progression with one missing element, find the missing number using binary search.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------|--------|----------------------------|\n| 1 | [2, 4, 6, 10] | 8 | 8 is missing |\n| 2 | [5, 15, 20, 25] | 10 | 10 is missing |\n| 3 | [3, 6, 9, 15] | 12 | 12 is missing |\n| 4 | [1, 3, 5, 7, 9, 13] | 11 | 11 is missing |\n| 5 | [10, 20, 30, 50] | 40 | 40 is missing |\n| 6 | [1, 2, 3, 4, 6] | 5 | Last value before end |\n| 7 | [1, 3, 4, 5] | 2 | Missing at start |\n",
  "example": {
    "input": "[2, 4, 6, 10]",
    "output": "8",
    "explanation": "The common difference is 2, and 8 is missing."
  },
  "answer":"def find_missing_ap(arr):\n    low, high = 0, len(arr) - 1\n    diff = (arr[-1] - arr[0]) // len(arr)\n    while low <= high:\n        mid = (low + high) // 2\n        expected = arr[0] + mid * diff\n        if arr[mid] == expected:\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(arr[0] + low * diff)\narr = list(map(int, input().split()))\nfind_missing_ap(arr)"
},
{
  "id": 23,
  "title": "Sum of Array Elements Using Divide and Conquer",
  "description": "Find the sum of array elements using a divide and conquer approach.\n\n| Test Case | Input | Output | Notes |\n|-----------|----------------------|--------|---------------------------|\n| 1 | [1, 2, 3, 4, 5] | 15 | Basic case |\n| 2 | [10, 20, 30] | 60 | Three elements |\n| 3 | [0, 0, 0, 0] | 0 | All zeros |\n| 4 | [-1, -2, -3] | -6 | Negative numbers |\n| 5 | [1] | 1 | Single element |\n| 6 | [] | 0 | Empty array |\n| 7 | [100, 200, 300, 400] | 1000 | Larger numbers |\n",
  "example": {
    "input": "[1, 2, 3, 4, 5]",
    "output": "15",
    "explanation": "Sum is calculated recursively by dividing the array."
  },
  "answer": "def sum_array(arr):\n    def helper(left, right):\n        if left > right:\n            return 0\n        if left == right:\n            return arr[left]\n        mid = (left + right) // 2\n        return helper(left, mid) + helper(mid + 1, right)\n\n    return helper(0, len(arr) - 1)\n\narr = list(map(int, input().split()))\nprint(sum_array(arr))"
},
{
  "id": 24,
  "title": "Check if Array is Sorted Using Divide and Conquer",
  "description": "Determine whether a given array is sorted in non-decreasing order using divide and conquer.\n\n| Test Case | Input | Output | Notes |\n|-----------|-------------------|--------|-------------------------------|\n| 1 | [1, 2, 3, 4, 5] | true | Sorted ascending |\n| 2 | [1, 1, 2, 3] | true | Duplicates allowed |\n| 3 | [5, 4, 3, 2, 1] | false | Descending order |\n| 4 | [1, 2, 2, 2, 3] | true | Flat sections |\n| 5 | [1] | true | Single element |\n| 6 | [] | true | Empty array is sorted |\n| 7 | [1, 3, 2] | false | Unsorted in middle |\n",
  "example": {
    "input": "[1, 2, 3, 4, 5]",
    "output": "true",
    "explanation": "The array is sorted in non-decreasing order."
  },
  "answer": "def is_sorted(arr):\n    def helper(start, end):\n        if start >= end:\n            return True\n        mid = (start + end) // 2\n        # Check left and right halves\n        if not helper(start, mid):\n            return False\n        if not helper(mid + 1, end):\n            return False\n        if arr[mid] > arr[mid + 1]:\n            return False\n        return True\n\n    return helper(0, len(arr) - 1)\narr = list(map(int, input().split()))\nprint(is_sorted(arr))"
},
{
  "id": 25,
  "title": "Find Second Largest Element Using Divide and Conquer",
  "description": "Find the second largest element in an array using the divide and conquer technique.\n\n| Test Case | Input | Output | Notes |\n|-----------|-------------------|--------|------------------------------|\n| 1 | [1, 2, 3, 4, 5] | 4 | Second largest is 4 |\n| 2 | [10, 20] | 10 | Two elements |\n| 3 | [5, 5, 5, 5] | -1 | No second largest |\n| 4 | [100] | -1 | Only one element |\n| 5 | [8, 6, 4, 2] | 6 | Descending order |\n| 6 | [1, 3, 3, 2] | 2 | Duplicates present |\n",
  "example": {
    "input": "[1, 2, 3, 4, 5]",
    "output": "4",
    "explanation": "The largest is 5, second largest is 4."
  },
  "answer": "def find_second_largest(arr):\n    if len(arr) < 2:\n        return -1\n    def helper(start, end):\n        if start == end:\n            return (arr[start], float('-inf'))\n\n        mid = (start + end) // 2\n        left_max, left_second = helper(start, mid)\n        right_max, right_second = helper(mid + 1, end)\n\n        if left_max > right_max:\n            max_val = left_max\n            second_max = max(left_second, right_max)\n        elif right_max > left_max:\n            max_val = right_max\n            second_max = max(right_second, left_max)\n        else:\n            max_val = left_max\n            second_max = max(left_second, right_second)\n        return (max_val, second_max)\n    max_val, second_max = helper(0, len(arr) - 1)\n    return second_max if second_max != float('-inf') else -1\narr = list(map(int, input().split()))\nprint(find_second_largest(arr))"
},
{
  "id": 26,
  "title": "Find Local Minima in Array",
  "description": "Given an array, find a local minima. An element is a local minima if it is less than or equal to its neighbors. Use binary search to achieve O(log n) time.\n\n| Test Case | Input | Output | Notes |\n|-----------|---------------------|--------|--------------------------------|\n| 1 | [9, 6, 3, 14, 5, 7, 4] | 2 | Index of local minima (3) |\n| 2 | [23, 8, 15, 2, 3] | 1 | Local minima is 8 |\n| 3 | [1, 2, 3, 4, 5] | 0 | First element is local minima |\n| 4 | [5, 4, 3, 2, 1] | 4 | Last element is local minima |\n| 5 | [10] | 0 | Single element is local minima |\n| 6 | [10, 5] | 1 | Smaller of two elements |\n| 7 | [5, 10] | 0 | Smaller of two elements |\n",
  "example": {
    "input": "[9, 6, 3, 14, 5, 7, 4]",
    "output": "2",
    "explanation": "Element 3 at index 2 is a local minima."
  },
  "answer": "def find_local_minima(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    if arr[0] < arr[1]:\n        return 0\n    if arr[n - 1] < arr[n - 2]:\n        # We'll not immediately return here, to find the leftmost local minima\n        pass\n\n    low, high = 1, n - 2\n    local_min_index = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < arr[mid - 1] and arr[mid] < arr[mid + 1]:\n            local_min_index = mid\n            # Try to find a local minima to the left as well for smaller index\n            high = mid - 1\n        elif arr[mid] > arr[mid - 1]:\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    if local_min_index != -1:\n        return local_min_index\n    else:\n        # Check edges now if no internal local minima found\n        if arr[0] < arr[1]:\n            return 0\n        if arr[n - 1] < arr[n - 2]:\n            return n - 1\n\n    return -1\n\narr = list(map(int, input().split()))\nprint(find_local_minima(arr))"
},
{
  "id": 27,
  "title": "Merge Overlapping Intervals",
  "description": "Given a collection of intervals, merge all overlapping intervals and return the result.\n\n| Test Case | Input | Output | Notes |\n|-----------|-----------------------------------|-------------------------|----------------------------|\n| 1 | [[1,3],[2,6],[8,10],[15,18]] | [[1,6],[8,10],[15,18]] | Overlapping intervals |\n| 2 | [[1,4],[4,5]] | [[1,5]] | Touching intervals |\n| 3 | [[1,3],[5,7],[9,11]] | [[1,3],[5,7],[9,11]] | No overlaps |\n| 4 | [[1,10],[2,3],[4,5]] | [[1,10]] | Nested intervals |\n| 5 | [[1,4]] | [[1,4]] | Single interval |\n| 6 | [] | [] | Empty input |\n",
  "example": {
    "input": "[[1,3],[2,6],[8,10],[15,18]]",
    "output": "[[1,6],[8,10],[15,18]]",
    "explanation": "Intervals [1,3] and [2,6] overlap and are merged into [1,6]."
  },
  "answer": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort()\n    merged = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if merged[-1][1] >= intervals[i][0]:\n            merged[-1][1] = max(merged[-1][1], intervals[i][1])\n        else:\n            merged.append(intervals[i])\n    return merged\nimport sys\nlines = sys.stdin.read().strip().split('\\n')\n\nintervals = [list(map(int, line.strip().split())) for line in lines if line.strip()]\nmerged = merge_intervals(intervals)\n\nfor interval in merged:\n    print(*interval)"
},
{
  "id": 28,
  "title": "Find Frequency of a Number in a Sorted Array",
  "description": "Given a sorted array and a number `x`, find the frequency of `x` using binary search.\n\n| Test Case | Input | Output | Notes |\n|-----------|--------------------------|--------|----------------------------|\n| 1 | [1,2,2,2,3,4], x=2 | 3 | Appears 3 times |\n| 2 | [1,2,3,4,5], x=6 | 0 | Not present |\n| 3 | [1,1,1,1], x=1 | 4 | All elements same |\n| 4 | [1,2,3,4], x=3 | 1 | Appears once |\n| 5 | [2,2,2,2,3], x=2 | 4 | Starts at beginning |\n| 6 | [], x=1 | 0 | Empty array |\n",
  "example": {
    "input": "[1,2,2,2,3,4], x=2",
    "output": "3",
    "explanation": "Binary search can find the first and last occurrence of 2, then count = last - first + 1."
  },
  "answer": "def frequency(arr, x):\n    def find_first():\n        low, high = 0, len(arr) - 1\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                ans = mid\n                high = mid - 1\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n\n    def find_last():\n        low, high = 0, len(arr) - 1\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                ans = mid\n                low = mid + 1\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n\n    first = find_first()\n    last = find_last()\n    return (last - first + 1) if first != -1 else 0"
},
{
  "id": 29,
  "title": "Find Floor of an Element in a Sorted Array",
  "description": "Given a sorted array and an integer `x`, find the floor of `x`. The floor is the greatest element smaller than or equal to `x`.\n\n| Test Case | Input | Output | Notes |\n|-----------|------------------------|--------|---------------------------|\n| 1 | [1,2,8,10,10,12,19], x=5 | 2 | Floor is 2 |\n| 2 | [1,2,8,10,10,12,19], x=20 | 19 | Floor is last element |\n| 3 | [1,2,8,10,10,12,19], x=0 | -1 | No floor |\n| 4 | [1,2,3], x=3 | 3 | Exact match |\n| 5 | [5], x=5 | 5 | Single element match |\n| 6 | [5], x=2 | -1 | No floor |\n| 7 | [], x=10 | -1 | Empty array |\n",
  "example": {
    "input": "[1,2,8,10,10,12,19], x=5",
    "output": "2",
    "explanation": "The largest value less than or equal to 5 is 2."
  },
  "answer": "def find_floor(arr, x):\n    low, high = 0, len(arr) - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return arr[mid]\n        elif arr[mid] < x:\n            res = arr[mid]\n            low = mid + 1\n        else:\n            high = mid - 1\n    return res\nx = int(input())\narr = list(map(int, input().split()))\nprint(find_floor(arr, x))"
},
{
  "id": 30,
  "title": "Find First and Last Occurrence of X in Sorted Array",
  "description": "Given a sorted array and a value `x`, find the first and last occurrence of `x` using binary search.\n\n| Test Case | Input | Output | Notes |\n|-----------|-----------------------------|-----------|-----------------------------|\n| 1 | [1,2,2,2,3,4], x=2 | [1,3] | Appears from index 1 to 3 |\n| 2 | [1,2,3,4,5], x=6 | [-1,-1] | Not found |\n| 3 | [1,1,1,1], x=1 | [0,3] | All occurrences |\n| 4 | [1,2,3,4], x=3 | [2,2] | Only once |\n| 5 | [2,2,2,2,3], x=2 | [0,3] | Starts at beginning |\n| 6 | [], x=1 | [-1,-1] | Empty array |\n",
  "example": {
    "input": "[1,2,2,2,3,4], x=2",
    "output": "[1,3]",
    "explanation": "First occurrence at index 1 and last at index 3."
  },
  "answer":"def find_first_last(arr, x):\n    def find_first():\n        low, high = 0, len(arr) - 1\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                ans = mid\n                high = mid - 1\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n\n    def find_last():\n        low, high = 0, len(arr) - 1\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                ans = mid\n                low = mid + 1\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n\n    return find_first(), find_last()\nx = int(input())\narr = list(map(int, input().split()))\nfirst, last = find_first_last(arr, x)\nprint(first, last)"
},
{
  "id": 31,
  "title": "Calculate Power(x, n) Using Divide and Conquer",
  "description": "Calculate x raised to the power n (x^n) using divide and conquer approach (fast exponentiation).\n\n| Test Case | Input | Output | Notes |\n|-----------|-------------------|--------|------------------------------|\n| 1 | x=2, n=10 | 1024 | 2^10 = 1024 |\n| 2 | x=3, n=5 | 243 | 3^5 = 243 |\n| 3 | x=5, n=0 | 1 | Any number to power 0 is 1 |\n| 4 | x=2, n=1 | 2 | Base case |\n| 5 | x=2, n=3 | 8 | Recursive case |\n| 6 | x=2, n=100 | 1267650600228229401496703205376 | Large power |\n| 7 | x=2, n=-2 | 0.25 | Negative power |\n",
  "example": {
    "input": "x=2, n=10",
    "output": "1024",
    "explanation": "Using divide and conquer: 2^10 = (2^5)^2 = ((2^2)^2 * 2)^2."
  },
  "answer": "def power(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 1 / power(x, -n)\n    half = power(x, n // 2)\n    if n % 2 == 0:\n        return half * half\n    else:\n        return half * half * x\n\nx = float(input())\nn = int(input())\nres = power(x, n)\n\nif isinstance(res, float) and res.is_integer():\n    print(int(res))\nelse:\n    print(res)"
}

  ]
}
      