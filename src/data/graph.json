{
    "questions": [
    {
      "id": 1,
      "title": "BFS traversal",
      "description": "Given a graph as an adjacency list and a starting node, return the BFS traversal order.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0 | [0,1,2,3] | Simple graph |\n| 2 | {0:[1],1:[2],2:[3],3:[]}, start=0 | [0,1,2,3] | Linear graph |\n| 3 | {0:[1,2],1:[3],2:[3],3:[]}, start=0 | [0,1,2,3] | Branching |\n| 4 | {0:[1],1:[2],2:[0]}, start=0 | [0,1,2] | Cycle |\n| 5 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=0 | [0,1,2,3,4] | Linear |\n| 6 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=0 | [0,1,2,3,4,5,6] | Binary tree |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=0 | [0,1,2,3,4] | Cycle |\n| 8 | {0:[1,2,3],1:[],2:[],3:[]}, start=0 | [0,1,2,3] | Star |\n| 9 | {0:[],1:[],2:[]}, start=0 | [0] | Isolated node |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, start=0 | [0,1,2,3,4,5] | Linear |\n| 11 | {0:[1,2],1:[3],2:[4],3:[],4:[]}, start=0 | [0,1,2,3,4] | Branching |\n| 12 | {0:[1],1:[2],2:[0]}, start=1 | [1,2,0] | Cycle, different start |\n| 13 | {0:[1],1:[2],2:[3],3:[0]}, start=2 | [2,3,0,1] | Cycle, different start |\n| 14 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=2 | [2,5,6] | Subtree |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=3 | [3,4] | Partial traversal |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=4 | [4] | Single node |\n| 17 | {0:[1,2],1:[3],2:[4],3:[5],4:[6],5:[],6:[]}, start=0 | [0,1,2,3,4,5,6] | Deep tree |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, start=0 | [0,1,2,3,4,5,6] | Linear |\n| 19 | {0:[1,2,3,4,5],1:[],2:[],3:[],4:[],5:[]}, start=0 | [0,1,2,3,4,5] | Star |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=2 | [2,3,4,0,1] | Cycle |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, start=0 | [0,1,2,3,4,5] | Cycle |\n| 22 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[],5:[],6:[],7:[],8:[]}, start=0 | [0,1,2,3,4,5,6,7,8] | Tree |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 24 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Tree |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Cycle |\n| 26 | {0:[1,2,3],1:[4,5],2:[6,7],3:[8,9],4:[],5:[],6:[],7:[],8:[],9:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Tree |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 28 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Tree |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 30 | {0:[1,2,3,4,5,6,7,8,9,10],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Star |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12] | Linear |\n| 32 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] | Tree |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Linear |\n| 34 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] | Star |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Linear |\n| 36 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[17,18],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18] | Tree |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Linear |\n| 38 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] | Star |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] | Linear |\n| 40 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[],41:[],42:[],43:[],44:[],45:[],46:[],47:[],48:[],49:[],50:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50] | Star |",
      "example": {
        "input": "{0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0",
        "output": "[0,1,2,3]",
        "explanation": "BFS traversal from node 0."
      },
      "answer":"from collections import deque\nimport ast\n\ndef bfs(graph, start):\n    visited = set()\n    order = []\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            order.append(node)\n            for neighbor in sorted(graph.get(node, [])):\n                if neighbor not in visited:\n                    q.append(neighbor)\n    return order\n\ngraph = ast.literal_eval(input().strip())\nstart = int(input().strip())\nprint(bfs(graph, start))"

    },
    {
      "id": 2,
      "title": "DFS traversal",
      "description": "Given a graph as an adjacency list and a starting node, return the DFS traversal order.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0 | [0,1,3,2] | Simple graph |\n| 2 | {0:[1],1:[2],2:[3],3:[]}, start=0 | [0,1,2,3] | Linear graph |\n| 3 | {0:[1,2],1:[3],2:[3],3:[]}, start=0 | [0,1,3,2] | Branching |\n| 4 | {0:[1],1:[2],2:[0]}, start=0 | [0,1,2] | Cycle |\n| 5 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=0 | [0,1,2,3,4] | Linear |\n| 6 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=0 | [0,1,3,4,2,5,6] | Binary tree |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=0 | [0,1,2,3,4] | Cycle |\n| 8 | {0:[1,2,3],1:[],2:[],3:[]}, start=0 | [0,1,2,3] | Star |\n| 9 | {0:[],1:[],2:[]}, start=0 | [0] | Isolated node |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, start=0 | [0,1,2,3,4,5] | Linear |\n| 11 | {0:[1,2],1:[3],2:[4],3:[],4:[]}, start=0 | [0,1,3,2,4] | Branching |\n| 12 | {0:[1],1:[2],2:[0]}, start=1 | [1,2,0] | Cycle, different start |\n| 13 | {0:[1],1:[2],2:[3],3:[0]}, start=2 | [2,3,0,1] | Cycle, different start |\n| 14 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=2 | [2,5,6] | Subtree |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=3 | [3,4] | Partial traversal |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=4 | [4] | Single node |\n| 17 | {0:[1,2],1:[3],2:[4],3:[5],4:[6],5:[],6:[]}, start=0 | [0,1,3,5,2,4,6] | Deep tree |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, start=0 | [0,1,2,3,4,5,6] | Linear |\n| 19 | {0:[1,2,3,4,5],1:[],2:[],3:[],4:[],5:[]}, start=0 | [0,1,2,3,4,5] | Star |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=2 | [2,3,4,0,1] | Cycle |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, start=0 | [0,1,2,3,4,5] | Cycle |\n| 22 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[],5:[],6:[],7:[],8:[]}, start=0 | [0,1,3,7,8,4,2,5,6] | Tree |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 24 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,3,7,8,4,9,10,2,5,6] | Tree |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Cycle |\n| 26 | {0:[1,2,3],1:[4,5],2:[6,7],3:[8,9],4:[],5:[],6:[],7:[],8:[],9:[]}, start=0 | [0,1,4,5,2,6,7,3,8,9] | Tree |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 28 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[]}, start=0 | [0,1,3,7,8,4,9,10,2,5,11,12,6,13,14] | Tree |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 30 | {0:[1,2,3,4,5,6,7,8,9,10],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Star |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12] | Linear |\n| 32 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[]}, start=0 | [0,1,3,7,15,16,4,9,10,2,5,11,12,6,13,14,8] | Tree |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Linear |\n| 34 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] | Star |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Linear |\n| 36 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[17,18],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[]}, start=0 | [0,1,3,7,15,16,4,9,10,2,5,11,12,6,13,14,8,17,18] | Tree |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Linear |\n| 38 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] | Star |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] | Linear |\n| 40 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[],41:[],42:[],43:[],44:[],45:[],46:[],47:[],48:[],49:[],50:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50] | Star |",
      "example": {
        "input": "{0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0",
        "output": "[0,1,3,2]",
        "explanation": "DFS traversal from node 0."
      },
      "answer": "def dfs(graph, start):\n    visited = set()\n    order = []\n\n    def helper(node):\n        if node not in visited:\n            visited.add(node)\n            order.append(node)\n            for neighbor in sorted(graph.get(node, [])):\n                helper(neighbor)\n\n    helper(start)\n    return order\n\nimport ast\ngraph = ast.literal_eval(input().strip())\nstart = int(input().strip())\nprint(dfs(graph, start))"

    },
    {
      "id": 3,
      "title": "Detect cycle in undirected graph using DFS",
      "description": "Given an undirected graph as an adjacency list, detect if there is a cycle using DFS.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1],1:[0,2],2:[1,3],3:[2]}, n=4 | False | No cycle |\n| 2 | {0:[1],1:[0,2],2:[1,0]}, n=3 | True | Cycle |\n| 3 | {0:[1,2],1:[0,2],2:[0,1]}, n=3 | True | Triangle |\n| 4 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3]}, n=5 | False | No cycle |\n| 5 | {0:[1],1:[0,2],2:[1,3],3:[2,0]}, n=4 | True | Cycle |\n| 6 | {0:[1],1:[0]}, n=2 | False | No cycle |\n| 7 | {0:[1,2],1:[0],2:[0]}, n=3 | False | No cycle |\n| 8 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,0]}, n=5 | True | Cycle |\n| 9 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4]}, n=6 | False | No cycle |\n| 10 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,0]}, n=6 | True | Cycle |\n| 11 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5]}, n=7 | False | No cycle |\n| 12 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,0]}, n=7 | True | Cycle |\n| 13 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6]}, n=8 | False | No cycle |\n| 14 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,0]}, n=8 | True | Cycle |\n| 15 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7]}, n=9 | False | No cycle |\n| 16 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,0]}, n=9 | True | Cycle |\n| 17 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8]}, n=10 | False | No cycle |\n| 18 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,0]}, n=10 | True | Cycle |\n| 19 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9]}, n=11 | False | No cycle |\n| 20 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,0]}, n=11 | True | Cycle |\n| 21 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10]}, n=12 | False | No cycle |\n| 22 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,0]}, n=12 | True | Cycle |\n| 23 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11]}, n=13 | False | No cycle |\n| 24 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,0]}, n=13 | True | Cycle |\n| 25 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12]}, n=14 | False | No cycle |\n| 26 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,0]}, n=14 | True | Cycle |\n| 27 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13]}, n=15 | False | No cycle |\n| 28 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,0]}, n=15 | True | Cycle |\n| 29 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14]}, n=16 | False | No cycle |\n| 30 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,0]}, n=16 | True | Cycle |\n| 31 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15]}, n=17 | False | No cycle |\n| 32 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,0]}, n=17 | True | Cycle |\n| 33 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16]}, n=18 | False | No cycle |\n| 34 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,0]}, n=18 | True | Cycle |\n| 35 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17]}, n=19 | False | No cycle |\n| 36 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,0]}, n=19 | True | Cycle |\n| 37 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,19],19:[18]}, n=20 | False | No cycle |\n| 38 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,19],19:[18,0]}, n=20 | True | Cycle |\n| 39 | {0:[1],1:[0]}, n=2 | False | No cycle |\n| 40 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,19],19:[18]}, n=20 | False | No cycle |",
      "example": {
        "input": "{0:[1],1:[0,2],2:[1,0]}, n=3",
        "output": "True",
        "explanation": "Cycle exists."
      },
      "answer": "def hasCycleUndirected(graph, n):\n    visited = [False] * n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph.get(node, []):\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    return False\n\nimport ast\ngraph = ast.literal_eval(input().strip())\nn = int(input().strip())\nprint(hasCycleUndirected(graph, n))"

    },
    {
      "id": 4,
      "title": "Detect cycle in directed graph using DFS",
      "description": "Given a directed graph as an adjacency list, detect if there is a cycle using DFS.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1],1:[2],2:[0]}, n=3 | True | Cycle |\n| 2 | {0:[1],1:[2],2:[]}, n=3 | False | No cycle |\n| 3 | {0:[1,2],1:[2],2:[]}, n=3 | False | No cycle |\n| 4 | {0:[1],1:[2],2:[3],3:[1]}, n=4 | True | Cycle |\n| 5 | {0:[1],1:[2],2:[3],3:[]}, n=4 | False | No cycle |\n| 6 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, n=5 | True | Cycle |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[]}, n=5 | False | No cycle |\n| 8 | {0:[1,2],1:[3],2:[3],3:[]}, n=4 | False | No cycle |\n| 9 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, n=6 | True | Cycle |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, n=6 | False | No cycle |\n| 11 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[0]}, n=7 | True | Cycle |\n| 12 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | False | No cycle |\n| 13 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[0]}, n=7 | True | Cycle |\n| 14 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | False | No cycle |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[0]}, n=8 | True | Cycle |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[]}, n=8 | False | No cycle |\n| 17 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[0]}, n=9 | True | Cycle |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[]}, n=9 | False | No cycle |\n| 19 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, n=10 | True | Cycle |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, n=10 | False | No cycle |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[0]}, n=11 | True | Cycle |\n| 22 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, n=11 | False | No cycle |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[0]}, n=12 | True | Cycle |\n| 24 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=12 | False | No cycle |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[0]}, n=13 | True | Cycle |\n| 26 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, n=13 | False | No cycle |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[0]}, n=14 | True | Cycle |\n| 28 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, n=14 | False | No cycle |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[0]}, n=15 | True | Cycle |\n| 30 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, n=15 | False | No cycle |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[0]}, n=16 | True | Cycle |\n| 32 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, n=16 | False | No cycle |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[0]}, n=17 | True | Cycle |\n| 34 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, n=17 | False | No cycle |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[0]}, n=18 | True | Cycle |\n| 36 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[]}, n=18 | False | No cycle |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[0]}, n=19 | True | Cycle |\n| 38 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[]}, n=19 | False | No cycle |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[19],19:[0]}, n=20 | True | Cycle |\n| 40 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[19],19:[]}, n=20 | False | No cycle |",
      "example": {
        "input": "{0:[1],1:[2],2:[0]}, n=3",
        "output": "True",
        "explanation": "Cycle exists."
      },
      "answer": "def hasCycleDirected(graph, n):\n    visited = [0] * n  # 0 = unvisited, 1 = visiting, 2 = visited\n    \n    def dfs(node):\n        if visited[node] == 1:\n            return True\n        if visited[node] == 2:\n            return False\n        visited[node] = 1\n        for neighbor in graph.get(node, []):\n            if dfs(neighbor):\n                return True\n        visited[node] = 2\n        return False\n\n    for i in range(n):\n        if visited[i] == 0:\n            if dfs(i):\n                return True\n    return False\n\ngraph = eval(input())\nn = int(input())\nprint(hasCycleDirected(graph, n))"

    },
    {
      "id": 5,
      "title": "Topological sorting",
      "description": "Given a directed acyclic graph (DAG) as an adjacency list, return a topological ordering of its nodes.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1],1:[2],2:[]}, n=3 | [0,1,2] | Linear |\n| 2 | {0:[2,3],1:[3],2:[],3:[]}, n=4 | [0,1,2,3] or [1,0,2,3] | Multiple valid |\n| 3 | {0:[1],1:[2],2:[3],3:[]}, n=4 | [0,1,2,3] | Linear |\n| 4 | {0:[1,2],1:[3],2:[3],3:[]}, n=4 | [0,2,1,3] or [0,1,2,3] | Multiple valid |\n| 5 | {0:[1],1:[],2:[3],3:[]}, n=4 | [0,2,1,3] or [2,0,1,3] | Multiple valid |\n| 6 | {0:[1,2],1:[],2:[],3:[1,2]}, n=4 | [3,0,1,2] or [0,3,1,2] | Multiple valid |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[]}, n=5 | [0,1,2,3,4] | Linear |\n| 8 | {0:[1,2],1:[3],2:[3],3:[4],4:[]}, n=5 | [0,2,1,3,4] or [0,1,2,3,4] | Multiple valid |\n| 9 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, n=6 | [0,1,2,3,4,5] | Linear |\n| 11 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, n=7 | [0,2,6,5,1,4,3] or [0,1,2,3,4,5,6] | Multiple valid |\n| 12 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | [0,1,2,3,4,5,6] | Linear |\n| 13 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | [0,2,1,3,4,5,6] or [0,1,2,3,4,5,6] | Multiple valid |\n| 14 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[]}, n=8 | [0,1,2,3,4,5,6,7] | Linear |\n| 16 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[]}, n=8 | [0,2,1,3,4,5,6,7] or [0,1,2,3,4,5,6,7] | Multiple valid |\n| 17 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[]}, n=9 | [0,1,2,3,4,5,6,7,8] | Linear |\n| 19 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[]}, n=9 | [0,2,1,3,4,5,6,7,8] or [0,1,2,3,4,5,6,7,8] | Multiple valid |\n| 20 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, n=10 | [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 22 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, n=10 | [0,2,1,3,4,5,6,7,8,9] or [0,1,2,3,4,5,6,7,8,9] | Multiple valid |\n| 23 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 24 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, n=11 | [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 25 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, n=11 | [0,2,1,3,4,5,6,7,8,9,10] or [0,1,2,3,4,5,6,7,8,9,10] | Multiple valid |\n| 26 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=12 | [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 28 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=12 | [0,2,1,3,4,5,6,7,8,9,10,11] or [0,1,2,3,4,5,6,7,8,9,10,11] | Multiple valid |\n| 29 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 30 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, n=13 | [0,1,2,3,4,5,6,7,8,9,10,11,12] | Linear |\n| 31 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=13 | [0,2,1,3,4,5,6,7,8,9,10,11,12] or [0,1,2,3,4,5,6,7,8,9,10,11,12] | Multiple valid |\n| 32 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, n=14 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Linear |\n| 34 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, n=14 | [0,2,1,3,4,5,6,7,8,9,10,11,12,13] or [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Multiple valid |\n| 35 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 36 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, n=15 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Linear |\n| 37 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, n=15 | [0,2,1,3,4,5,6,7,8,9,10,11,12,13,14] or [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Multiple valid |\n| 38 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, n=16 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Linear |\n| 40 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, n=16 | [0,2,1,3,4,5,6,7,8,9,10,11,12,13,14,15] or [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Multiple valid |",
      "example": {
        "input": "{0:[1],1:[2],2:[]}, n=3",
        "output": "[0,1,2]",
        "explanation": "One valid topological order."
      },
      "answer": "from collections import deque, defaultdict\n\ndef topo_sort():\n    graph = eval(input())\n    n = int(input())\n    indegree = [0] * n\n    for u in graph:\n        for v in graph[u]:\n            indegree[v] += 1\n    q = deque([i for i in range(n) if indegree[i] == 0])\n    order = []\n    while q:\n        node = q.popleft()\n        order.append(node)\n        for neighbor in graph.get(node, []):\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n    print(order)\n\ntopo_sort()"

    },
    {
        "id": 6,
        "title": "Number of islands",
        "description": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]] | 1 | Single island |\n| 2 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 3 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 9 | Each 1 is an island |\n| 4 | [[0,0,0],[0,0,0],[0,0,0]] | 0 | All water |\n| 5 | [[1,1,1],[1,1,1],[1,1,1]] | 1 | All land |\n| 6 | [[1,0,0],[0,1,0],[0,0,1]] | 3 | Diagonal islands |\n| 7 | [[1,1,0,0],[0,1,0,1],[1,0,0,1],[0,0,1,1]] | 3 | Mixed |\n| 8 | [[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]] | 8 | Checkerboard |\n| 9 | [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]] | 1 | Hollow square |\n| 10 | [[1,0,1,0,1,0,1,0,1,0]] | 5 | Alternating |\n| 11 | [[1],[1],[1],[1],[1]] | 1 | Single column |\n| 12 | [[1,1,1,1,1]] | 1 | Single row |\n| 13 | [[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0]] | 7 | Alternating |\n| 14 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |\n| 15 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 16 | [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] | 2 | Donut |\n| 17 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 13 | Checkerboard |\n| 18 | [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]] | 1 | All land |\n| 19 | [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] | 0 | All water |\n| 20 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |\n| 21 | [[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]] | 1 | Single island |\n| 22 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 23 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 9 | Each 1 is an island |\n| 24 | [[0,0,0],[0,0,0],[0,0,0]] | 0 | All water |\n| 25 | [[1,1,1],[1,1,1],[1,1,1]] | 1 | All land |\n| 26 | [[1,0,0],[0,1,0],[0,0,1]] | 3 | Diagonal islands |\n| 27 | [[1,1,0,0],[0,1,0,1],[1,0,0,1],[0,0,1,1]] | 3 | Mixed |\n| 28 | [[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]] | 8 | Checkerboard |\n| 29 | [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]] | 1 | Hollow square |\n| 30 | [[1,0,1,0,1,0,1,0,1,0]] | 5 | Alternating |\n| 31 | [[1],[1],[1],[1],[1]] | 1 | Single column |\n| 32 | [[1,1,1,1,1]] | 1 | Single row |\n| 33 | [[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0]] | 7 | Alternating |\n| 34 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |\n| 35 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 36 | [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] | 2 | Donut |\n| 37 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 13 | Checkerboard |\n| 38 | [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]] | 1 | All land |\n| 39 | [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] | 0 | All water |\n| 40 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |",
        "example": {
          "input": "[[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]]",
          "output": "1",
          "explanation": "There is only one island."
        },
        "answer": "def num_islands(grid):\n    if not grid:\n        return 0\n    n, m = len(grid), len(grid[0])\n    def dfs(i, j):\n        if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(i + di, j + dj)\n    island_count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                island_count += 1\n    return island_count\n\nimport ast\ngrid = ast.literal_eval(input())\nprint(num_islands(grid))"

      },
      {
        "id": 7,
        "title": "Flood fill algorithm",
        "description": "Given a 2D grid, a starting cell, and a new color, fill the connected area with the new color.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Example 1 |\n| 2 | [[0,0,0],[0,1,1]], sr=1, sc=1, color=1 | [[0,0,0],[0,1,1]] | No change |\n| 3 | [[0,0,0],[0,1,1]], sr=1, sc=1, color=2 | [[0,0,0],[0,2,2]] | Fill |\n| 4 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=0, color=3 | [[3,3,3],[3,3,3],[3,3,3]] | All same |\n| 5 | [[1,2,1],[2,2,2],[1,2,1]], sr=1, sc=1, color=3 | [[1,3,1],[3,3,3],[1,3,1]] | Center |\n| 6 | [[1,1,1],[1,1,0],[1,0,1]], sr=0, sc=0, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 7 | [[0,0,0],[0,0,0]], sr=0, sc=0, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 8 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=2, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 9 | [[1,2,3],[4,5,6],[7,8,9]], sr=1, sc=1, color=0 | [[1,2,3],[4,0,6],[7,8,9]] | Single cell |\n| 10 | [[1,1,1],[1,1,0],[1,0,1]], sr=2, sc=2, color=2 | [[1,1,1],[1,1,0],[1,0,2]] | Corner |\n| 11 | [[1,1,1],[1,1,1],[1,1,1]], sr=1, sc=1, color=1 | [[1,1,1],[1,1,1],[1,1,1]] | No change |\n| 12 | [[0,0,0],[0,1,1]], sr=0, sc=0, color=2 | [[2,2,2],[2,1,1]] | Fill |\n| 13 | [[1,2,1],[2,2,2],[1,2,1]], sr=0, sc=1, color=4 | [[1,4,1],[4,4,4],[1,4,1]] | Edge |\n| 14 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=2, color=3 | [[1,1,1],[1,1,3],[1,0,1]] | Edge |\n| 15 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=2, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 16 | [[0,0,0],[0,0,0]], sr=1, sc=1, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 17 | [[1,2,3],[4,5,6],[7,8,9]], sr=0, sc=0, color=9 | [[9,2,3],[4,5,6],[7,8,9]] | Single cell |\n| 18 | [[1,1,1],[1,1,0],[1,0,1]], sr=2, sc=0, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 19 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=2, color=3 | [[3,3,3],[3,3,3],[3,3,3]] | All same |\n| 20 | [[1,2,1],[2,2,2],[1,2,1]], sr=2, sc=1, color=5 | [[1,5,1],[5,5,5],[1,5,1]] | Center |\n| 21 | [[1,1,1],[1,1,0],[1,0,1]], sr=0, sc=1, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 22 | [[0,0,0],[0,0,0]], sr=0, sc=1, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 23 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=0, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 24 | [[1,2,3],[4,5,6],[7,8,9]], sr=2, sc=2, color=0 | [[1,2,3],[4,5,6],[7,8,0]] | Single cell |\n| 25 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=0, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 26 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=1, color=1 | [[1,1,1],[1,1,1],[1,1,1]] | No change |\n| 27 | [[0,0,0],[0,1,1]], sr=1, sc=0, color=2 | [[2,2,2],[2,1,1]] | Fill |\n| 28 | [[1,2,1],[2,2,2],[1,2,1]], sr=1, sc=2, color=6 | [[1,6,1],[6,6,6],[1,6,1]] | Edge |\n| 29 | [[1,1,1],[1,1,0],[1,0,1]], sr=2, sc=1, color=3 | [[1,1,1],[1,1,0],[1,3,1]] | Edge |\n| 30 | [[1,1,1],[1,1,1],[1,1,1]], sr=1, sc=2, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 31 | [[0,0,0],[0,0,0]], sr=0, sc=2, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 32 | [[1,2,3],[4,5,6],[7,8,9]], sr=0, sc=2, color=9 | [[1,2,9],[4,5,6],[7,8,9]] | Single cell |\n| 33 | [[1,1,1],[1,1,0],[1,0,1]], sr=0, sc=2, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 34 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=1, color=3 | [[3,3,3],[3,3,3],[3,3,3]] | All same |\n| 35 | [[1,2,1],[2,2,2],[1,2,1]], sr=0, sc=0, color=4 | [[4,2,1],[2,2,2],[1,2,1]] | Edge |\n| 36 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 37 | [[0,0,0],[0,0,0]], sr=1, sc=2, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 38 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=0, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 39 | [[1,2,3],[4,5,6],[7,8,9]], sr=2, sc=0, color=0 | [[0,2,3],[4,5,6],[7,8,9]] | Single cell |\n| 40 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=2, color=2 | [[1,1,1],[1,1,2],[1,0,1]] | Edge |",
        "example": {
          "input": "[[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2",
          "output": "[[2,2,2],[2,2,0],[2,0,1]]",
          "explanation": "Flood fill from (1,1) with color 2."
        },
        "answer": "def floodFill(image, sr, sc, color):\n    original_color = image[sr][sc]\n    if original_color == color:\n        return image\n\n    rows, cols = len(image), len(image[0])\n\n    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols or image[r][c] != original_color:\n            return\n        image[r][c] = color\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n    return image\n\ngrid = eval(input())\nsr, sc, new_color = map(int, input().split())\nresult = floodFill(grid, sr, sc, new_color)\nprint(result)"

      },
      
        {
          "id": 8,
          "title": "Clone a graph",
          "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | 1--2 | 1'--2' | Simple two node |\n| 2 | 1--2--3 | 1'--2'--3' | Three node line |\n| 3 | 1--2--3--1 | 1'--2'--3'--1' | Triangle |\n| 4 | 1--2, 3--4 | 1'--2', 3'--4' | Two components |\n| 5 | 1--2--3--4--5 | 1'--2'--3'--4'--5' | Line |\n| 6 | 1--2--3--4--1 | 1'--2'--3'--4'--1' | Square |\n| 7 | 1--2--3--4--5--1 | 1'--2'--3'--4'--5'--1' | Pentagon |\n| 8 | 1--2--3--4--5--6--1 | 1'--2'--3'--4'--5'--6'--1' | Hexagon |\n| 9 | 1--2--3--4--5--6--7--1 | 1'--2'--3'--4'--5'--6'--7'--1' | Heptagon |\n| 10 | 1--2--3--4--5--6--7--8--1 | 1'--2'--3'--4'--5'--6'--7'--8'--1' | Octagon |\n| 11 | 1--2--3--4--5--6--7--8--9--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--1' | Nonagon |\n| 12 | 1--2--3--4--5--6--7--8--9--10--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--1' | Decagon |\n| 13 | 1--2--3--4--5--6--7--8--9--10--11--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--1' | 11-gon |\n| 14 | 1--2--3--4--5--6--7--8--9--10--11--12--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--1' | 12-gon |\n| 15 | 1--2--3--4--5--6--7--8--9--10--11--12--13--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--1' | 13-gon |\n| 16 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--1' | 14-gon |\n| 17 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--1' | 15-gon |\n| 18 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--1' | 16-gon |\n| 19 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--1' | 17-gon |\n| 20 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--1' | 18-gon |\n| 21 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--1' | 19-gon |\n| 22 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--1' | 20-gon |\n| 23 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--1' | 21-gon |\n| 24 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--1' | 22-gon |\n| 25 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--1' | 23-gon |\n| 26 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--1' | 24-gon |\n| 27 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--1' | 25-gon |\n| 28 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--1' | 26-gon |\n| 29 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--1' | 27-gon |\n| 30 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--1' | 28-gon |\n| 31 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--1' | 29-gon |\n| 32 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--1' | 30-gon |\n| 33 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--1' | 31-gon |\n| 34 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--1' | 32-gon |\n| 35 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--33--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--33'--1' | 33-gon |\n| 36 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--33--34--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--33'--34'--1' | 34-gon |\n| 37 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--33--34--35--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--33'--34'--35'--1' | 35-gon |\n| 38 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--33--34--35--36--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--33'--34'--35'--36'--1' | 36-gon |\n| 39 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--33--34--35--36--37--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--33'--34'--35'--36'--37'--1' | 37-gon |\n| 40 | 1--2--3--4--5--6--7--8--9--10--11--12--13--14--15--16--17--18--19--20--21--22--23--24--25--26--27--28--29--30--31--32--33--34--35--36--37--38--1 | 1'--2'--3'--4'--5'--6'--7'--8'--9'--10'--11'--12'--13'--14'--15'--16'--17'--18'--19'--20'--21'--22'--23'--24'--25'--26'--27'--28'--29'--30'--31'--32'--33'--34'--35'--36'--37'--38'--1' | 38-gon |",
          "example": {
            "input": "1--2--3--1",
            "output": "1'--2'--3'--1'",
            "explanation": "Triangle graph is cloned."
          },
          "answer": "from collections import defaultdict\n\ndef kosaraju_scc(n, edges):\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n\n    visited = [False] * n\n    stack = []\n\n    def dfs1(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor)\n        stack.append(node)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n\n    reversed_adj = defaultdict(list)\n    for u, v in edges:\n        reversed_adj[v].append(u)\n\n    visited = [False] * n\n    sccs = []\n\n    def dfs2(node, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in reversed_adj[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor, component)\n\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs2(node, component)\n            sccs.append(sorted(component))\n\n    return sorted(sccs, key=lambda x: x[0])\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges_str = input()\n    edges_list = []\n    if edges_str:\n        edge_pairs = edges_str.strip('[]').split('], [')\n        for pair_str in edge_pairs:\n            pair = list(map(int, pair_str.strip('[]').split(', ')))\n            edges_list.append(pair)\n    result = kosaraju_scc(n, edges_list)\n    print(result)"

        },
        {
          "id": 9,
          "title": "Bipartite graph check",
          "description": "Given an undirected graph, check if it is bipartite.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 2 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 3 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 4 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 5 | [[1],[0]] | True | Two nodes |\n| 6 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 7 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 8 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 9 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 10 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 11 | [[1],[0]] | True | Two nodes |\n| 12 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 13 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 14 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 15 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 16 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 17 | [[1],[0]] | True | Two nodes |\n| 18 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 19 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 20 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 21 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 22 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 23 | [[1],[0]] | True | Two nodes |\n| 24 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 25 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 26 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 27 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 28 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 29 | [[1],[0]] | True | Two nodes |\n| 30 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 31 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 32 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 33 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 34 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 35 | [[1],[0]] | True | Two nodes |\n| 36 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 37 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 38 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 39 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 40 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |",
          "example": {
            "input": "[[1,3],[0,2],[1,3],[0,2]]",
            "output": "True",
            "explanation": "4-node cycle is bipartite."
          },
          "answer":"def isBipartite(graph):\n    color = {}\n    for node in range(len(graph)):\n        if node not in color:\n            stack = [node]\n            color[node] = 0\n            while stack:\n                u = stack.pop()\n                for v in graph[u]:\n                    if v not in color:\n                        color[v] = color[u] ^ 1\n                        stack.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ninput_str = input(\"\")\ngraph = eval(input_str)\nresult = isBipartite(graph)\nprint(result)"

        },
        {
          "id": 10,
          "title": "Count connected components",
          "description": "Given an undirected graph, count the number of connected components.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n=5, edges=[[0,1],[1,2],[3,4]] | 2 | Two components |\n| 2 | n=5, edges=[[0,1],[1,2],[2,3],[3,4]] | 1 | Single component |\n| 3 | n=5, edges=[] | 5 | All isolated |\n| 4 | n=5, edges=[[0,1],[2,3]] | 3 | Three components |\n| 5 | n=1, edges=[] | 1 | Single node |\n| 6 | n=2, edges=[] | 2 | Two isolated |\n| 7 | n=2, edges=[[0,1]] | 1 | Connected |\n| 8 | n=3, edges=[[0,1]] | 2 | One edge |\n| 9 | n=3, edges=[[0,1],[1,2]] | 1 | Connected |\n| 10 | n=4, edges=[[0,1],[2,3]] | 2 | Two components |\n| 11 | n=4, edges=[[0,1],[1,2],[2,3]] | 1 | Connected |\n| 12 | n=4, edges=[] | 4 | All isolated |\n| 13 | n=5, edges=[[0,1],[1,2],[2,3],[3,4],[4,0]] | 1 | Cycle |\n| 14 | n=6, edges=[[0,1],[2,3],[4,5]] | 3 | Three components |\n| 15 | n=6, edges=[[0,1],[1,2],[2,3],[3,4],[4,5]] | 1 | Connected |\n| 16 | n=6, edges=[] | 6 | All isolated |\n| 17 | n=7, edges=[[0,1],[2,3],[4,5],[5,6]] | 3 | Three components |\n| 18 | n=7, edges=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]] | 1 | Connected |\n| 19 | n=8, edges=[[0,1],[2,3],[4,5],[6,7]] | 4 | Four components |\n| 20 | n=8, edges=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] | 1 | Connected |\n| 21 | n=9, edges=[[0,1],[2,3],[4,5],[6,7],[7,8]] | 4 | Four components |\n| 22 | n=9, edges=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8]] | 1 | Connected |\n| 23 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9]] | 5 | Five components |\n| 24 | n=10, edges=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9]] | 1 | Connected |\n| 25 | n=10, edges=[] | 10 | All isolated |\n| 26 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4],[5,6],[7,8]] | 1 | Connected |\n| 27 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4],[5,6]] | 2 | Two components |\n| 28 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4]] | 3 | Three components |\n| 29 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2]] | 4 | Four components |\n| 30 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9]] | 5 | Five components |\n| 31 | n=10, edges=[[0,1],[2,3],[4,5],[6,7]] | 6 | Six components |\n| 32 | n=10, edges=[[0,1],[2,3],[4,5]] | 7 | Seven components |\n| 33 | n=10, edges=[[0,1],[2,3]] | 8 | Eight components |\n| 34 | n=10, edges=[[0,1]] | 9 | Nine components |\n| 35 | n=10, edges=[] | 10 | All isolated |\n| 36 | n=10, edges=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9]] | 1 | Connected |\n| 37 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4],[5,6],[7,8],[0,9]] | 1 | Connected |\n| 38 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4],[5,6],[7,8]] | 2 | Two components |\n| 39 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4]] | 3 | Three components |\n| 40 | n=10, edges=[[0,1],[2,3],[4,5],[6,7],[8,9],[1,2]] | 4 | Four components |",
          "example": {
            "input": "n=5, edges=[[0,1],[1,2],[3,4]]",
            "output": "2",
            "explanation": "There are two connected components."
          },
          "answer": "from collections import defaultdict\n\ndef has_eulerian_circuit_directed(n, edges):\n    if not edges and n <= 1:\n        return True\n\n    in_degree = [0] * n\n    out_degree = [0] * n\n    adj = defaultdict(list)\n\n    for u, v in edges:\n        adj[u].append(v)\n        in_degree[v] += 1\n        out_degree[u] += 1\n\n    for i in range(n):\n        if in_degree[i] != out_degree[i]:\n            return False\n\n    def get_reachable_nodes(graph, start_node, num_nodes):\n        visited = [False] * num_nodes\n        stack = [start_node]\n        visited[start_node] = True\n        count = 0\n        while stack:\n            u = stack.pop()\n            count += 1\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    stack.append(v)\n        return count\n\n    if not adj:\n        return True\n\n    start_node = next(iter(adj))\n    reachable_count = get_reachable_nodes(adj, start_node, n)\n    if reachable_count < n:\n        return False\n\n    reversed_adj = defaultdict(list)\n    for u, v in edges:\n        reversed_adj[v].append(u)\n\n    reversed_reachable_count = get_reachable_nodes(reversed_adj, start_node, n)\n    return reversed_reachable_count == n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges_str = input()\n    edges_list = []\n    if edges_str:\n        edge_pairs = edges_str.strip('[]').split('], [')\n        for pair_str in edge_pairs:\n            pair = list(map(int, pair_str.strip('[]').split(', ')))\n            edges_list.append(pair)\n    result = has_eulerian_circuit_directed(n, edges_list)\n    print(result)"

        },
        {
          "id": 11,
          "title": "Shortest path in unweighted graph using BFS",
          "description": "Given an unweighted graph as an adjacency list, a start node, and an end node, return the length of the shortest path.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0, end=3 | 2 | Path: 0-1-3 or 0-2-3 |\n| 2 | {0:[1],1:[2],2:[3],3:[]}, start=0, end=3 | 3 | Path: 0-1-2-3 |\n| 3 | {0:[1,2],1:[3],2:[3],3:[]}, start=0, end=3 | 2 | Path: 0-1-3 or 0-2-3 |\n| 4 | {0:[1],1:[2],2:[0]}, start=0, end=2 | 2 | Path: 0-1-2 |\n| 5 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=0, end=4 | 4 | Path: 0-1-2-3-4 |\n| 6 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=0, end=6 | 2 | Path: 0-2-6 |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=0, end=4 | 4 | Path: 0-1-2-3-4 |\n| 8 | {0:[1,2,3],1:[],2:[],3:[]}, start=0, end=3 | 1 | Path: 0-3 |\n| 9 | {0:[],1:[],2:[]}, start=0, end=2 | -1 | No path |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, start=0, end=5 | 5 | Path: 0-1-2-3-4-5 |\n| 11 | {0:[1,2],1:[3],2:[4],3:[],4:[]}, start=0, end=4 | 2 | Path: 0-2-4 |\n| 12 | {0:[1],1:[2],2:[0]}, start=1, end=0 | 2 | Path: 1-2-0 |\n| 13 | {0:[1],1:[2],2:[3],3:[0]}, start=2, end=1 | 2 | Path: 2-3-0-1 |\n| 14 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=2, end=5 | 1 | Path: 2-5 |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=3, end=0 | -1 | No path |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=4, end=0 | -1 | No path |\n| 17 | {0:[1,2],1:[3],2:[4],3:[5],4:[6],5:[],6:[]}, start=0, end=6 | 3 | Path: 0-2-4-6 |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, start=0, end=6 | 6 | Path: 0-1-2-3-4-5-6 |\n| 19 | {0:[1,2,3,4,5],1:[],2:[],3:[],4:[],5:[]}, start=0, end=5 | 1 | Path: 0-5 |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=2, end=0 | 3 | Path: 2-3-4-0 |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, start=0, end=5 | 5 | Path: 0-1-2-3-4-5 |\n| 22 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[],5:[],6:[],7:[],8:[]}, start=0, end=8 | 3 | Path: 0-1-3-8 |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, start=0, end=9 | 9 | Path: 0-1-2-3-4-5-6-7-8-9 |\n| 24 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0, end=10 | 3 | Path: 0-1-4-10 |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, start=0, end=8 | 8 | Path: 0-1-2-3-4-5-6-7-8 |\n| 26 | {0:[1,2,3],1:[4,5],2:[6,7],3:[8,9],4:[],5:[],6:[],7:[],8:[],9:[]}, start=0, end=9 | 2 | Path: 0-3-9 |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, start=0, end=10 | 10 | Path: 0-1-2-3-4-5-6-7-8-9-10 |\n| 28 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[]}, start=0, end=14 | 3 | Path: 0-2-6-14 |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, start=0, end=11 | 11 | Path: 0-1-2-3-4-5-6-7-8-9-10-11 |\n| 30 | {0:[1,2,3,4,5,6,7,8,9,10],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0, end=10 | 1 | Path: 0-10 |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, start=0, end=12 | 12 | Path: 0-1-2-3-4-5-6-7-8-9-10-11-12 |\n| 32 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[]}, start=0, end=16 | 4 | Path: 0-1-3-7-16 |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, start=0, end=13 | 13 | Path: 0-1-2-3-4-5-6-7-8-9-10-11-12-13 |\n| 34 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[]}, start=0, end=20 | 1 | Path: 0-20 |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, start=0, end=14 | 14 | Path: 0-1-2-3-4-5-6-7-8-9-10-11-12-13-14 |\n| 36 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[17,18],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[]}, start=0, end=18 | 5 | Path: 0-2-5-11-12-18 |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, start=0, end=15 | 15 | Path: 0-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15 |\n| 38 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[]}, start=0, end=40 | 1 | Path: 0-40 |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, start=0, end=16 | 16 | Path: 0-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16 |\n| 40 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[],41:[],42:[],43:[],44:[],45:[],46:[],47:[],48:[],49:[],50:[]}, start=0, end=50 | 1 | Path: 0-50 |",
          "example": {
            "input": "{0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0, end=3",
            "output": "2",
            "explanation": "Shortest path is 0-1-3 or 0-2-3."
          },
          "answer": "def findJudge(n, trust):\n    if n == 1 and not trust:\n        return 1\n    trust_counts = [0] * (n + 1)\n    trusted_by_counts = [0] * (n + 1)\n    for a, b in trust:\n        trust_counts[a] += 1\n        trusted_by_counts[b] += 1\n    for i in range(1, n + 1):\n        if trust_counts[i] == 0 and trusted_by_counts[i] == n - 1:\n            return i\n    return -1\n\n# Get user input for n\nn = int(input())\n\n# Get user input for the trust array\ntrust_str = input()\n# Remove brackets and split by comma\ntrust_list_str = trust_str.strip(\"[]\").split(\"],[\")\ntrust = []\nif trust_list_str != ['']:\n    for item in trust_list_str:\n        pair_str = item.split(\",\")\n        trust.append([int(pair_str[0]), int(pair_str[1])])\n\n# Find and print the judge\nresult = findJudge(n, trust)\nprint(result)"
},
        {
          "id": 12,
          "title": "Word Ladder",
          "description": "Given beginWord, endWord, and a wordList, return the length of the shortest transformation sequence from beginWord to endWord.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog'] | 5 | Example 1 |\n| 2 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log'] | 0 | No path |\n| 3 | begin='a', end='c', wordList=['a','b','c'] | 2 | Short words |\n| 4 | begin='hit', end='hot', wordList=['hot'] | 2 | One step |\n| 5 | begin='hit', end='hit', wordList=['hit'] | 1 | Same word |\n| 6 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hog'] | 4 | Shorter path |\n| 7 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog'] | 4 | Multiple paths |\n| 8 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot'] | 4 | Multiple paths |\n| 9 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con'] | 4 | Multiple paths |\n| 10 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog'] | 4 | Multiple paths |\n| 11 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 12 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 13 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 14 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 15 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 16 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 17 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 18 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 19 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 20 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 21 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 22 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 23 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 24 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 25 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 26 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 27 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 28 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 29 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 30 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 31 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 32 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 33 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 34 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 35 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 36 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |\n| 37 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con'] | 4 | Multiple paths |\n| 38 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog'] | 4 | Multiple paths |\n| 39 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog'] | 4 | Multiple paths |\n| 40 | begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog','hig','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot','con','cog','hog','cot'] | 4 | Multiple paths |",
          "example": {
            "input": "begin='hit', end='cog', wordList=['hot','dot','dog','lot','log','cog']",
            "output": "5",
            "explanation": "hit->hot->dot->dog->cog is a valid sequence."
          },
          "answer": "def isValidTree(n, edges):\n    if len(edges) != n - 1:\n        return False\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n    count = 0\n\n    while queue:\n        u = queue.pop(0)\n        count += 1\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n\n    return count == n\n\n# Get user input for n\nn = int(input())\n\n# Get user input for the edges array\nedges_str = input()\n# Remove brackets and split by comma-separated pairs\nedges_list_str = edges_str.strip(\"[]\").split(\"],[\")\nedges = []\nif edges_list_str != ['']:\n    for item in edges_list_str:\n        pair_str = item.split(\",\")\n        edges.append([int(pair_str[0]), int(pair_str[1])])\n\n# Check if it's a valid tree and print the result\nresult = isValidTree(n, edges)\nprint(result)"

        },
        {
          "id": 13,
          "title": "All paths from source to target",
          "description": "Given a directed acyclic graph, return all possible paths from node 0 to node n-1.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 2 | [[4,3,1],[3,2,4],[3],[4],[]] | [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] | Multiple paths |\n| 3 | [[1],[]] | [[0,1]] | Simple |\n| 4 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 5 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 6 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 7 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 8 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 9 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 10 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 11 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 12 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 13 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 14 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 15 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 16 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 17 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 18 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 19 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 20 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 21 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 22 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 23 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 24 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 25 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 26 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 27 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 28 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 29 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 30 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 31 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 32 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 33 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 34 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 35 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 36 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 37 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 38 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |\n| 39 | [[1,2],[3],[3],[]] | [[0,1,3],[0,2,3]] | Example 1 |\n| 40 | [[1,2,3],[2],[3],[]] | [[0,1,2,3],[0,2,3],[0,3]] | Multiple |",
          "example": {
            "input": "[[1,2],[3],[3],[]]",
            "output": "[[0,1,3],[0,2,3]]",
            "explanation": "All paths from 0 to 3."
          },
          "answer":"def validPath(n, edges, start, end):\n    if start == end:\n        return True\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    queue = [start]\n    visited[start] = True\n\n    while queue:\n        curr = queue.pop(0)\n        if curr == end:\n            return True\n        for neighbor in adj[curr]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n    return False\n\n# Get user input for n\nn = int(input())\n\n# Get user input for the edges array\nedges_str = input()\nedges_list_str = edges_str.strip(\"[]\").split(\"],[\")\nedges = []\nif edges_list_str != ['']:\n    for item in edges_list_str:\n        pair_str = item.split(\",\")\n        edges.append([int(pair_str[0]), int(pair_str[1])])\n\n# Get user input for start and end nodes\nstart = int(input())\nend = int(input())\n\n# Check if a path exists and print the result\nresult = validPath(n, edges, start, end)\nprint(result)"

        },
        {
          "id": 14,
          "title": "Find eventual safe states",
          "description": "Given a directed graph, return all the nodes that are eventually safe (no cycles from them).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 2 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 3 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 4 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 5 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 6 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 7 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 8 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 9 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 10 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 11 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 12 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 13 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 14 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 15 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 16 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 17 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 18 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 19 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 20 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 21 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 22 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 23 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 24 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 25 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 26 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 27 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 28 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 29 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 30 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 31 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 32 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 33 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 34 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 35 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 36 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 37 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 38 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |\n| 39 | [[1,2],[2,3],[5],[0],[5],[],[]] | [2,4,5,6] | Example 1 |\n| 40 | [[1,2,3,4],[1,2],[3,4],[0,4],[]] | [4] | Only 4 is safe |",
          "example": {
            "input": "[[1,2],[2,3],[5],[0],[5],[],[]]",
            "output": "[2,4,5,6]",
            "explanation": "Nodes 2,4,5,6 are eventually safe."
          },
          "answer": "def findCenter(edges):\n    # In a star graph, the center node will appear in every edge.\n    # We can check the first two edges to find the common node.\n    if len(edges) > 1:\n        u1, v1 = edges[0]\n        u2, v2 = edges[1]\n        if u1 == u2 or u1 == v2:\n            return u1\n        else:\n            return v1\n    # If there's only one edge, either node is the center.\n    # Based on the problem description, n >= 2 for a star graph.\n    elif edges:\n        return edges[0][0]\n    return -1\n\n# Get user input for the edges array\nedges_str = input()\nedges_list_str = edges_str.strip(\"[]\").split(\"],[\")\nedges = []\nif edges_list_str != ['']:\n    for item in edges_list_str:\n        pair_str = item.split(\",\")\n        edges.append([int(pair_str[0]), int(pair_str[1])])\n\n# Find and print the center of the star graph\nresult = findCenter(edges)\nprint(result)"

        },
        {
          "id": 15,
          "title": "Is graph tree?",
          "description": "Given an undirected graph, check if it is a tree (connected and acyclic).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n=5, edges=[[0,1],[0,2],[0,3],[1,4]] | True | Tree |\n| 2 | n=5, edges=[[0,1],[1,2],[2,3],[1,3],[1,4]] | False | Cycle |\n| 3 | n=4, edges=[[0,1],[1,2],[2,3]] | True | Linear tree |\n| 4 | n=4, edges=[[0,1],[1,2],[2,3],[3,0]] | False | Cycle |\n| 5 | n=1, edges=[] | True | Single node |\n| 6 | n=2, edges=[[0,1]] | True | Two node tree |\n| 7 | n=2, edges=[] | False | Disconnected |\n| 8 | n=3, edges=[[0,1],[1,2]] | True | Tree |\n| 9 | n=3, edges=[[0,1],[1,2],[2,0]] | False | Cycle |\n| 10 | n=4, edges=[[0,1],[2,3]] | False | Disconnected |\n| 11 | n=4, edges=[[0,1],[1,2],[2,3],[3,1]] | False | Cycle |\n| 12 | n=5, edges=[[0,1],[0,2],[0,3],[1,4]] | True | Tree |\n| 13 | n=5, edges=[[0,1],[1,2],[2,3],[1,3],[1,4]] | False | Cycle |\n| 14 | n=4, edges=[[0,1],[1,2],[2,3]] | True | Linear tree |\n| 15 | n=4, edges=[[0,1],[1,2],[2,3],[3,0]] | False | Cycle |\n| 16 | n=1, edges=[] | True | Single node |\n| 17 | n=2, edges=[[0,1]] | True | Two node tree |\n| 18 | n=2, edges=[] | False | Disconnected |\n| 19 | n=3, edges=[[0,1],[1,2]] | True | Tree |\n| 20 | n=3, edges=[[0,1],[1,2],[2,0]] | False | Cycle |\n| 21 | n=4, edges=[[0,1],[2,3]] | False | Disconnected |\n| 22 | n=4, edges=[[0,1],[1,2],[2,3],[3,1]] | False | Cycle |\n| 23 | n=5, edges=[[0,1],[0,2],[0,3],[1,4]] | True | Tree |\n| 24 | n=5, edges=[[0,1],[1,2],[2,3],[1,3],[1,4]] | False | Cycle |\n| 25 | n=4, edges=[[0,1],[1,2],[2,3]] | True | Linear tree |\n| 26 | n=4, edges=[[0,1],[1,2],[2,3],[3,0]] | False | Cycle |\n| 27 | n=1, edges=[] | True | Single node |\n| 28 | n=2, edges=[[0,1]] | True | Two node tree |\n| 29 | n=2, edges=[] | False | Disconnected |\n| 30 | n=3, edges=[[0,1],[1,2]] | True | Tree |\n| 31 | n=3, edges=[[0,1],[1,2],[2,0]] | False | Cycle |\n| 32 | n=4, edges=[[0,1],[2,3]] | False | Disconnected |\n| 33 | n=4, edges=[[0,1],[1,2],[2,3],[3,1]] | False | Cycle |\n| 34 | n=5, edges=[[0,1],[0,2],[0,3],[1,4]] | True | Tree |\n| 35 | n=5, edges=[[0,1],[1,2],[2,3],[1,3],[1,4]] | False | Cycle |\n| 36 | n=4, edges=[[0,1],[1,2],[2,3]] | True | Linear tree |\n| 37 | n=4, edges=[[0,1],[1,2],[2,3],[3,0]] | False | Cycle |\n| 38 | n=1, edges=[] | True | Single node |\n| 39 | n=2, edges=[[0,1]] | True | Two node tree |\n| 40 | n=2, edges=[] | False | Disconnected |",
          "example": {
            "input": "n=5, edges=[[0,1],[0,2],[0,3],[1,4]]",
            "output": "True",
            "explanation": "Graph is connected and acyclic."
          },
          "answer": "def uniquePaths(m, n):\n    # This is a classic combinatorial problem.\n    # To reach the bottom-right (m-1, n-1) from (0, 0), we need to make a total of (m-1) down moves and (n-1) right moves.\n    # The total number of moves is (m-1) + (n-1) = m + n - 2.\n    # The number of unique paths is the number of ways to choose the positions of the down (or right) moves in the sequence of total moves.\n    # This can be calculated using combinations: C(m + n - 2, m - 1) or C(m + n - 2, n - 1).\n\n    def combinations(total, choose):\n        if choose < 0 or choose > total:\n            return 0\n        if choose == 0 or choose == total:\n            return 1\n        if choose > total // 2:\n            choose = total - choose\n        result = 1\n        for i in range(choose):\n            result = result * (total - i) // (i + 1)\n        return result\n\n    return combinations(m + n - 2, m - 1)\n\n# Get user input for m and n\nm = int(input())\nn = int(input())\n\n# Calculate and print the number of unique paths\nresult = uniquePaths(m, n)\nprint(result)"

        },
        
            {
              "id": 16,
              "title": "Count all paths between two vertices",
              "description": "Given a directed graph, count all possible paths from a source vertex to a destination vertex.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | graph = {0: [1, 2], 1: [2], 2: [3], 3: []}, src=0, dst=3 | 2 | Two paths: 0->1->2->3, 0->2->3 |\n| 2 | graph = {0: [1], 1: [2], 2: [3], 3: []}, src=0, dst=3 | 1 | Only one path |\n| 3 | graph = {0: [1, 2], 1: [3], 2: [3], 3: []}, src=0, dst=3 | 2 | Two paths |\n| 4 | graph = {0: [1], 1: [2], 2: [], 3: []}, src=0, dst=3 | 0 | No path |\n| 5 | graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: []}, src=2, dst=3 | 1 | Only 2->3 |\n| 6 | graph = {0: [1], 1: [2], 2: [0, 3], 3: []}, src=0, dst=3 | 2 | 0->1->2->3, 0->1->2->0->1->2->3 (cycle) |\n| 7 | graph = {0: [1], 1: [2], 2: [3], 3: [4], 4: []}, src=0, dst=4 | 1 | One path |\n| 8 | graph = {0: [1, 2], 1: [3], 2: [3], 3: [4], 4: []}, src=0, dst=4 | 2 | Two paths |\n| 9 | graph = {0: [1], 1: [2], 2: [0]}, src=0, dst=2 | Infinite | Cycle, but count simple paths only |\n| 10 | graph = {0: [1], 1: [2], 2: [3], 3: [0]}, src=0, dst=2 | 1 | 0->1->2 |\n| ... | ... | ... | ... |\n",
              "example": "Input: graph = {0: [1, 2], 1: [2], 2: [3], 3: []}, src=0, dst=3\nOutput: 2",
              "answer": "def kruskals_mst(n, edges):\n    edges.sort(key=lambda x: x[2])  # Sort edges by weight\n    parent = list(range(n))  # Initialize parent array for Union-Find\n\n    def find(i):  # Find the root of the set to which i belongs\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])  # Path compression for efficiency\n        return parent[i]\n\n    def union(i, j):  # Union the sets containing i and j\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j  # Make one root the parent of the other\n            return True  # Indicate that a union occurred\n        return False  # Indicate that no union occurred (i.e., they were already in the same set)\n\n    mst_edges = []  # Store the edges of the MST\n    for u, v, weight in edges:\n        if union(u, v):  # If adding this edge doesn't create a cycle\n            mst_edges.append([u, v, weight])  # Add it to the MST\n    return mst_edges\n\n# Get user input for the number of nodes\nn = int(input())\n\n# Get user input for the edges\nedges_str = input()\nedges_list_str = edges_str.strip(\"[]\").split(\"],[\")\nedges = []\nif edges_list_str != ['']:\n    for item in edges_list_str:\n        u_str, v_str, weight_str = item.split(\",\")\n        edges.append([int(u_str), int(v_str), int(weight_str)])\n\n# Find the MST using Kruskal's algorithm\nresult = kruskals_mst(n, edges)\n\n# Print the MST edges\nprint(result)"

            },
            {
                "id": 17,
                "title": "Course Schedule",
                "description": "Given the total number of courses and a list of prerequisite pairs, determine if it is possible to finish all courses (i.e., the graph is a DAG).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | numCourses=2, prerequisites=[[1,0]] | True | Simple chain |\n| 2 | numCourses=2, prerequisites=[[1,0],[0,1]] | False | Simple cycle |\n| 3 | numCourses=4, prerequisites=[[1,0],[2,1],[3,2]] | True | Linear chain |\n| 4 | numCourses=3, prerequisites=[[0,1],[1,2],[2,0]] | False | Cycle |\n| 5 | numCourses=1, prerequisites=[] | True | Single course |\n| 6 | numCourses=3, prerequisites=[] | True | No prerequisites |\n| 7 | numCourses=3, prerequisites=[[1,0],[2,0]] | True | Tree |\n| 8 | numCourses=3, prerequisites=[[1,0],[2,1],[0,2]] | False | Cycle |\n| 9 | numCourses=5, prerequisites=[[1,0],[2,1],[3,2],[4,3]] | True | Long chain |\n| 10 | numCourses=5, prerequisites=[[1,0],[0,2],[2,1]] | False | Cycle |\n| 11 | numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] | True | DAG |\n| 12 | numCourses=4, prerequisites=[[1,0],[2,1],[0,2]] | False | Cycle |\n| 13 | numCourses=2, prerequisites=[] | True | No prerequisites |\n| 14 | numCourses=2, prerequisites=[[0,1]] | True | Simple chain |\n| 15 | numCourses=2, prerequisites=[[0,1],[1,0]] | False | Simple cycle |\n| 16 | numCourses=3, prerequisites=[[0,1],[1,2]] | True | Chain |\n| 17 | numCourses=3, prerequisites=[[0,1],[1,2],[2,0]] | False | Cycle |\n| 18 | numCourses=4, prerequisites=[[0,1],[1,2],[2,3]] | True | Chain |\n| 19 | numCourses=4, prerequisites=[[0,1],[1,2],[2,3],[3,0]] | False | Cycle |\n| 20 | numCourses=5, prerequisites=[[0,1],[1,2],[2,3],[3,4]] | True | Chain |\n| 21 | numCourses=5, prerequisites=[[0,1],[1,2],[2,3],[3,4],[4,0]] | False | Cycle |\n| 22 | numCourses=3, prerequisites=[[1,0],[2,0],[2,1]] | True | DAG |\n| 23 | numCourses=3, prerequisites=[[1,0],[2,1],[0,2]] | False | Cycle |\n| 24 | numCourses=4, prerequisites=[[1,0],[2,1],[3,2],[1,3]] | False | Cycle |\n| 25 | numCourses=4, prerequisites=[[1,0],[2,1],[3,2]] | True | Chain |\n| 26 | numCourses=4, prerequisites=[[1,0],[2,1],[3,2],[0,3]] | False | Cycle |\n| 27 | numCourses=6, prerequisites=[[1,0],[2,1],[3,2],[4,3],[5,4]] | True | Long chain |\n| 28 | numCourses=6, prerequisites=[[1,0],[2,1],[3,2],[4,3],[5,4],[0,5]] | False | Cycle |\n| 29 | numCourses=3, prerequisites=[[0,1],[1,2]] | True | Chain |\n| 30 | numCourses=3, prerequisites=[[0,1],[1,2],[2,0]] | False | Cycle |\n| 31 | numCourses=4, prerequisites=[[0,1],[1,2],[2,3]] | True | Chain |\n| 32 | numCourses=4, prerequisites=[[0,1],[1,2],[2,3],[3,0]] | False | Cycle |\n| 33 | numCourses=5, prerequisites=[[0,1],[1,2],[2,3],[3,4]] | True | Chain |\n| 34 | numCourses=5, prerequisites=[[0,1],[1,2],[2,3],[3,4],[4,0]] | False | Cycle |\n| 35 | numCourses=2, prerequisites=[[1,0]] | True | Simple chain |\n| 36 | numCourses=2, prerequisites=[[1,0],[0,1]] | False | Simple cycle |\n| 37 | numCourses=1, prerequisites=[] | True | Single course |\n| 38 | numCourses=3, prerequisites=[[1,0],[2,0]] | True | Tree |\n| 39 | numCourses=3, prerequisites=[[1,0],[2,1],[0,2]] | False | Cycle |\n| 40 | numCourses=3, prerequisites=[] | True | No prerequisites |",
                "example": {
                  "input": "numCourses=2, prerequisites=[[1,0]]",
                  "output": "True",
                  "explanation": "Course 1 depends on 0, no cycles."
                },
                "answer": "import heapq\n\ndef prims_mst(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v, weight in edges:\n        adj[u].append((v, weight))\n        adj[v].append((u, weight))\n\n    visited = [False] * n\n    min_heap = [(0, 0, -1)]  # (weight, node, parent). Start at node 0 with weight 0 and no parent.\n    mst_edges = []\n    total_weight = 0\n\n    while min_heap:\n        weight, u, parent = heapq.heappop(min_heap)\n        if visited[u]:\n            continue  # Skip if the node is already visited\n\n        visited[u] = True\n        total_weight += weight\n        if parent != -1:  # Add the edge to the MST (except for the starting node)\n            mst_edges.append([parent, u, weight])\n\n        for v, edge_weight in adj[u]:\n            if not visited[v]:\n                heapq.heappush(min_heap, (edge_weight, v, u))\n\n    return mst_edges\n\n# Get user input for the number of nodes\nn = int(input())\n\n# Get user input for the edges\nedges_str = input()\nedges_list_str = edges_str.strip(\"[]\").split(\"],[\")\nedges = []\nif edges_list_str != ['']:\n    for item in edges_list_str:\n        u_str, v_str, weight_str = item.split(\",\")\n        edges.append([int(u_str), int(v_str), int(weight_str)])\n\n# Find the MST using Prim's algorithm\nresult = prims_mst(n, edges)\n\n# Print the MST edges\nprint(result)"

              },
              {
                "id": 18,
                "title": "Dijkstras Algorithm (BFS variation)",
                "description": "Given a weighted graph and a source vertex, find the shortest path from the source to all other vertices using Dijkstras algorithm.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | graph = {0: [(1,1), (2,4)], 1: [(2,2), (3,5)], 2: [(3,1)], 3: []}, src=0 | [0,1,3,4] | Shortest paths from 0 |\n| 2 | graph = {0: [(1,2)], 1: [(2,3)], 2: [(3,1)], 3: []}, src=0 | [0,2,5,6] | Linear graph |\n| 3 | graph = {0: [(1,1)], 1: [(2,1)], 2: [(3,1)], 3: []}, src=0 | [0,1,2,3] | All weights 1 |\n| 4 | graph = {0: [(1,10)], 1: [(2,10)], 2: [(3,10)], 3: []}, src=0 | [0,10,20,30] | Large weights |\n| 5 | graph = {0: [(1,1)], 1: [(2,1)], 2: [(0,1)], 3: []}, src=0 | [0,1,2,inf] | Disconnected node |\n| 6 | graph = {0: [(1,2), (2,5)], 1: [(2,1)], 2: [(3,2)], 3: []}, src=0 | [0,2,3,5] | Multiple paths |\n| 7 | graph = {0: [(1,1)], 1: [(2,1)], 2: [(0,1)], 3: [(2,1)]}, src=3 | [inf,inf,1,0] | Start from 3 |\n| 8 | graph = {0: [(1,1)], 1: [(2,1)], 2: [(3,1)], 3: [(0,1)]}, src=1 | [3,0,1,2] | Cycle |\n| 9 | graph = {0: [(1,1)], 1: [(2,1)], 2: [(3,1)], 3: [(1,1)]}, src=0 | [0,1,2,3] | Cycle |\n| 10 | graph = {0: [(1,1)], 1: [(2,1)], 2: [(3,1)], 3: [(0,1)]}, src=2 | [2,3,0,1] | Start from 2 |\n| 11 | graph = {0: [(1,2), (2,2)], 1: [(2,2)], 2: [(3,2)], 3: []}, src=0 | [0,2,2,4] | Multiple edges |\n| 12 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,4)]}, src=0 | [0,1,3,6] | Cycle back to start |\n| 13 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(1,4)]}, src=0 | [0,1,3,6] | Cycle not used |\n| 14 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(1,1)]}, src=0 | [0,1,3,6] | Cycle not used |\n| 15 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(2,1)]}, src=0 | [0,1,3,6] | Cycle not used |\n| 16 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(3,1)]}, src=0 | [0,1,3,6] | Self loop |\n| 17 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(2,1)]}, src=3 | [inf,inf,1,0] | Start from 3 |\n| 18 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=3 | [1,2,3,0] | Start from 3 |\n| 19 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=2 | [6,7,0,3] | Start from 2 |\n| 20 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=1 | [4,0,2,5] | Start from 1 |\n| 21 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=0 | [0,1,3,6] | Start from 0 |\n| 22 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=1 | [4,0,2,5] | Start from 1 |\n| 23 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=2 | [6,7,0,3] | Start from 2 |\n| 24 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=3 | [1,2,3,0] | Start from 3 |\n| 25 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=0 | [0,1,3,6] | Start from 0 |\n| 26 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=1 | [4,0,2,5] | Start from 1 |\n| 27 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=2 | [6,7,0,3] | Start from 2 |\n| 28 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=3 | [1,2,3,0] | Start from 3 |\n| 29 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=0 | [0,1,3,6] | Start from 0 |\n| 30 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=1 | [4,0,2,5] | Start from 1 |\n| 31 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=2 | [6,7,0,3] | Start from 2 |\n| 32 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=3 | [1,2,3,0] | Start from 3 |\n| 33 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=0 | [0,1,3,6] | Start from 0 |\n| 34 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=1 | [4,0,2,5] | Start from 1 |\n| 35 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=2 | [6,7,0,3] | Start from 2 |\n| 36 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=3 | [1,2,3,0] | Start from 3 |\n| 37 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=0 | [0,1,3,6] | Start from 0 |\n| 38 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=1 | [4,0,2,5] | Start from 1 |\n| 39 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=2 | [6,7,0,3] | Start from 2 |\n| 40 | graph = {0: [(1,1)], 1: [(2,2)], 2: [(3,3)], 3: [(0,1)]}, src=3 | [1,2,3,0] | Start from 3 |\n",
                "example": {
                    "Input": "graph = {0: [(1,1), (2,4)], 1: [(2,2), (3,5)], 2: [(3,1)], 3: []}, src=0",
                    "Output": "[0,1,3,4]"
                },
                "answer": "import sys\n\ndef shortest_path_dag(n, edges, source):\n    adj = [[] for _ in range(n)]  # Adjacency list: (neighbor, weight)\n    for u, v, weight in edges:\n        adj[u].append((v, weight))\n\n    indegree = [0] * n  # Calculate in-degrees for topological sort\n    for u in range(n):\n        for v, _ in adj[u]:\n            indegree[v] += 1\n\n    queue = [u for u in range(n) if indegree[u] == 0]  # Start with nodes with in-degree 0\n    top_order = []\n    while queue:\n        u = queue.pop(0)\n        top_order.append(u)\n        for v, _ in adj[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n\n    dist = [float('inf')] * n  # Initialize distances to infinity\n    dist[source] = 0  # Distance from source to itself is 0\n\n    for u in top_order:\n        if dist[u] != float('inf'):  # If node u is reachable\n            for v, weight in adj[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight  # Relax the edge\n\n    return dist\n\n# Get user input for the number of nodes\nn = int(input())\n\n# Get user input for the edges\nedges_str = input()\nedges_list_str = edges_str.strip(\"[]\").split(\"],[\")\nedges = []\nif edges_list_str != ['']:\n    for item in edges_list_str:\n        u_str, v_str, weight_str = item.split(\",\")\n        edges.append([int(u_str), int(v_str), int(weight_str)])\n\n# Get user input for the source node\nsource = int(input())\n\n# Calculate and print the shortest paths\nresult = shortest_path_dag(n, edges, source)\nprint(result)"

              },
              {
                "id": 19,
                "title": "Bellman Ford basic check",
                "description": "Given a weighted directed graph, find the shortest path from a source to all vertices using Bellman-Ford algorithm. Detect negative cycles.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | edges = [(0,1,1),(1,2,2),(2,3,3)], n=4, src=0 | [0,1,3,6] | No negative cycle |\n| 2 | edges = [(0,1,1),(1,2,-1),(2,3,-1),(3,0,-1)], n=4, src=0 | 'Negative cycle' | Negative cycle exists |\n| 3 | edges = [(0,1,4),(0,2,5),(1,2,-3),(2,3,4)], n=4, src=0 | [0,4,1,5] | No negative cycle |\n| 4 | edges = [(0,1,1),(1,2,1),(2,3,1),(3,1,-3)], n=4, src=0 | 'Negative cycle' | Negative cycle |\n| 5 | edges = [(0,1,2),(1,2,3),(2,3,4)], n=4, src=0 | [0,2,5,9] | No negative cycle |\n| 6 | edges = [(0,1,1),(1,2,2),(2,0,-4)], n=3, src=0 | 'Negative cycle' | Negative cycle |\n| 7 | edges = [(0,1,1),(1,2,2),(2,3,3)], n=4, src=1 | [inf,0,2,5] | Start from 1 |\n| 8 | edges = [(0,1,1),(1,2,2),(2,3,3)], n=4, src=2 | [inf,inf,0,3] | Start from 2 |\n| 9 | edges = [(0,1,1),(1,2,2),(2,3,3)], n=4, src=3 | [inf,inf,inf,0] | Start from 3 |\n| 10 | edges = [(0,1,1),(1,2,2),(2,3,3)], n=4, src=0 | [0,1,3,6] | Repeat |\n| 11 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,1)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 12 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,-7)], n=4, src=0 | 'Negative cycle' | Negative cycle |\n| 13 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,1,-6)], n=4, src=0 | 'Negative cycle' | Negative cycle |\n| 14 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,2,-4)], n=4, src=0 | [0,1,3,6] | No negative cycle |\n| 15 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,2,-2)], n=4, src=0 | [0,1,3,6] | No negative cycle |\n| 16 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,2,-6)], n=4, src=0 | 'Negative cycle' | Negative cycle |\n| 17 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,1,-7)], n=4, src=0 | 'Negative cycle' | Negative cycle |\n| 18 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,-6)], n=4, src=0 | 'Negative cycle' | Negative cycle |\n| 19 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,0)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 20 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,1)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 21 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,2)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 22 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,3)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 23 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,4)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 24 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,5)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 25 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,6)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 26 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,7)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 27 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,8)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 28 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,9)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 29 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,10)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 30 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,11)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 31 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,12)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 32 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,13)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 33 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,14)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 34 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,15)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 35 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,16)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 36 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,17)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 37 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,18)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 38 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,19)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 39 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,20)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n| 40 | edges = [(0,1,1),(1,2,2),(2,3,3),(3,0,21)], n=4, src=0 | [0,1,3,6] | Cycle, no negative |\n",
                "example":{
                 "Input": "edges = [(0,1,1),(1,2,2),(2,3,3)], n=4, src=0",
                 "Output": "[0,1,3,6]"},
                "answer": "def find_number_of_provinces(graph):\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n    return count\n\n# Get user input for the adjacency matrix\ngraph_str = input()\ngraph_list_str = graph_str.strip(\"[]\").split(\"],[\")\ngraph = []\nfor row_str in graph_list_str:\n    row = [int(x) for x in row_str.split(\",\")]\n    graph.append(row)\n\n# Find and print the number of provinces\nresult = find_number_of_provinces(graph)\nprint(result)"

              },
              {
                "id": 20,
                "title": "Build and traverse adjacency list",
                "description": "Given a list of edges, build an adjacency list for the graph and traverse it (BFS and DFS).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | edges = [(0,1),(0,2),(1,2),(2,0),(2,3),(3,3)], n=4 | BFS: [0,1,2,3], DFS: [0,1,2,3] | Simple graph |\n| 2 | edges = [(0,1),(1,2),(2,3)], n=4 | BFS: [0,1,2,3], DFS: [0,1,2,3] | Linear |\n| 3 | edges = [(0,1),(1,2),(2,0)], n=3 | BFS: [0,1,2], DFS: [0,1,2] | Cycle |\n| 4 | edges = [(0,1),(1,2),(2,3),(3,4)], n=5 | BFS: [0,1,2,3,4], DFS: [0,1,2,3,4] | Linear |\n| 5 | edges = [(0,1),(1,2),(2,3),(3,0)], n=4 | BFS: [0,1,2,3], DFS: [0,1,2,3] | Cycle |\n| 6 | edges = [(0,1),(1,2),(2,3),(3,4),(4,0)], n=5 | BFS: [0,1,2,3,4], DFS: [0,1,2,3,4] | Cycle |\n| 7 | edges = [(0,1)], n=2 | BFS: [0,1], DFS: [0,1] | Simple |\n| 8 | edges = [(0,1),(1,2)], n=3 | BFS: [0,1,2], DFS: [0,1,2] | Simple |\n| 9 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5)], n=6 | BFS: [0,1,2,3,4,5], DFS: [0,1,2,3,4,5] | Linear |\n| 10 | edges = [(0,1),(1,2),(2,3),(3,4),(4,0)], n=5 | BFS: [0,1,2,3,4], DFS: [0,1,2,3,4] | Cycle |\n| 11 | edges = [(0,1),(0,2),(0,3)], n=4 | BFS: [0,1,2,3], DFS: [0,1,2,3] | Star |\n| 12 | edges = [(0,1),(1,2),(1,3)], n=4 | BFS: [0,1,2,3], DFS: [0,1,2,3] | Branch |\n| 13 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], n=6 | BFS: [0,1,5,2,4,3], DFS: [0,1,2,3,4,5] | Cycle |\n| 14 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)], n=7 | BFS: [0,1,2,3,4,5,6], DFS: [0,1,2,3,4,5,6] | Linear |\n| 15 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], n=6 | BFS: [0,1,5,2,4,3], DFS: [0,1,2,3,4,5] | Cycle |\n| 16 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,0)], n=7 | BFS: [0,1,6,2,5,3,4], DFS: [0,1,2,3,4,5,6] | Cycle |\n| 17 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)], n=8 | BFS: [0,1,2,3,4,5,6,7], DFS: [0,1,2,3,4,5,6,7] | Linear |\n| 18 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,0)], n=8 | BFS: [0,1,7,2,6,3,5,4], DFS: [0,1,2,3,4,5,6,7] | Cycle |\n| 19 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8)], n=9 | BFS: [0,1,2,3,4,5,6,7,8], DFS: [0,1,2,3,4,5,6,7,8] | Linear |\n| 20 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,0)], n=9 | BFS: [0,1,8,2,7,3,6,4,5], DFS: [0,1,2,3,4,5,6,7,8] | Cycle |\n| 21 | edges = [(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)], n=7 | BFS: [0,1,2,3,4,5,6], DFS: [0,1,3,4,2,5,6] | Binary tree |\n| 22 | edges = [(0,1),(1,2),(2,0)], n=3 | BFS: [0,1,2], DFS: [0,1,2] | Cycle |\n| 23 | edges = [(0,1),(1,2),(2,3),(3,0)], n=4 | BFS: [0,1,3,2], DFS: [0,1,2,3] | Cycle |\n| 24 | edges = [(0,1),(1,2),(2,3),(3,4),(4,0)], n=5 | BFS: [0,1,4,2,3], DFS: [0,1,2,3,4] | Cycle |\n| 25 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], n=6 | BFS: [0,1,5,2,4,3], DFS: [0,1,2,3,4,5] | Cycle |\n| 26 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,0)], n=7 | BFS: [0,1,6,2,5,3,4], DFS: [0,1,2,3,4,5,6] | Cycle |\n| 27 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,0)], n=8 | BFS: [0,1,7,2,6,3,5,4], DFS: [0,1,2,3,4,5,6,7] | Cycle |\n| 28 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,0)], n=9 | BFS: [0,1,8,2,7,3,6,4,5], DFS: [0,1,2,3,4,5,6,7,8] | Cycle |\n| 29 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,0)], n=10 | BFS: [0,1,9,2,8,3,7,4,6,5], DFS: [0,1,2,3,4,5,6,7,8,9] | Cycle |\n| 30 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)], n=10 | BFS: [0,1,2,3,4,5,6,7,8,9], DFS: [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 31 | edges = [(0,1)], n=2 | BFS: [0,1], DFS: [0,1] | Simple |\n| 32 | edges = [(0,1)], n=3 | BFS: [0,1], DFS: [0,1] | Disconnected |\n| 33 | edges = [], n=1 | BFS: [0], DFS: [0] | Single node |\n| 34 | edges = [], n=2 | BFS: [0], DFS: [0] | Disconnected |\n| 35 | edges = [(0,1),(2,3)], n=4 | BFS: [0,1], DFS: [0,1] | Two components |\n| 36 | edges = [(0,1),(2,3)], n=5 | BFS: [0,1], DFS: [0,1] | Two components, one isolated |\n| 37 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)], n=11 | BFS: [0,1,2,3,4,5,6,7,8,9,10], DFS: [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 38 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,0)], n=11 | BFS: [0,1,10,2,9,3,8,4,7,5,6], DFS: [0,1,2,3,4,5,6,7,8,9,10] | Cycle |\n| 39 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)], n=12 | BFS: [0,1,2,3,4,5,6,7,8,9,10,11], DFS: [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 40 | edges = [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,0)], n=12 | BFS: [0,1,11,2,10,3,9,4,8,5,7,6], DFS: [0,1,2,3,4,5,6,7,8,9,10,11] | Cycle |\n",
                "example":
                { "Input": "edges = [(0,1),(0,2),(1,2),(2,0),(2,3),(3,3)], n=4",
                 "Output": "BFS: [0,1,2,3], DFS: [0,1,2,3]"
              },
                "answer":"import heapq\n\ndef minimum_effort_path(heights):\n    rows, cols = len(heights), len(heights[0])\n    diffs = [[float('inf')] * cols for _ in range(rows)]\n    diffs[0][0] = 0\n    pq = [(0, 0, 0)]  # (effort, r, c)\n\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n\n        if effort > diffs[r][c]:\n            continue\n\n        if r == rows - 1 and c == cols - 1:\n            return effort\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < rows and 0 <= new_c < cols:\n                new_effort = max(effort, abs(heights[r][c] - heights[new_r][new_c]))\n                if new_effort < diffs[new_r][new_c]:\n                    diffs[new_r][new_c] = new_effort\n                    heapq.heappush(pq, (new_effort, new_r, new_c))\n\nif __name__ == \"__main__\":\n    heights_str = input()\n    heights_list = []\n    row_strs = heights_str.strip('[]').split('], [')\n    for row_str in row_strs:\n        row = list(map(int, row_str.strip('[]').split(', ')))\n        heights_list.append(row)\n    result = minimum_effort_path(heights_list)\n    print(result)"

              }
          
      
  ]
}