{
    "questions": [
    {
      "id": 1,
      "title": "BFS traversal",
      "description": "Given a graph as an adjacency list and a starting node, return the BFS traversal order.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0 | [0,1,2,3] | Simple graph |\n| 2 | {0:[1],1:[2],2:[3],3:[]}, start=0 | [0,1,2,3] | Linear graph |\n| 3 | {0:[1,2],1:[3],2:[3],3:[]}, start=0 | [0,1,2,3] | Branching |\n| 4 | {0:[1],1:[2],2:[0]}, start=0 | [0,1,2] | Cycle |\n| 5 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=0 | [0,1,2,3,4] | Linear |\n| 6 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=0 | [0,1,2,3,4,5,6] | Binary tree |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=0 | [0,1,2,3,4] | Cycle |\n| 8 | {0:[1,2,3],1:[],2:[],3:[]}, start=0 | [0,1,2,3] | Star |\n| 9 | {0:[],1:[],2:[]}, start=0 | [0] | Isolated node |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, start=0 | [0,1,2,3,4,5] | Linear |\n| 11 | {0:[1,2],1:[3],2:[4],3:[],4:[]}, start=0 | [0,1,2,3,4] | Branching |\n| 12 | {0:[1],1:[2],2:[0]}, start=1 | [1,2,0] | Cycle, different start |\n| 13 | {0:[1],1:[2],2:[3],3:[0]}, start=2 | [2,3,0,1] | Cycle, different start |\n| 14 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=2 | [2,5,6] | Subtree |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=3 | [3,4] | Partial traversal |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=4 | [4] | Single node |\n| 17 | {0:[1,2],1:[3],2:[4],3:[5],4:[6],5:[],6:[]}, start=0 | [0,1,2,3,4,5,6] | Deep tree |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, start=0 | [0,1,2,3,4,5,6] | Linear |\n| 19 | {0:[1,2,3,4,5],1:[],2:[],3:[],4:[],5:[]}, start=0 | [0,1,2,3,4,5] | Star |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=2 | [2,3,4,0,1] | Cycle |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, start=0 | [0,1,2,3,4,5] | Cycle |\n| 22 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[],5:[],6:[],7:[],8:[]}, start=0 | [0,1,2,3,4,5,6,7,8] | Tree |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 24 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Tree |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Cycle |\n| 26 | {0:[1,2,3],1:[4,5],2:[6,7],3:[8,9],4:[],5:[],6:[],7:[],8:[],9:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Tree |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 28 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Tree |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 30 | {0:[1,2,3,4,5,6,7,8,9,10],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Star |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12] | Linear |\n| 32 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] | Tree |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Linear |\n| 34 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] | Star |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Linear |\n| 36 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[17,18],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18] | Tree |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Linear |\n| 38 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] | Star |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] | Linear |\n| 40 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[],41:[],42:[],43:[],44:[],45:[],46:[],47:[],48:[],49:[],50:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50] | Star |",
      "example": {
        "input": "{0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0",
        "output": "[0,1,2,3]",
        "explanation": "BFS traversal from node 0."
      },
      "answer": "from collections import deque\ndef bfs(graph, start):\n    visited = set()\n    order = []\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            order.append(node)\n            for neighbor in graph.get(node, []):\n                if neighbor not in visited:\n                    q.append(neighbor)\n    return order"
    },
    {
      "id": 2,
      "title": "DFS traversal",
      "description": "Given a graph as an adjacency list and a starting node, return the DFS traversal order.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0 | [0,1,3,2] | Simple graph |\n| 2 | {0:[1],1:[2],2:[3],3:[]}, start=0 | [0,1,2,3] | Linear graph |\n| 3 | {0:[1,2],1:[3],2:[3],3:[]}, start=0 | [0,1,3,2] | Branching |\n| 4 | {0:[1],1:[2],2:[0]}, start=0 | [0,1,2] | Cycle |\n| 5 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=0 | [0,1,2,3,4] | Linear |\n| 6 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=0 | [0,1,3,4,2,5,6] | Binary tree |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=0 | [0,1,2,3,4] | Cycle |\n| 8 | {0:[1,2,3],1:[],2:[],3:[]}, start=0 | [0,1,2,3] | Star |\n| 9 | {0:[],1:[],2:[]}, start=0 | [0] | Isolated node |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, start=0 | [0,1,2,3,4,5] | Linear |\n| 11 | {0:[1,2],1:[3],2:[4],3:[],4:[]}, start=0 | [0,1,3,2,4] | Branching |\n| 12 | {0:[1],1:[2],2:[0]}, start=1 | [1,2,0] | Cycle, different start |\n| 13 | {0:[1],1:[2],2:[3],3:[0]}, start=2 | [2,3,0,1] | Cycle, different start |\n| 14 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, start=2 | [2,5,6] | Subtree |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=3 | [3,4] | Partial traversal |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[]}, start=4 | [4] | Single node |\n| 17 | {0:[1,2],1:[3],2:[4],3:[5],4:[6],5:[],6:[]}, start=0 | [0,1,3,5,2,4,6] | Deep tree |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, start=0 | [0,1,2,3,4,5,6] | Linear |\n| 19 | {0:[1,2,3,4,5],1:[],2:[],3:[],4:[],5:[]}, start=0 | [0,1,2,3,4,5] | Star |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, start=2 | [2,3,4,0,1] | Cycle |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, start=0 | [0,1,2,3,4,5] | Cycle |\n| 22 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[],5:[],6:[],7:[],8:[]}, start=0 | [0,1,3,7,8,4,2,5,6] | Tree |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 24 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,3,7,8,4,9,10,2,5,6] | Tree |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, start=0 | [0,1,2,3,4,5,6,7,8,9] | Cycle |\n| 26 | {0:[1,2,3],1:[4,5],2:[6,7],3:[8,9],4:[],5:[],6:[],7:[],8:[],9:[]}, start=0 | [0,1,4,5,2,6,7,3,8,9] | Tree |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 28 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[]}, start=0 | [0,1,3,7,8,4,9,10,2,5,11,12,6,13,14] | Tree |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 30 | {0:[1,2,3,4,5,6,7,8,9,10],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10] | Star |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12] | Linear |\n| 32 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[]}, start=0 | [0,1,3,7,15,16,4,9,10,2,5,11,12,6,13,14,8] | Tree |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Linear |\n| 34 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] | Star |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Linear |\n| 36 | {0:[1,2],1:[3,4],2:[5,6],3:[7,8],4:[9,10],5:[11,12],6:[13,14],7:[15,16],8:[17,18],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[]}, start=0 | [0,1,3,7,15,16,4,9,10,2,5,11,12,6,13,14,8,17,18] | Tree |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Linear |\n| 38 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] | Star |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] | Linear |\n| 40 | {0:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[],11:[],12:[],13:[],14:[],15:[],16:[],17:[],18:[],19:[],20:[],21:[],22:[],23:[],24:[],25:[],26:[],27:[],28:[],29:[],30:[],31:[],32:[],33:[],34:[],35:[],36:[],37:[],38:[],39:[],40:[],41:[],42:[],43:[],44:[],45:[],46:[],47:[],48:[],49:[],50:[]}, start=0 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50] | Star |",
      "example": {
        "input": "{0:[1,2],1:[0,3],2:[0,3],3:[1,2]}, start=0",
        "output": "[0,1,3,2]",
        "explanation": "DFS traversal from node 0."
      },
      "answer": "def dfs(graph, start):\n    visited = set()\n    order = []\n    def helper(node):\n        if node not in visited:\n            visited.add(node)\n            order.append(node)\n            for neighbor in graph.get(node, []):\n                helper(neighbor)\n    helper(start)\n    return order"
    },
    {
      "id": 3,
      "title": "Detect cycle in undirected graph using DFS",
      "description": "Given an undirected graph as an adjacency list, detect if there is a cycle using DFS.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1],1:[0,2],2:[1,3],3:[2]}, n=4 | False | No cycle |\n| 2 | {0:[1],1:[0,2],2:[1,0]}, n=3 | True | Cycle |\n| 3 | {0:[1,2],1:[0,2],2:[0,1]}, n=3 | True | Triangle |\n| 4 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3]}, n=5 | False | No cycle |\n| 5 | {0:[1],1:[0,2],2:[1,3],3:[2,0]}, n=4 | True | Cycle |\n| 6 | {0:[1],1:[0]}, n=2 | False | No cycle |\n| 7 | {0:[1,2],1:[0],2:[0]}, n=3 | False | No cycle |\n| 8 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,0]}, n=5 | True | Cycle |\n| 9 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4]}, n=6 | False | No cycle |\n| 10 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,0]}, n=6 | True | Cycle |\n| 11 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5]}, n=7 | False | No cycle |\n| 12 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,0]}, n=7 | True | Cycle |\n| 13 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6]}, n=8 | False | No cycle |\n| 14 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,0]}, n=8 | True | Cycle |\n| 15 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7]}, n=9 | False | No cycle |\n| 16 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,0]}, n=9 | True | Cycle |\n| 17 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8]}, n=10 | False | No cycle |\n| 18 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,0]}, n=10 | True | Cycle |\n| 19 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9]}, n=11 | False | No cycle |\n| 20 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,0]}, n=11 | True | Cycle |\n| 21 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10]}, n=12 | False | No cycle |\n| 22 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,0]}, n=12 | True | Cycle |\n| 23 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11]}, n=13 | False | No cycle |\n| 24 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,0]}, n=13 | True | Cycle |\n| 25 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12]}, n=14 | False | No cycle |\n| 26 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,0]}, n=14 | True | Cycle |\n| 27 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13]}, n=15 | False | No cycle |\n| 28 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,0]}, n=15 | True | Cycle |\n| 29 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14]}, n=16 | False | No cycle |\n| 30 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,0]}, n=16 | True | Cycle |\n| 31 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15]}, n=17 | False | No cycle |\n| 32 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,0]}, n=17 | True | Cycle |\n| 33 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16]}, n=18 | False | No cycle |\n| 34 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,0]}, n=18 | True | Cycle |\n| 35 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17]}, n=19 | False | No cycle |\n| 36 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,0]}, n=19 | True | Cycle |\n| 37 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,19],19:[18]}, n=20 | False | No cycle |\n| 38 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,19],19:[18,0]}, n=20 | True | Cycle |\n| 39 | {0:[1],1:[0]}, n=2 | False | No cycle |\n| 40 | {0:[1],1:[0,2],2:[1,3],3:[2,4],4:[3,5],5:[4,6],6:[5,7],7:[6,8],8:[7,9],9:[8,10],10:[9,11],11:[10,12],12:[11,13],13:[12,14],14:[13,15],15:[14,16],16:[15,17],17:[16,18],18:[17,19],19:[18]}, n=20 | False | No cycle |",
      "example": {
        "input": "{0:[1],1:[0,2],2:[1,0]}, n=3",
        "output": "True",
        "explanation": "Cycle exists."
      },
      "answer": "def hasCycleUndirected(graph, n):\n    visited = [False]*n\n    def dfs(u, parent):\n        visited[u] = True\n        for v in graph.get(u, []):\n            if not visited[v]:\n                if dfs(v, u):\n                    return True\n            elif v != parent:\n                return True\n        return False\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    return False"
    },
    {
      "id": 4,
      "title": "Detect cycle in directed graph using DFS",
      "description": "Given a directed graph as an adjacency list, detect if there is a cycle using DFS.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1],1:[2],2:[0]}, n=3 | True | Cycle |\n| 2 | {0:[1],1:[2],2:[]}, n=3 | False | No cycle |\n| 3 | {0:[1,2],1:[2],2:[]}, n=3 | False | No cycle |\n| 4 | {0:[1],1:[2],2:[3],3:[1]}, n=4 | True | Cycle |\n| 5 | {0:[1],1:[2],2:[3],3:[]}, n=4 | False | No cycle |\n| 6 | {0:[1],1:[2],2:[3],3:[4],4:[0]}, n=5 | True | Cycle |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[]}, n=5 | False | No cycle |\n| 8 | {0:[1,2],1:[3],2:[3],3:[]}, n=4 | False | No cycle |\n| 9 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[0]}, n=6 | True | Cycle |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, n=6 | False | No cycle |\n| 11 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[0]}, n=7 | True | Cycle |\n| 12 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | False | No cycle |\n| 13 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[0]}, n=7 | True | Cycle |\n| 14 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | False | No cycle |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[0]}, n=8 | True | Cycle |\n| 16 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[]}, n=8 | False | No cycle |\n| 17 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[0]}, n=9 | True | Cycle |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[]}, n=9 | False | No cycle |\n| 19 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[0]}, n=10 | True | Cycle |\n| 20 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, n=10 | False | No cycle |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[0]}, n=11 | True | Cycle |\n| 22 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, n=11 | False | No cycle |\n| 23 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[0]}, n=12 | True | Cycle |\n| 24 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=12 | False | No cycle |\n| 25 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[0]}, n=13 | True | Cycle |\n| 26 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, n=13 | False | No cycle |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[0]}, n=14 | True | Cycle |\n| 28 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, n=14 | False | No cycle |\n| 29 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[0]}, n=15 | True | Cycle |\n| 30 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, n=15 | False | No cycle |\n| 31 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[0]}, n=16 | True | Cycle |\n| 32 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, n=16 | False | No cycle |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[0]}, n=17 | True | Cycle |\n| 34 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[]}, n=17 | False | No cycle |\n| 35 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[0]}, n=18 | True | Cycle |\n| 36 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[]}, n=18 | False | No cycle |\n| 37 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[0]}, n=19 | True | Cycle |\n| 38 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[]}, n=19 | False | No cycle |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[19],19:[0]}, n=20 | True | Cycle |\n| 40 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[16],16:[17],17:[18],18:[19],19:[]}, n=20 | False | No cycle |",
      "example": {
        "input": "{0:[1],1:[2],2:[0]}, n=3",
        "output": "True",
        "explanation": "Cycle exists."
      },
      "answer": "def hasCycleDirected(graph, n):\n    visited = [0]*n\n    def dfs(u):\n        if visited[u] == 1:\n            return True\n        if visited[u] == 2:\n            return False\n        visited[u] = 1\n        for v in graph.get(u, []):\n            if dfs(v):\n                return True\n        visited[u] = 2\n        return False\n    for i in range(n):\n        if visited[i] == 0:\n            if dfs(i):\n                return True\n    return False"
    },
    {
      "id": 5,
      "title": "Topological sorting",
      "description": "Given a directed acyclic graph (DAG) as an adjacency list, return a topological ordering of its nodes.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | {0:[1],1:[2],2:[]}, n=3 | [0,1,2] | Linear |\n| 2 | {0:[2,3],1:[3],2:[],3:[]}, n=4 | [0,1,2,3] or [1,0,2,3] | Multiple valid |\n| 3 | {0:[1],1:[2],2:[3],3:[]}, n=4 | [0,1,2,3] | Linear |\n| 4 | {0:[1,2],1:[3],2:[3],3:[]}, n=4 | [0,2,1,3] or [0,1,2,3] | Multiple valid |\n| 5 | {0:[1],1:[],2:[3],3:[]}, n=4 | [0,2,1,3] or [2,0,1,3] | Multiple valid |\n| 6 | {0:[1,2],1:[],2:[],3:[1,2]}, n=4 | [3,0,1,2] or [0,3,1,2] | Multiple valid |\n| 7 | {0:[1],1:[2],2:[3],3:[4],4:[]}, n=5 | [0,1,2,3,4] | Linear |\n| 8 | {0:[1,2],1:[3],2:[3],3:[4],4:[]}, n=5 | [0,2,1,3,4] or [0,1,2,3,4] | Multiple valid |\n| 9 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 10 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[]}, n=6 | [0,1,2,3,4,5] | Linear |\n| 11 | {0:[1,2],1:[3,4],2:[5,6],3:[],4:[],5:[],6:[]}, n=7 | [0,2,6,5,1,4,3] or [0,1,2,3,4,5,6] | Multiple valid |\n| 12 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | [0,1,2,3,4,5,6] | Linear |\n| 13 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[]}, n=7 | [0,2,1,3,4,5,6] or [0,1,2,3,4,5,6] | Multiple valid |\n| 14 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 15 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[]}, n=8 | [0,1,2,3,4,5,6,7] | Linear |\n| 16 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[]}, n=8 | [0,2,1,3,4,5,6,7] or [0,1,2,3,4,5,6,7] | Multiple valid |\n| 17 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 18 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[]}, n=9 | [0,1,2,3,4,5,6,7,8] | Linear |\n| 19 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[]}, n=9 | [0,2,1,3,4,5,6,7,8] or [0,1,2,3,4,5,6,7,8] | Multiple valid |\n| 20 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 21 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, n=10 | [0,1,2,3,4,5,6,7,8,9] | Linear |\n| 22 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[]}, n=10 | [0,2,1,3,4,5,6,7,8,9] or [0,1,2,3,4,5,6,7,8,9] | Multiple valid |\n| 23 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 24 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, n=11 | [0,1,2,3,4,5,6,7,8,9,10] | Linear |\n| 25 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[]}, n=11 | [0,2,1,3,4,5,6,7,8,9,10] or [0,1,2,3,4,5,6,7,8,9,10] | Multiple valid |\n| 26 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 27 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=12 | [0,1,2,3,4,5,6,7,8,9,10,11] | Linear |\n| 28 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=12 | [0,2,1,3,4,5,6,7,8,9,10,11] or [0,1,2,3,4,5,6,7,8,9,10,11] | Multiple valid |\n| 29 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 30 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, n=13 | [0,1,2,3,4,5,6,7,8,9,10,11,12] | Linear |\n| 31 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[]}, n=13 | [0,2,1,3,4,5,6,7,8,9,10,11,12] or [0,1,2,3,4,5,6,7,8,9,10,11,12] | Multiple valid |\n| 32 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 33 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, n=14 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Linear |\n| 34 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[]}, n=14 | [0,2,1,3,4,5,6,7,8,9,10,11,12,13] or [0,1,2,3,4,5,6,7,8,9,10,11,12,13] | Multiple valid |\n| 35 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 36 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, n=15 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Linear |\n| 37 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[]}, n=15 | [0,2,1,3,4,5,6,7,8,9,10,11,12,13,14] or [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] | Multiple valid |\n| 38 | {0:[1],1:[],2:[3],3:[],4:[2]}, n=5 | [4,0,2,1,3] or [0,4,2,1,3] | Multiple valid |\n| 39 | {0:[1],1:[2],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[15],15:[]}, n=16 | [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Linear |\n| 40 | {0:[1,2],1:[3],2:[3],3:[4],4:[5],5:[6],6:[7],7:[8],8:[9],9:[10],10:[11],11:[12],12:[13],13:[14],14:[]}, n=16 | [0,2,1,3,4,5,6,7,8,9,10,11,12,13,14,15] or [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | Multiple valid |",
      "example": {
        "input": "{0:[1],1:[2],2:[]}, n=3",
        "output": "[0,1,2]",
        "explanation": "One valid topological order."
      },
      "answer": "from collections import deque, defaultdict\ndef topoSort(graph, n):\n    indegree = [0]*n\n    for u in graph:\n        for v in graph[u]:\n            indegree[v] += 1\n    q = deque([i for i in range(n) if indegree[i]==0])\n    order = []\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in graph.get(u, []):\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                q.append(v)\n    return order if len(order)==n else []"
    },
    {
        "id": 6,
        "title": "Number of islands",
        "description": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]] | 1 | Single island |\n| 2 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 3 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 9 | Each 1 is an island |\n| 4 | [[0,0,0],[0,0,0],[0,0,0]] | 0 | All water |\n| 5 | [[1,1,1],[1,1,1],[1,1,1]] | 1 | All land |\n| 6 | [[1,0,0],[0,1,0],[0,0,1]] | 3 | Diagonal islands |\n| 7 | [[1,1,0,0],[0,1,0,1],[1,0,0,1],[0,0,1,1]] | 3 | Mixed |\n| 8 | [[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]] | 8 | Checkerboard |\n| 9 | [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]] | 1 | Hollow square |\n| 10 | [[1,0,1,0,1,0,1,0,1,0]] | 5 | Alternating |\n| 11 | [[1],[1],[1],[1],[1]] | 1 | Single column |\n| 12 | [[1,1,1,1,1]] | 1 | Single row |\n| 13 | [[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0]] | 7 | Alternating |\n| 14 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |\n| 15 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 16 | [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] | 2 | Donut |\n| 17 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 13 | Checkerboard |\n| 18 | [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]] | 1 | All land |\n| 19 | [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] | 0 | All water |\n| 20 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |\n| 21 | [[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]] | 1 | Single island |\n| 22 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 23 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 9 | Each 1 is an island |\n| 24 | [[0,0,0],[0,0,0],[0,0,0]] | 0 | All water |\n| 25 | [[1,1,1],[1,1,1],[1,1,1]] | 1 | All land |\n| 26 | [[1,0,0],[0,1,0],[0,0,1]] | 3 | Diagonal islands |\n| 27 | [[1,1,0,0],[0,1,0,1],[1,0,0,1],[0,0,1,1]] | 3 | Mixed |\n| 28 | [[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]] | 8 | Checkerboard |\n| 29 | [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]] | 1 | Hollow square |\n| 30 | [[1,0,1,0,1,0,1,0,1,0]] | 5 | Alternating |\n| 31 | [[1],[1],[1],[1],[1]] | 1 | Single column |\n| 32 | [[1,1,1,1,1]] | 1 | Single row |\n| 33 | [[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0]] | 7 | Alternating |\n| 34 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |\n| 35 | [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]] | 3 | Three islands |\n| 36 | [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] | 2 | Donut |\n| 37 | [[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]] | 13 | Checkerboard |\n| 38 | [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]] | 1 | All land |\n| 39 | [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] | 0 | All water |\n| 40 | [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]] | 9 | Diagonal cross |",
        "example": {
          "input": "[[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]]",
          "output": "1",
          "explanation": "There is only one island."
        },
        "answer": "def numIslands(grid):\n    if not grid: return 0\n    n, m = len(grid), len(grid[0])\n    def dfs(i, j):\n        if i<0 or i>=n or j<0 or j>=m or grid[i][j]!='1': return\n        grid[i][j] = '#'\n        for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n            dfs(i+di, j+dj)\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1' or grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    return count"
      },
      {
        "id": 7,
        "title": "Flood fill algorithm",
        "description": "Given a 2D grid, a starting cell, and a new color, fill the connected area with the new color.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Example 1 |\n| 2 | [[0,0,0],[0,1,1]], sr=1, sc=1, color=1 | [[0,0,0],[0,1,1]] | No change |\n| 3 | [[0,0,0],[0,1,1]], sr=1, sc=1, color=2 | [[0,0,0],[0,2,2]] | Fill |\n| 4 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=0, color=3 | [[3,3,3],[3,3,3],[3,3,3]] | All same |\n| 5 | [[1,2,1],[2,2,2],[1,2,1]], sr=1, sc=1, color=3 | [[1,3,1],[3,3,3],[1,3,1]] | Center |\n| 6 | [[1,1,1],[1,1,0],[1,0,1]], sr=0, sc=0, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 7 | [[0,0,0],[0,0,0]], sr=0, sc=0, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 8 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=2, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 9 | [[1,2,3],[4,5,6],[7,8,9]], sr=1, sc=1, color=0 | [[1,2,3],[4,0,6],[7,8,9]] | Single cell |\n| 10 | [[1,1,1],[1,1,0],[1,0,1]], sr=2, sc=2, color=2 | [[1,1,1],[1,1,0],[1,0,2]] | Corner |\n| 11 | [[1,1,1],[1,1,1],[1,1,1]], sr=1, sc=1, color=1 | [[1,1,1],[1,1,1],[1,1,1]] | No change |\n| 12 | [[0,0,0],[0,1,1]], sr=0, sc=0, color=2 | [[2,2,2],[2,1,1]] | Fill |\n| 13 | [[1,2,1],[2,2,2],[1,2,1]], sr=0, sc=1, color=4 | [[1,4,1],[4,4,4],[1,4,1]] | Edge |\n| 14 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=2, color=3 | [[1,1,1],[1,1,3],[1,0,1]] | Edge |\n| 15 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=2, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 16 | [[0,0,0],[0,0,0]], sr=1, sc=1, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 17 | [[1,2,3],[4,5,6],[7,8,9]], sr=0, sc=0, color=9 | [[9,2,3],[4,5,6],[7,8,9]] | Single cell |\n| 18 | [[1,1,1],[1,1,0],[1,0,1]], sr=2, sc=0, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 19 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=2, color=3 | [[3,3,3],[3,3,3],[3,3,3]] | All same |\n| 20 | [[1,2,1],[2,2,2],[1,2,1]], sr=2, sc=1, color=5 | [[1,5,1],[5,5,5],[1,5,1]] | Center |\n| 21 | [[1,1,1],[1,1,0],[1,0,1]], sr=0, sc=1, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 22 | [[0,0,0],[0,0,0]], sr=0, sc=1, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 23 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=0, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 24 | [[1,2,3],[4,5,6],[7,8,9]], sr=2, sc=2, color=0 | [[1,2,3],[4,5,6],[7,8,0]] | Single cell |\n| 25 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=0, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 26 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=1, color=1 | [[1,1,1],[1,1,1],[1,1,1]] | No change |\n| 27 | [[0,0,0],[0,1,1]], sr=1, sc=0, color=2 | [[2,2,2],[2,1,1]] | Fill |\n| 28 | [[1,2,1],[2,2,2],[1,2,1]], sr=1, sc=2, color=6 | [[1,6,1],[6,6,6],[1,6,1]] | Edge |\n| 29 | [[1,1,1],[1,1,0],[1,0,1]], sr=2, sc=1, color=3 | [[1,1,1],[1,1,0],[1,3,1]] | Edge |\n| 30 | [[1,1,1],[1,1,1],[1,1,1]], sr=1, sc=2, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 31 | [[0,0,0],[0,0,0]], sr=0, sc=2, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 32 | [[1,2,3],[4,5,6],[7,8,9]], sr=0, sc=2, color=9 | [[1,2,9],[4,5,6],[7,8,9]] | Single cell |\n| 33 | [[1,1,1],[1,1,0],[1,0,1]], sr=0, sc=2, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 34 | [[1,1,1],[1,1,1],[1,1,1]], sr=2, sc=1, color=3 | [[3,3,3],[3,3,3],[3,3,3]] | All same |\n| 35 | [[1,2,1],[2,2,2],[1,2,1]], sr=0, sc=0, color=4 | [[4,2,1],[2,2,2],[1,2,1]] | Edge |\n| 36 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2 | [[2,2,2],[2,2,0],[2,0,1]] | Fill |\n| 37 | [[0,0,0],[0,0,0]], sr=1, sc=2, color=1 | [[1,1,1],[1,1,1]] | All zero to one |\n| 38 | [[1,1,1],[1,1,1],[1,1,1]], sr=0, sc=0, color=2 | [[2,2,2],[2,2,2],[2,2,2]] | All same |\n| 39 | [[1,2,3],[4,5,6],[7,8,9]], sr=2, sc=0, color=0 | [[0,2,3],[4,5,6],[7,8,9]] | Single cell |\n| 40 | [[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=2, color=2 | [[1,1,1],[1,1,2],[1,0,1]] | Edge |",
        "example": {
          "input": "[[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2",
          "output": "[[2,2,2],[2,2,0],[2,0,1]]",
          "explanation": "Flood fill from (1,1) with color 2."
        },
        "answer": "def floodFill(image, sr, sc, color):\n    orig = image[sr][sc]\n    if orig == color: return image\n    n, m = len(image), len(image[0])\n    def dfs(i, j):\n        if i<0 or i>=n or j<0 or j>=m or image[i][j]!=orig: return\n        image[i][j] = color\n        for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n            dfs(i+di, j+dj)\n    dfs(sr, sc)\n    return image"
      },
      
         {
    "id": 8,
    "title": "Find Strongly Connected Components (Kosaraju's Algorithm)",
    "description": "Given a directed graph, find all its strongly connected components (SCCs) using Kosaraju's algorithm.  Kosaraju's algorithm involves three main steps:\n\n1.  Perform a DFS on the graph to compute the finishing times of each vertex.\n2.  Reverse the direction of all edges in the graph.\n3.  Perform a DFS on the reversed graph, processing vertices in decreasing order of their finishing times. Each DFS traversal discovers a new SCC.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 5, edges = [[0,1],[1,2],[2,0],[1,3],[3,4]] | [[0, 1, 2], [3], [4]] | One SCC: {0,1,2}. |\n| 2 | n = 4, edges = [[0,1],[1,2],[2,3],[3,0]] | [[0, 1, 2, 3]] | One big SCC. |\n| 3 | n = 3, edges = [[0,1],[1,2],[2,0],[0,2]] | [[0, 1, 2]] |  |\n| 4 | n = 1, edges = [] | [[0]] | Single node. |\n| 5 | n = 2, edges = [[0,1],[1,0]] | [[0, 1]] | Two nodes, cycle. |\n| 6 | n = 2, edges = [[0,1]] | [[0], [1]] | No cycle. |\n| 7 | n = 5, edges = [[0,1],[1,2],[2,0],[3,4]] | [[0, 1, 2], [3], [4]] | Two SCCs. |\n| 8 | n = 6, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,3]] | [[0, 1, 2], [3, 4, 5]] | Two SCCs. |\n| 9 | n = 4, edges = [[0,1],[1,2],[2,3]] | [[0], [1], [2], [3]] | No SCCs, just paths. |\n| 10 | n = 5, edges = [[0,1],[1,2],[2,3],[3,4],[4,0]] | [[0, 1, 2, 3, 4]] | One SCC. |\n",
    "example": {
      "input": "5\n[[0, 1], [1, 2], [2, 0], [1, 3], [3, 4]]",
      "output": "[[0, 1, 2], [3], [4]]",
      "explanation": "The strongly connected components are {0, 1, 2}, {3}, and {4}."
    },
    "answer": "from collections import defaultdict\n\ndef kosaraju_scc(n, edges):\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n\n    visited = [False] * n\n    stack = []\n\n    def dfs1(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor)\n        stack.append(node)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n\n    reversed_adj = defaultdict(list)\n    for u, v in edges:\n        reversed_adj[v].append(u)\n\n    visited = [False] * n\n    sccs = []\n\n    def dfs2(node, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in reversed_adj[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor, component)\n\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs2(node, component)\n            sccs.append(sorted(component))\n\n    return sorted(sccs, key=lambda x: x[0])\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges_str = input()\n    edges_list = []\n    if edges_str:\n        edge_pairs = edges_str.strip('[]').split('], [')\n        for pair_str in edge_pairs:\n            pair = list(map(int, pair_str.strip('[]').split(', ')))\n            edges_list.append(pair)\n    result = kosaraju_scc(n, edges_list)\n    print(result)\n"
  },
        {
          "id": 9,
          "title": "Bipartite graph check",
          "description": "Given an undirected graph, check if it is bipartite.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 2 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 3 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 4 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 5 | [[1],[0]] | True | Two nodes |\n| 6 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 7 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 8 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 9 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 10 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 11 | [[1],[0]] | True | Two nodes |\n| 12 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 13 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 14 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 15 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 16 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 17 | [[1],[0]] | True | Two nodes |\n| 18 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 19 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 20 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 21 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 22 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 23 | [[1],[0]] | True | Two nodes |\n| 24 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 25 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 26 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 27 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 28 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 29 | [[1],[0]] | True | Two nodes |\n| 30 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 31 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 32 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 33 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 34 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |\n| 35 | [[1],[0]] | True | Two nodes |\n| 36 | [[1,2],[0,2],[0,1]] | False | Triangle |\n| 37 | [[1,3],[0,2],[1,3],[0,2]] | True | 4-node cycle |\n| 38 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | 3-node cycle |\n| 39 | [[1],[0,3],[3],[1,2]] | True | Tree |\n| 40 | [[1,2,3],[0,2],[0,1,3],[0,2]] | False | Odd cycle |",
          "example": {
            "input": "[[1,3],[0,2],[1,3],[0,2]]",
            "output": "True",
            "explanation": "4-node cycle is bipartite."
          },
          "answer": "def isBipartite(graph):\n    color = {}\n    for node in range(len(graph)):\n        if node not in color:\n            stack = [node]\n            color[node] = 0\n            while stack:\n                u = stack.pop()\n                for v in graph[u]:\n                    if v not in color:\n                        color[v] = color[u]^1\n                        stack.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True"
        },
        {
    "id": 10,
    "title": "Eulerian Circuit in Directed Graph",
    "description": "Given a directed graph, check if an Eulerian circuit exists in the graph. An Eulerian circuit is a path in a graph that visits every edge exactly once and starts and ends at the same vertex. A directed graph has an Eulerian circuit if and only if:\n\nAll vertices have the same in-degree and out-degree.\nThe graph is strongly connected (there is a directed path between any two vertices).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 3, edges = [[0,1],[1,2],[2,0]] | true | Cycle 0-1-2-0 |\n| 2 | n = 3, edges = [[0,1],[0,2],[1,2],[2,0],[2,1]] | true | 0-1-2-0-2-1-0 |\n| 3 | n = 3, edges = [[0,1],[1,2]] | false | Not strongly connected. |\n| 4 | n = 1, edges = [] | true | Single node, no edges. |\n| 5 | n = 2, edges = [[0,1],[1,0]] | true | Simple cycle. |\n| 6 | n = 2, edges = [[0,1]] | false | No cycle. |\n| 7 | n = 4, edges = [[0,1],[1,2],[2,3],[3,0]] | true | Simple cycle in 4 nodes |\n| 8 | n = 4, edges = [[0,1],[1,2],[2,3],[3,0],[0,2],[2,1]] | true | More complex cycle |\n| 9 | n = 4, edges = [[0,1],[1,2],[2,3]] | false | No cycle back to start. |\n| 10 | n = 5, edges = [[0,1],[1,2],[2,3],[3,4],[4,0],[0,4],[4,2]] | true |  |\n",
    "example": {
      "input": "3\n[[0, 1], [1, 2], [2, 0]]",
      "output": "true",
      "explanation": "The circuit 0 -> 1 -> 2 -> 0 visits every edge exactly once and returns to the starting node."
    },
    "answer": "from collections import defaultdict\n\ndef has_eulerian_circuit_directed(n, edges):\n    if not edges and n <= 1:\n        return True\n\n    adj = defaultdict(list)\n    in_degree = [0] * n\n    out_degree = [0] * n\n\n    for u, v in edges:\n        adj[u].append(v)\n        in_degree[v] += 1\n        out_degree[u] += 1\n\n    for i in range(n):\n        if in_degree[i] != out_degree[i]:\n            return False\n\n    def is_strongly_connected(graph, num_nodes):\n        if num_nodes <= 1:\n            return True\n\n        def dfs(start_node, visited):\n            visited[start_node] = True\n            for neighbor in graph[start_node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, visited)\n\n        start_node = next(iter(graph)) if graph else 0 # Fix: Handle empty graph case\n        visited = [False] * num_nodes\n        dfs(start_node, visited)\n        if not all(visited):\n            return False\n\n        # Check connectivity from every node (strong connectivity)\n        for i in range(num_nodes):\n            visited = [False] * num_nodes\n            dfs(i, visited)\n            if not all(visited):\n                return False\n        return True\n\n    return is_strongly_connected(adj, n)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges_str = input()\n    edges_list = []\n    if edges_str:\n        edge_pairs = edges_str.strip('[]').split('], [')\n        for pair_str in edge_pairs:\n            pair = list(map(int, pair_str.strip('[]').split(', ')))\n            edges_list.append(pair)\n    result = has_eulerian_circuit_directed(n, edges_list)\n    print(result)\n"
  },
        {
    "id": 11,
    "title": "Find the Town Judge",
    "description": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\n\nThe town judge trusts nobody.\nEveryone (except for the town judge) trusts the town judge.\nThere is exactly one person that satisfies properties 1 and 2.\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi.\n\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 2, trust = [[1,2]] | 2 | Person 1 trusts person 2, person 2 trusts no one, and everyone (just 1) trusts person 2. |\n| 2 | n = 3, trust = [[1,3],[2,3]] | 3 | Person 1 and 2 trust person 3, person 3 trusts no one, and everyone (1 and 2) trusts person 3. |\n| 3 | n = 3, trust = [[1,3],[2,3],[3,1]] | -1 | Person 3 trusts person 1, so person 3 cannot be the judge. |\n| 4 | n = 1, trust = [] | 1 | Only one person, they trust no one and everyone (vacuously) trusts them. |\n| 5 | n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] | 3 | Persons 1 and 2 trust 3, person 4 trusts 3, and 3 trusts no one. |\n| 6 | n = 4, trust = [[1,2],[2,3],[3,4]] | -1 | No one is trusted by everyone except themselves. |\n| 7 | n = 2, trust = [] | -1 | No trust relationships, so no judge can exist if n > 1. |\n| 8 | n = 3, trust = [[1,2],[2,1]] | -1 | No one is trusted by everyone else. |\n| 9 | n = 5, trust = [[1,4],[2,4],[3,4],[5,4]] | 4 | Everyone except 4 trusts 4, and 4 trusts no one. |\n| 10 | n = 5, trust = [[1,4],[2,4],[3,4]] | -1 | Person 5 does not trust anyone, and is not trusted by everyone. |\n",
    "example": {
      "input": "n = 3, trust = [[1,3],[2,3]]",
      "output": "3",
      "explanation": "People 1 and 2 trust person 3. Person 3 trusts no one. Everyone (except the judge, which is 3) trusts the judge."
    },
    "answer": "def findJudge(n, trust):\n    if n == 1 and not trust:\n        return 1\n    trust_counts = [0] * (n + 1)\n    trusted_by_counts = [0] * (n + 1)\n    for a, b in trust:\n        trust_counts[a] += 1\n        trusted_by_counts[b] += 1\n    for i in range(1, n + 1):\n        if trust_counts[i] == 0 and trusted_by_counts[i] == n - 1:\n            return i\n    return -1"
  },
  {
    "id":12,
    "title": "Graph Valid Tree",
    "description": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\nA valid tree has two specific properties:\n\nIt is fully connected: There is a path between any two nodes.\nIt contains no cycles.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 5, edges = [[0,1],[0,2],[0,3],[1,4]] | True | A star graph is a valid tree. |\n| 2 | n = 5, edges = [[0,1],[1,2],[2,3],[3,4]] | True | A linear chain is a valid tree. |\n| 3 | n = 5, edges = [[0,1],[1,2],[2,3],[3,4],[4,0]] | False | Contains a cycle. |\n| 4 | n = 5, edges = [[0,1],[0,2],[3,4]] | False | Not fully connected (no path between {0,1,2} and {3,4}). |\n| 5 | n = 1, edges = [] | True | A single node with no edges is a valid tree. |\n| 6 | n = 2, edges = [[0,1]] | True | Two connected nodes form a valid tree. |\n| 7 | n = 2, edges = [] | False | Not connected. |\n| 8 | n = 3, edges = [[0,1],[1,2],[0,2]] | False | Contains a cycle. |\n| 9 | n = 4, edges = [[0,1],[2,3]] | False | Not connected. |\n| 10 | n = 4, edges = [[0,1],[1,2],[2,3]] | True | A linear chain. |\n",
    "example": {
      "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",
      "output": "True",
      "explanation": "The graph is connected and has no cycles."
    },
    "answer": "def isValidTree(n, edges):\n    if len(edges) != n - 1:\n        return False\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n    count = 0\n\n    while queue:\n        u = queue.pop(0)\n        count += 1\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n\n    return count == n"
  },
  {
    "id": 13,
    "title": "Find if Path Exists in Graph",
    "description": "Given an undirected graph represented as a list of edges, and two vertices start and end, determine if a path exists between start and end.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2 | True | Direct path exists. |\n| 2 | n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], start = 0, end = 5 | False | No path connects the two components. |\n| 3 | n = 5, edges = [[0,1],[1,2],[2,3],[3,4]], start = 0, end = 4 | True | Linear path. |\n| 4 | n = 1, edges = [], start = 0, end = 0 | True | Start and end are the same node. |\n| 5 | n = 2, edges = [[0,1]], start = 0, end = 1 | True | Directly connected. |\n| 6 | n = 2, edges = [], start = 0, end = 1 | False | No connection. |\n| 7 | n = 4, edges = [[0,1],[1,2],[3,0]], start = 3, end = 2 | True | Path: 3 -> 0 -> 1 -> 2. |\n| 8 | n = 4, edges = [[0,1],[1,2]], start = 0, end = 3 | False | No path to node 3. |\n| 9 | n = 5, edges = [[0,1],[1,2],[0,3],[3,4]], start = 2, end = 4 | True | Path: 2 -> 1 -> 0 -> 3 -> 4. |\n| 10 | n = 5, edges = [[0,1],[1,2],[0,3]], start = 2, end = 4 | False | Node 4 is isolated. |\n",
    "example": {
      "input": "n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2",
      "output": "True",
      "explanation": "There is a path from node 0 to node 2 (0 -> 2 or 0 -> 1 -> 2)."
    },
    "answer": "def validPath(n, edges, start, end):\n    if start == end:\n        return True\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    queue = [start]\n    visited[start] = True\n\n    while queue:\n        curr = queue.pop(0)\n        if curr == end:\n            return True\n        for neighbor in adj[curr]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n    return False"
  },
  {
    "id": 14,
    "title": "Find Center of Star Graph",
    "description": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph has exactly one center node and exactly n - 1 edges that connect the center node with all other nodes.\n\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | edges = [[1,2],[2,3],[4,2]] | 2 | Node 2 is connected to all other nodes. |\n| 2 | edges = [[1,2],[5,1],[1,3],[1,4]] | 1 | Node 1 is connected to all other nodes. |\n| 3 | edges = [[7,1],[1,8],[1,9],[1,10],[1,6]] | 1 | Node 1 is the center. |\n| 4 | edges = [[3,5],[5,2],[5,1]] | 5 | Node 5 is the center. |\n| 5 | edges = [[10,1],[1,2]] | 1 | With only two edges, the common node is the center. |\n| 6 | edges = [[6,3],[3,9],[3,4],[3,1]] | 3 | Node 3 is the center. |\n| 7 | edges = [[2,8],[8,5],[8,1],[8,3]] | 8 | Node 8 is the center. |\n| 8 | edges = [[11,1],[1,5],[1,12]] | 1 | Node 1 is the center. |\n| 9 | edges = [[15,2],[2,7],[2,1]] | 2 | Node 2 is the center. |\n| 10 | edges = [[9,4],[4,6],[4,2],[4,8]] | 4 | Node 4 is the center. |\n",
    "example": {
      "input": "edges = [[1,2],[2,3],[4,2]]",
      "output": "2",
      "explanation": "The edges connect node 2 with nodes 1, 3, and 4, making 2 the center."
    },
    "answer": "def findCenter(edges):\n    # In a star graph, the center node will appear in every edge.\n    # With more than one edge, we can just check the first two edges.\n    if len(edges) > 1:\n        u1, v1 = edges[0]\n        u2, v2 = edges[1]\n        if u1 == u2 or u1 == v2:\n            return u1\n        else:\n            return v1\n    # If there's only one edge, either node can be considered the center.\n    # However, based on the problem definition (n nodes, n-1 edges), this case shouldn't strictly occur for a star graph with n > 1.\n    # For completeness (though unlikely based on problem constraints):\n    if edges:\n        return edges[0][0]\n    return -1 # Should not happen for a valid star graph with n >= 2"
  },
  {
    "id":15,
    "title": "Matrix Path Count",
    "description": "Given a m x n integer matrix grid, where grid[i][j] could be 0 or 1. You need to find the number of unique paths from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1). You can only move either down or right at any point in time. Assume there are no obstacles (all grid values are effectively 1 for pathfinding).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | m = 3, n = 2 | 3 | Paths: (0,0)->(0,1)->(1,1), (0,0)->(1,0)->(1,1), (0,0)->(1,0)->(0,0)->(0,1)->(1,1) - only down and right allowed |\n| 2 | m = 7, n = 3 | 28 | Larger grid. |\n| 3 | m = 1, n = 5 | 1 | Only one way to go right. |\n| 4 | m = 5, n = 1 | 1 | Only one way to go down. |\n| 5 | m = 1, n = 1 | 1 | Starting and ending at the same cell. |\n| 6 | m = 2, n = 2 | 2 | (0,0)->(0,1)->(1,1), (0,0)->(1,0)->(1,1) |\n| 7 | m = 4, n = 4 | 20 | Symmetric case. |\n| 8 | m = 3, n = 4 | 10 | More columns than rows. |\n| 9 | m = 4, n = 3 | 10 | More rows than columns. |\n| 10 | m = 2, n = 5 | 5 | More columns. |\n",
    "example": {
      "input": "m = 3, n = 2",
      "output": "3",
      "explanation": "There are 3 possible paths to reach the bottom-right corner from the top-left corner by only moving down or right."
    },
    "answer": "def uniquePaths(m, n):\n    # This is a classic combinatorial problem.\n    # To reach the bottom-right (m-1, n-1) from (0, 0), we need to make a total of (m-1) down moves and (n-1) right moves.\n    # The total number of moves is (m-1) + (n-1) = m + n - 2.\n    # The number of unique paths is the number of ways to choose the positions of the down (or right) moves in the sequence of total moves.\n    # This can be calculated using combinations: C(m + n - 2, m - 1) or C(m + n - 2, n - 1).\n\n    def combinations(total, choose):\n        if choose < 0 or choose > total:\n            return 0\n        if choose == 0 or choose == total:\n            return 1\n        if choose > total // 2:\n            choose = total - choose\n        result = 1\n        for i in range(choose):\n            result = result * (total - i) // (i + 1)\n        return result\n\n    return combinations(m + n - 2, m - 1)"
  },
   {
    "id": 16,
    "title": "Minimum Spanning Tree (MST) - Kruskal's Algorithm",
    "description": "Given a weighted undirected graph, find the Minimum Spanning Tree (MST) using Kruskal's algorithm. The MST is a subgraph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.\n\nKruskal's algorithm works by sorting all the edges by weight and iteratively adding the smallest weight edge to the MST if it does not create a cycle.  A disjoint set data structure (Union-Find) is typically used to efficiently detect cycles.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4]] | [[2,3,4],[0,3,5],[0,2,6]] | Basic MST, no duplicate weights. |\n| 2 | n = 5, edges = [[0,1,2],[0,2,4],[1,2,1],[1,3,7],[2,3,3],[2,4,5],[3,4,6]] | [[1,2,1],[0,1,2],[2,3,3],[2,4,5]] |  No duplicate weights. |\n| 3 | n = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4],[1,2,6]] | [[2,3,4],[0,3,5],[0,2,6]] | Duplicate edge weights. |\n| 4 | n = 1, edges = [] | [] | Single node, no edges. |\n| 5 | n = 2, edges = [[0,1,5]] | [[0,1,5]] | Two nodes, one edge. |\n| 6 | n = 3, edges = [[0,1,1],[1,2,2],[0,2,3]] | [[0,1,1],[1,2,2]] | Simple chain. |\n| 7 | n = 4, edges = [[0,1,2],[1,2,3],[2,3,1],[0,3,4]] | [[2,3,1],[0,1,2],[1,2,3]] | Cycle with varying weights. |\n| 8 | n = 5, edges = [[0,1,1],[0,2,2],[0,3,3],[0,4,4],[1,2,5],[1,3,6],[1,4,7],[2,3,8],[2,4,9],[3,4,10]] | [[0,1,1],[0,2,2],[0,3,3],[0,4,4]] | Star graph. |\n| 9 | n = 6, edges = [[0,1,7],[1,2,9],[2,3,8],[3,4,6],[4,5,5],[0,5,10],[1,3,11],[2,4,12]] | [[4,5,5],[3,4,6],[0,1,7],[2,3,8],[1,2,9]] | More complex graph. |\n| 10 | n = 4, edges = [[0,1,1],[0,2,1],[0,3,1],[1,2,1],[1,3,1],[2,3,1]] | [[0,1,1],[0,2,1],[0,3,1]] | All edges have same weight. |\n",
    "example": {
      "input": "n = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4]]",
      "output": "[[2,3,4],[0,3,5],[0,2,6]]",
      "explanation": "The edges (2,3), (0,3), and (0,2) form the MST with a total weight of 4 + 5 + 6 = 15.  Other combinations would have a higher total weight."
    },
    "answer": "def kruskals_mst(n, edges):\n    edges.sort(key=lambda x: x[2])  # Sort edges by weight\n    parent = list(range(n))  # Initialize parent array for Union-Find\n\n    def find(i):  # Find the root of the set to which i belongs\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])  # Path compression for efficiency\n        return parent[i]\n\n    def union(i, j):  # Union the sets containing i and j\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j  # Make one root the parent of the other\n            return True  # Indicate that a union occurred\n        return False  # Indicate that no union occurred (i.e., they were already in the same set)\n\n    mst_edges = []  # Store the edges of the MST\n    for u, v, weight in edges:\n        if union(u, v):  # If adding this edge doesn't create a cycle\n            mst_edges.append([u, v, weight])  # Add it to the MST\n    return mst_edges"
  },
  {
    "id": 17,
    "title": "Minimum Spanning Tree (MST) - Prim's Algorithm",
    "description": "Given a weighted undirected graph, find the Minimum Spanning Tree (MST) using Prim's algorithm.  Prim's algorithm starts with a single vertex and grows the MST one edge at a time.  It selects the edge with the minimum weight that connects a vertex in the MST to a vertex not yet in the MST.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4]] | [[0,3,5],[2,3,4],[0,2,6]] | Basic MST, no duplicate weights. |\n| 2 | n = 5, edges = [[0,1,2],[0,2,4],[1,2,1],[1,3,7],[2,3,3],[2,4,5],[3,4,6]] | [[0,1,2],[1,2,1],[2,3,3],[2,4,5]] | No duplicate weights. |\n| 3 | n = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4],[1,2,6]] | [[0,3,5],[2,3,4],[0,2,6]] | Duplicate edge weights. |\n| 4 | n = 1, edges = [] | [] | Single node, no edges. |\n| 5 | n = 2, edges = [[0,1,5]] | [[0,1,5]] | Two nodes, one edge. |\n| 6 | n = 3, edges = [[0,1,1],[1,2,2],[0,2,3]] | [[0,1,1],[1,2,2]] | Simple chain. |\n| 7 | n = 4, edges = [[0,1,2],[1,2,3],[2,3,1],[0,3,4]] | [[0,1,2],[2,3,1],[1,2,3]] | Cycle with varying weights. |\n| 8 | n = 5, edges = [[0,1,1],[0,2,2],[0,3,3],[0,4,4],[1,2,5],[1,3,6],[1,4,7],[2,3,8],[2,4,9],[3,4,10]] | [[0,1,1],[0,2,2],[0,3,3],[0,4,4]] | Star graph. |\n| 9 | n = 6, edges = [[0,1,7],[1,2,9],[2,3,8],[3,4,6],[4,5,5],[0,5,10],[1,3,11],[2,4,12]] | [[0,1,7],[4,5,5],[3,4,6],[2,3,8],[1,2,9]] | More complex graph. |\n| 10 | n = 4, edges = [[0,1,1],[0,2,1],[0,3,1],[1,2,1],[1,3,1],[2,3,1]] | [[0,1,1],[0,2,1],[0,3,1]] | All edges have same weight.  (Order may vary based on starting node and tie-breaking) |\n",
    "example": {
      "input": "n = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4]]",
      "output": "[[0,3,5],[2,3,4],[0,2,6]]",
      "explanation": "Prim's algorithm starts from a node (e.g., 0), adds the cheapest edge to an unvisited node (0-3), then the next cheapest edge connecting the MST to an unvisited node (3-2), and so on."
    },
    "answer": "import heapq\n\ndef prims_mst(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v, weight in edges:\n        adj[u].append((v, weight))\n        adj[v].append((u, weight))\n\n    visited = [False] * n\n    min_heap = [(0, 0, -1)]  # (weight, node, parent). Start at node 0 with weight 0 and no parent.\n    mst_edges = []\n    total_weight = 0\n\n    while min_heap:\n        weight, u, parent = heapq.heappop(min_heap)\n        if visited[u]:\n            continue  # Skip if the node is already visited\n\n        visited[u] = True\n        total_weight += weight\n        if parent != -1:  # Add the edge to the MST (except for the starting node)\n            mst_edges.append([parent, u, weight])\n\n        for v, edge_weight in adj[u]:\n            if not visited[v]:\n                heapq.heappush(min_heap, (edge_weight, v, u))\n\n    return mst_edges #, total_weight # Return the edges and the total weight\n"
  },
  {
    "id": 18,
    "title": "Shortest Path in DAG",
    "description": "Given a directed acyclic graph (DAG) with weighted edges, find the shortest path from a source vertex to all other vertices.  A DAG has no cycles, which allows us to use a topological sort to process vertices in the correct order for shortest path calculation.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | n = 6, edges = [[0,1,5],[0,2,3],[1,3,6],[1,2,2],[2,4,4],[2,5,2],[3,4,-1],[4,5,-2]], source = 0 | [0, 5, 3, 11, 7, 5] | Basic DAG, positive and negative weights. |\n| 2 | n = 4, edges = [[0,1,2],[0,2,4],[1,3,5],[2,3,1]], source = 0 | [0, 2, 4, 5] | Only positive weights. |\n| 3 | n = 3, edges = [[0,1,10],[1,2,-5]], source = 0 | [0, 10, 5] | Negative weight edge. |\n| 4 | n = 1, edges = [], source = 0 | [0] | Single node, no edges. |\n| 5 | n = 2, edges = [[0,1,10]], source = 0 | [0, 10] | Two nodes, one edge. |\n| 6 | n = 4, edges = [[0,1,2],[1,2,2],[2,3,2]], source = 0 | [0, 2, 4, 6] | Simple chain. |\n| 7 | n = 4, edges = [[0,1,5],[0,2,2],[2,3,3],[1,3,1]], source = 0 | [0, 5, 2, 5] | Multiple paths, some converging. |\n| 8 | n = 5, edges = [[0,1,3],[0,2,6],[1,3,5],[2,3,8],[3,4,2]], source = 0 | [0, 3, 6, 8, 10] | Longer path. |\n| 9 | n = 6, edges = [[0,1,4],[0,2,2],[1,3,2],[2,3,3],[2,4,4],[3,5,1],[4,5,0]], source = 0 | [0, 4, 2, 5, 6, 6] | More complex DAG. |\n| 10 | n = 5, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,1]], source = 4 | [inf, inf, inf, inf, 0] | Start from the last node. |\n",
    "example": {
      "input": "n = 6, edges = [[0,1,5],[0,2,3],[1,3,6],[1,2,2],[2,4,4],[2,5,2],[3,4,-1],[4,5,-2]], source = 0",
      "output": "[0, 5, 3, 11, 7, 5]",
      "explanation": "The shortest path from node 0 to:\n    - 0: 0\n    - 1: 0 -> 1 (weight 5)\n    - 2: 0 -> 2 (weight 3)\n    - 3: 0 -> 1 -> 3 (weight 5 + 6 = 11)\n    - 4: 0 -> 2 -> 4 (weight 3 + 4 = 7)\n    - 5: 0 -> 2 -> 5 (weight 3 + 2 = 5)"
    },
    "answer": "import sys\n\ndef shortest_path_dag(n, edges, source):\n    adj = [[] for _ in range(n)]  # Adjacency list: (neighbor, weight)\n    for u, v, weight in edges:\n        adj[u].append((v, weight))\n\n    indegree = [0] * n  # Calculate in-degrees for topological sort\n    for u in range(n):\n        for v, _ in adj[u]:\n            indegree[v] += 1\n\n    queue = [u for u in range(n) if indegree[u] == 0] # Start with nodes with in-degree 0\n    top_order = []\n    while queue:\n        u = queue.pop(0)\n        top_order.append(u)\n        for v, _ in adj[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n\n    dist = [float('inf')] * n  # Initialize distances to infinity\n    dist[source] = 0  # Distance from source to itself is 0\n\n    for u in top_order:\n        if dist[u] != float('inf'):  # If node u is reachable\n            for v, weight in adj[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight  # Relax the edge\n\n    return dist"
  },
  {
    "id": 19,
    "title": "Find Number of Provinces",
    "description": "Given an undirected graph represented as an adjacency matrix, where graph[i][j] = 1 if there is an edge between city i and city j, and graph[i][j] = 0 otherwise, find the number of provinces. A province is a group of directly or indirectly connected cities.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | graph = [[1,1,0],[1,1,0],[0,0,1]] | 2 | Cities 0 and 1 are connected, 2 is separate. |\n| 2 | graph = [[1,0,0],[0,1,0],[0,0,1]] | 3 | No cities are connected. |\n| 3 | graph = [[1,1,1],[1,1,1],[1,1,1]] | 1 | All cities are connected. |\n| 4 | graph = [[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]] | 2 | Two connected components. |\n| 5 | graph = [[1]] | 1 | Single city. |\n| 6 | graph = [[1,0],[0,1]] | 1 | Two connected cities. |\n|  7 | graph = [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]] | 5 | No connections. |\n| 8 | graph = [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]] | 2 | Two pairs of connected cities. |\n| 9 | graph = [[1,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,1]] | 2 | Cities 1 and 2 are connected. |\n| 10 | graph = [[1,0,0,0,0,0],[0,1,1,0,0,0],[0,1,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]] | 3 | Three provinces. |\n",
    "example": {
      "input": "graph = [[1,1,0],[1,1,0],[0,0,1]]",
      "output": "2",
      "explanation": "Cities 0 and 1 are connected (graph[0][1] = 1 and graph[1][0] = 1), forming one province. City 2 is not connected to any other city, forming a second province."
    },
    "answer": "def find_number_of_provinces(graph):\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n    return count"
  },

  {
    "id": 20,
    "title": "Find Path with Minimum Effort",
    "description": "You are a hiker preparing for a mountain trip. You are given a 2D array heights where heights[row][col] represents the height of cell (row, col). You start at cell (0, 0), and you want to reach cell (rows-1, cols-1). You are allowed to move up, down, left, or right.\n\nThe effort of a route is the maximum absolute difference in heights between two consecutive cells in the route.\n\nReturn the minimum effort required to travel from the top-left cell to the bottom-right cell.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-------|----------------|-------|\n| 1 | heights = [[1,2,2],[3,8,2],[5,3,5]] | 2 | Path: 1->2->2->3->5. Max diff: 2. |\n| 2 | heights = [[1,5],[2,3],[4,5]] | 3 | Path: 1->2->3->4->5. Max diff: 3. |\n| 3 | heights = [[1,2,3],[4,5,6],[7,8,9]] | 2 | Monotonically increasing. |\n| 4 | heights = [[3]] | 0 | Single cell. |\n| 5 | heights = [[1,10,6,7,9,10,5,10,3,9]] | 4 | 1 -> 6 -> 7 -> 9 -> 10 -> 9. Max diff is 4. |\n| 6 | heights = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14]] | 1 |  |\n| 7 | heights = [[0,2,4,6,8],[1,3,5,7,9],[2,4,6,8,10],[3,5,7,9,11],[4,6,8,10,12]] | 2 |   |\n| 8 | heights = [[1,2],[2,2],[2,1],[1,1],[1,2]] | 1 |   |\n| 9 | heights = [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7]] | 1 |   |\n| 10 | heights = [[8,3,10,4,0],[6,7,3,0,6],[5,1,9,4,9],[1,0,3,1,6],[4,0,3,1,6]] | 5 |    |\n",
    "example": {
      "input": "[[1, 2, 2], [3, 8, 2], [5, 3, 5]]",
      "output": "2",
      "explanation": "The route 1 -> 2 -> 2 -> 3 -> 5 has a maximum absolute difference of 2 between adjacent cells."
    },
    "answer": "import heapq\n\ndef minimum_effort_path(heights):\n    rows, cols = len(heights), len(heights[0])\n    diffs = [[float('inf')] * cols for _ in range(rows)]\n    diffs[0][0] = 0\n    pq = [(0, 0, 0)]  # (effort, r, c)\n\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n\n        if effort > diffs[r][c]:\n            continue\n\n        if r == rows - 1 and c == cols - 1:\n            return effort\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < rows and 0 <= new_c < cols:\n                new_effort = max(effort, abs(heights[r][c] - heights[new_r][new_c]))\n                if new_effort < diffs[new_r][new_c]:\n                    diffs[new_r][new_c] = new_effort\n                    heapq.heappush(pq, (new_effort, new_r, new_c))\n\nif __name__ == \"__main__\":\n    heights_str = input()\n    heights_list = []\n    row_strs = heights_str.strip('[]').split('], [')\n    for row_str in row_strs:\n        row = list(map(int, row_str.strip('[]').split(', ')))\n        heights_list.append(row)\n    result = minimum_effort_path(heights_list)\n    print(result)\n"
  }
             
  ]
}