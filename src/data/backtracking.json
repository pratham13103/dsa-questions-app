{
    "questions": [
      {
        "id": 1,
        "title": "Find all paths in a maze from top-left to bottom-right (Rat in a Maze)",
        "description": "Given an `n x n` binary matrix (0 for blocked, 1 for open), find all paths from (0,0) to (n-1,n-1) moving in 4 directions: up, down, left, right.\n\n### Test Cases\n\n| Input Matrix | Output Paths |\n|--------------|--------------|\n| [[1, 0], [1, 1]] | [\"DR\"] |\n| [[1, 0], [0, 1]] | [] |\n| [[1, 1], [1, 1]] | [\"DR\", \"RD\"] |\n| [[1]] | [\"\"] |\n| [[1, 1, 1], [1, 0, 1], [1, 1, 1]] | Many paths (like DDRR, DRDR...) |\n| [[0]] | [] |\n| [[1,0,0],[1,1,0],[1,1,1]] | [\"DDRR\"] |\n| [[1,1,0,1],[1,1,1,1],[0,1,0,1],[1,1,1,1]] | Many paths |\n| [[1,1,1],[1,0,1],[1,1,1]] | Multiple |\n| [[1,1],[1,0]] | [\"D\"] |",
        "example": {
          "input": "[[1, 0], [1, 1]]",
          "output": "[\"DR\"]",
          "explanation": "Only one valid path exists from top-left to bottom-right."
        },
        "answer": "def rat_in_maze(maze, x, y, path, n, res):\n    if x == n - 1 and y == n - 1:\n        res.append(path)\n        return\n    directions = [(1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R'), (-1, 0, 'U')]\n    maze[x][y] = 0\n    for dx, dy, move in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < n and maze[nx][ny] == 1:\n            rat_in_maze(maze, nx, ny, path + move, n, res)\n    maze[x][y] = 1\n\ndef solve(maze):\n    res = []\n    if maze[0][0] == 1:\n        rat_in_maze(maze, 0, 0, '', len(maze), res)\n    return res"
      },
      {
        "id": 2,
        "title": "Place N queens on an N×N board such that no two queens threaten each other",
        "description": "Return all valid arrangements of N queens on an N×N chessboard.\n\n### Test Cases\n\n| N | Output Count |\n|---|---------------|\n| 1 | 1 |\n| 2 | 0 |\n| 3 | 0 |\n| 4 | 2 |\n| 5 | 10 |\n| 6 | 4 |\n| 7 | 40 |\n| 8 | 92 |\n| 9 | 352 |\n| 10 | 724 |",
        "example": {
          "input": "4",
          "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"]...]",
          "explanation": "There are two solutions for 4×4 N-Queens."
        },
        "answer": "def solve_n_queens(n):\n    def backtrack(row, cols, diag1, diag2, board):\n        if row == n:\n            res.append([\"\".join(r) for r in board])\n            return\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n            board[row][col] = 'Q'\n            backtrack(row + 1, cols | {col}, diag1 | {row - col}, diag2 | {row + col}, board)\n            board[row][col] = '.'\n    res = []\n    board = [['.'] * n for _ in range(n)]\n    backtrack(0, set(), set(), set(), board)\n    return res"
      },
      {
        "id": 3,
        "title": "Solve a Sudoku puzzle using backtracking",
        "description": "Fill the empty cells of a partially filled 9×9 Sudoku board so each row, column, and box has digits 1-9.\n\n### Test Cases (Input is a 9x9 board with '.' as empty cells)\n\n| Test | Input Clues | Output Filled |\n|------|--------------|----------------|\n| Easy | Few empty | Valid Sudoku |\n| Medium | 40 empty | Valid Sudoku |\n| Hard | 50+ empty | Valid Sudoku |\n| Empty | All '.' | Multiple solutions |\n| Valid Complete | No change | Same board |\n| 1-cell left | One cell to fill | Solved board |\n| 2 solutions | Ambiguous board | First valid one |\n| Invalid Input | Wrong initial board | No solution |\n| Random Holes | Holes across | Valid solution |\n| Checkerboard | Alternating clues | Solved board |",
        "example": {
          "input": "[[\"5\",\"3\",\".\",...,\".\",\".\"]...]",
          "output": "[[\"5\",\"3\",\"4\",...,\"8\",\"9\"]...]",
          "explanation": "Fills the board according to Sudoku rules."
        },
        "answer": "def is_valid(board, r, c, val):\n    for i in range(9):\n        if board[r][i] == val or board[i][c] == val or board[3*(r//3)+i//3][3*(c//3)+i%3] == val:\n            return False\n    return True\n\ndef solve_sudoku(board):\n    for r in range(9):\n        for c in range(9):\n            if board[r][c] == '.':\n                for d in '123456789':\n                    if is_valid(board, r, c, d):\n                        board[r][c] = d\n                        if solve_sudoku(board): return True\n                        board[r][c] = '.'\n                return False\n    return True"
      },
      {
        "id": 4,
        "title": "Check if a word exists in a 2D board by traversing adjacent cells",
        "description": "Return true if the word can be found in the grid using adjacent letters (up, down, left, right).\n\n### Test Cases\n\n| Board | Word | Result |\n|--------|------|--------|\n| [[\"A\",\"B\"],[\"C\",\"D\"]] | \"ABCD\" | False |\n| [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]] | \"ABCCED\" | True |\n| Same board | \"SEE\" | True |\n| Same board | \"ABCB\" | False |\n| Single cell | \"A\" | True |\n| Single cell | \"B\" | False |\n| Long path | \"ASFDE\" | True |\n| Empty board | \"A\" | False |\n| Diagonal required | \"ACE\" | False |\n| Board with duplicates | \"AAAA\" | Depends |",
        "example": {
          "input": "board = [[\"A\",\"B\"],[\"C\",\"D\"]], word = \"ABCD\"",
          "output": "false",
          "explanation": "Cannot reuse diagonal cells or go backward."
        },
        "answer": "def exist(board, word):\n    rows, cols = len(board), len(board[0])\n    def dfs(r, c, i):\n        if i == len(word): return True\n        if r<0 or c<0 or r>=rows or c>=cols or board[r][c] != word[i]: return False\n        temp, board[r][c] = board[r][c], '#'\n        found = any(dfs(r+dr, c+dc, i+1) for dr, dc in [(0,1),(1,0),(-1,0),(0,-1)])\n        board[r][c] = temp\n        return found\n    return any(dfs(r, c, 0) for r in range(rows) for c in range(cols))"
      },
      {
        "id": 5,
        "title": "Generate all subsets of a set",
        "description": "Return all possible subsets of the given array.\n\n### Test Cases\n\n| Input | Subsets Count |\n|-------|----------------|\n| [] | 1 |\n| [1] | 2 |\n| [1, 2] | 4 |\n| [1, 2, 3] | 8 |\n| [0] | 2 |\n| [1, 2, 2] | 8 |\n| [1, 2, 3, 4] | 16 |\n| ['a', 'b'] | 4 |\n| [-1, -2] | 4 |\n| [1, 1, 1] | 8 |",
        "example": {
          "input": "[1,2,3]",
          "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "explanation": "All subsets generated using inclusion/exclusion."
        },
        "answer": "def subsets(nums):\n    res = []\n    def backtrack(i, path):\n        if i == len(nums):\n            res.append(path[:])\n            return\n        backtrack(i+1, path)\n        path.append(nums[i])\n        backtrack(i+1, path)\n        path.pop()\n    backtrack(0, [])\n    return res"
      },
      {
        "id": 6,
        "title": "Generate all permutations of a list of numbers",
        "description": "Return all permutations of a list of distinct numbers.\n\n### Test Cases\n\n| Input | Permutations Count |\n|-------|---------------------|\n| [1] | 1 |\n| [1, 2] | 2 |\n| [1, 2, 3] | 6 |\n| [1, 2, 3, 4] | 24 |\n| [1, 2, 3, 4, 5] | 120 |\n| [0, 1] | 2 |\n| [-1, 0, 1] | 6 |\n| [3, 2, 1] | 6 |\n| [1, 1, 1] | 1 |\n| [5, 3, 2, 4] | 24 |",
        "example": {
          "input": "[1,2,3]",
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
          "explanation": "All permutations of the list of numbers."
        },
        "answer": "def permute(nums):\n    res = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return res"
      },
      {
        "id": 7,
        "title": "Find all combinations of numbers that sum to a target",
        "description": "Return all unique combinations of numbers from a given list that sum up to a target.\n\n### Test Cases\n\n| Input | Target | Combinations Count |\n|-------|--------|--------------------|\n| [2, 3, 6, 7] | 7 | 2 |\n| [2, 3, 5] | 8 | 2 |\n| [1, 2, 3] | 4 | 1 |\n| [10, 1, 2, 7, 6, 5] | 8 | 4 |\n| [3, 5, 7] | 12 | 1 |\n| [2, 3, 6] | 10 | 1 |\n| [2, 4, 5] | 10 | 1 |\n| [1, 2, 3] | 6 | 2 |\n| [1, 2] | 3 | 1 |\n| [3, 5] | 5 | 1 |",
        "example": {
          "input": "[2, 3, 6, 7], target = 7",
          "output": "[[2, 2, 3], [7]]",
          "explanation": "Combinations that sum to the target value."
        },
        "answer": "def combination_sum(candidates, target):\n    res = []\n    def backtrack(start, target, path):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target: continue\n            path.append(candidates[i])\n            backtrack(i, target - candidates[i], path)\n            path.pop()\n    backtrack(0, target, [])\n    return res"
      },
      {
        "id": 8,
        "title": "Find all subsets of a set (with duplicates)",
        "description": "Return all possible subsets of the given array, including duplicates.\n\n### Test Cases\n\n| Input | Subsets Count |\n|-------|----------------|\n| [] | 1 |\n| [1] | 2 |\n| [1, 2] | 4 |\n| [1, 2, 2] | 6 |\n| [1, 2, 3] | 8 |\n| [1, 2, 2, 3] | 12 |\n| [1, 1, 2] | 6 |\n| [1, 2, 2, 3, 3] | 18 |\n| [4, 4, 4] | 5 |\n| [5, 5, 5] | 6 |",
        "example": {
          "input": "[1, 2, 2]",
          "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]",
          "explanation": "Generates all subsets considering duplicates."
        },
        "answer": "def subsets_with_dup(nums):\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]: continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    nums.sort()\n    backtrack(0, [])\n    return res"
      },
      {
        "id": 9,
        "title": "Partition a string into palindromes",
        "description": "Return all possible palindrome partitions of a string.\n\n### Test Cases\n\n| Input | Palindromes Count |\n|-------|--------------------|\n| a | 1 |\n| ab | 2 |\n| aab | 3 |\n| aabb | 6 |\n| madam | 10 |\n| abcba | 6 |\n| racecar | 15 |\n| aabbcc | 20 |\n| aa | 2 |\n| abba | 4 |",
        "example": {
          "input": "madam",
          "output": "[[\"m\", \"a\", \"d\", \"a\", \"m\"], [\"madam\"]]",
          "explanation": "All possible palindrome partitions."
        },
        "answer": "def partition(s):\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    res = []\n    def backtrack(start, path):\n        if start == len(s):\n            res.append(path[:])\n            return\n        for end in range(start + 1, len(s) + 1):\n            if is_palindrome(s[start:end]):\n                path.append(s[start:end])\n                backtrack(end, path)\n                path.pop()\n    backtrack(0, [])\n    return res"
      },
      {
        "id": 10,
        "title": "Find all possible valid IP addresses from a string of digits",
        "description": "Return all valid IP addresses that can be formed from a string of digits.\n\n### Test Cases\n\n| Input | Valid IPs Count |\n|-------|------------------|\n| \"25525511135\" | 2 |\n| \"0000\" | 1 |\n| \"1111\" | 1 |\n| \"255255255255\" | 1 |\n| \"12345\" | 0 |\n| \"255255255255123\" | 0 |\n| \"19216811\" | 1 |\n| \"000001\" | 1 |\n| \"010010\" | 2 |\n| \"11112222\" | 0 |",
        "example": {
          "input": "25525511135",
          "output": "[\"255.255.11.135\", \"255.255.111.35\"]",
          "explanation": "All valid IP addresses formed."
        },
        "answer": "def restore_ip_addresses(s):\n    res = []\n    def backtrack(start, path):\n        if len(path) == 4 and start == len(s):\n            res.append('.'.join(path))\n            return\n        for end in range(start + 1, min(start + 4, len(s) + 1)):\n            if s[start] == '0' and end > start + 1: continue\n            if 0 <= int(s[start:end]) <= 255:\n                backtrack(end, path + [s[start:end]])\n    backtrack(0, [])\n    return res"
      },
      {
        "id": 11,
        "title": "Word Search II",
        "description": "Find all words from a list in a 2D board of characters.\n\n### Test Cases\n\n| Input | Words Found |\n|-------|-------------|\n| [[\"o\",\"a\",\"a\"], [\"e\",\"t\",\"a\"], [\"i\",\"h\",\"k\"], [\"i\",\"f\",\"l\"], [\"g\",\"r\",\"f\"]], [\"oath\", \"pea\", \"eat\", \"rain\"] | [\"oath\", \"eat\"] |\n| [[\"a\",\"b\",\"c\"], [\"d\",\"e\",\"f\"], [\"g\",\"h\",\"i\"]], [\"abcdef\", \"ghie\", \"cd\"] | [\"abcdef\"] |\n| [[\"a\",\"b\"], [\"c\",\"d\"]], [\"abcd\"] | [\"abcd\"] |\n| [[\"a\"]], [\"a\"] | [\"a\"] |\n| [[\"a\",\"b\"], [\"b\",\"a\"]], [\"ba\"] | [\"ba\"] |\n| [[\"r\",\"a\",\"t\"], [\"a\",\"r\",\"e\"], [\"r\",\"t\",\"e\"]], [\"rat\", \"art\"] | [\"rat\", \"art\"] |\n| [[\"o\",\"b\"], [\"b\",\"a\"], [\"t\",\"y\"]], [\"bat\", \"boy\"] | [\"bat\", \"boy\"] |\n| [[\"z\",\"z\",\"z\"], [\"z\",\"z\",\"z\"], [\"z\",\"z\",\"z\"]], [\"zzz\"] | [\"zzz\"] |\n| [[\"f\",\"o\",\"r\"], [\"e\",\"t\",\"r\"], [\"a\",\"b\",\"t\"]], [\"for\", \"abet\"] | [\"for\"] |\n| [[\"m\",\"i\"], [\"n\",\"e\"]], [\"mine\"] | [\"mine\"] |",
        "example": {
          "input": "[[\"o\", \"a\", \"a\"], [\"e\", \"t\", \"a\"], [\"i\", \"h\", \"k\"], [\"i\", \"f\", \"l\"], [\"g\", \"r\", \"f\"]], [\"oath\", \"pea\", \"eat\", \"rain\"]]",
          "output": "[\"oath\", \"eat\"]",
          "explanation": "Find words from the list in the board by searching in all possible directions."
        },
        "answer": "def find_words(board, words):\n    res = []\n    trie = {}\n    for word in words:\n        node = trie\n        for char in word:\n            node = node.setdefault(char, {})\n        node['$'] = word\n    def backtrack(node, i, j, path):\n        if '$' in node:\n            res.append(path)\n            del node['$']\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return\n        temp = board[i][j]\n        board[i][j] = '#'\n        for x, y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + x, j + y\n            if ni >= 0 and ni < len(board) and nj >= 0 and nj < len(board[0]) and board[ni][nj] in node:\n                backtrack(node[board[ni][nj]], ni, nj, path + board[ni][nj])\n        board[i][j] = temp\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] in trie:\n                backtrack(trie[board[i][j]], i, j, board[i][j])\n    return res"
      },
      {
        "id": 12,
        "title": "Combination Sum III",
        "description": "Find all combinations of k numbers that add up to a number n.\n\n### Test Cases\n\n| Input | Combinations Count |\n|-------|--------------------|\n| 3, 7 | 8 |\n| 3, 9 | 6 |\n| 3, 10 | 3 |\n| 2, 5 | 1 |\n| 4, 15 | 1 |\n| 2, 12 | 6 |\n| 3, 6 | 2 |\n| 3, 8 | 4 |\n| 4, 10 | 2 |\n| 3, 5 | 4 |",
        "example": {
          "input": "3, 7",
          "output": "[[1, 2, 4], [1, 3, 3], [2, 5], [1, 6], [3, 4], [1, 2, 4]]",
          "explanation": "Find all valid combinations of numbers that sum to the target."
        },
        "answer": "def combination_sum3(k, n):\n    res = []\n    def backtrack(start, path, target):\n        if len(path) == k and target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, 10):\n            if i > target: break\n            path.append(i)\n            backtrack(i + 1, path, target - i)\n            path.pop()\n    backtrack(1, [], n)\n    return res"
      },
      {
        "id": 13,
        "title": "Subset Sum",
        "description": "Find all subsets of a list of numbers that sum up to a specific target.\n\n### Test Cases\n\n| Input | Target | Subsets Count |\n|-------|--------|----------------|\n| [1, 2, 3, 4], 5 | 2 |\n| [1, 2, 3, 4], 6 | 3 |\n| [2, 3, 5], 5 | 1 |\n| [1, 2, 3], 3 | 2 |\n| [1, 3, 5], 4 | 1 |\n| [2, 4, 6], 10 | 1 |\n| [1, 2, 5], 5 | 2 |\n| [1, 2], 4 | 1 |\n| [3, 5, 8], 8 | 2 |\n| [4, 6], 10 | 1 |",
        "example": {
          "input": "[1, 2, 3, 4], target = 5",
          "output": "[[1, 4], [2, 3]]",
          "explanation": "Find all subsets of the list that sum to the target."
        },
        "answer": "def subset_sum(nums, target):\n    res = []\n    def backtrack(start, path, target):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target: continue\n            path.append(nums[i])\n            backtrack(i + 1, path, target - nums[i])\n            path.pop()\n    backtrack(0, [], target)\n    return res"
      },     
      {
        "id": 14,
        "title": "Permutations II (with duplicates)",
        "description": "Generate all unique permutations of a list with possible duplicate values.\n\n### Test Cases\n\n| Input | Permutations Count |\n|-------|--------------------|\n| [1,1,2] | 3 |\n| [1,2,3] | 6 |\n| [1,1,1] | 1 |\n| [2,2,3] | 3 |\n| [3,3,3] | 1 |\n| [1,2,2,3] | 12 |\n| [4,4,4] | 1 |\n| [2,2,5] | 3 |\n| [1,2] | 2 |\n| [5,4,5] | 3 |",
        "example": {
          "input": "[1,1,2]",
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]",
          "explanation": "Generate all unique permutations considering duplicates."
        },
        "answer": "def permute_unique(nums):\n    res = []\n    def backtrack(start, path):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for i in range(len(nums)):\n            if i > start and nums[i] == nums[i - 1]: continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    nums.sort()\n    backtrack(0, [])\n    return res"
      },
      {
        "id": 15,
        "title": "Generate all permutations of a string",
        "description": "Generate all possible permutations of a given string.",
        "example": {
          "input": "\"abc\"",
          "output": "[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
          "explanation": "All possible ways to arrange the characters of the string."
        },
        "answer": "def permute(s):\n    def backtrack(start, s):\n        if start == len(s):\n            result.append(''.join(s))\n            return\n        for i in range(start, len(s)):\n            s[start], s[i] = s[i], s[start]\n            backtrack(start + 1, s)\n            s[start], s[i] = s[i], s[start]\n    result = []\n    backtrack(0, list(s))\n    return result"
      },
      {
        "id": 16,
        "title": "Find all subsets of a set",
        "description": "Given a set of distinct integers, return all possible subsets (the power set).",
        "example": {
          "input": "[1, 2, 3]",
          "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
          "explanation": "Generate all combinations of the elements in the set."
        },
        "answer": "def subsets(nums):\n    def backtrack(start, current):\n        result.append(list(current))\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    result = []\n    backtrack(0, [])\n    return result"
      },
      {
        "id": 17,
        "title": "Solve N-Queens problem",
        "description": "Place N queens on an N x N chessboard so that no two queens threaten each other.",
        "example": {
          "input": "4",
          "output": "[['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]",
          "explanation": "All possible solutions to the N-Queens problem for N = 4."
        },
        "answer": "def solveNQueens(n):\n    def is_valid(board, row, col):\n        for i in range(row):\n            if board[i][col] == 'Q' or (col - row + i >= 0 and board[i][col - row + i] == 'Q') or (col + row - i < n and board[i][col + row - i] == 'Q'):\n                return False\n        return True\n    def backtrack(board, row):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if is_valid(board, row, col):\n                board[row][col] = 'Q'\n                backtrack(board, row + 1)\n                board[row][col] = '.'\n    result = []\n    backtrack([['.' for _ in range(n)] for _ in range(n)], 0)\n    return result"
      },
      {
        "id": 18,
        "title": "Word Search",
        "description": "Given a 2D board of characters and a word, find if the word exists in the board by going up, down, left, or right.",
        "example": {
          "input": "[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] , \"ABCCED\"",
          "output": "True",
          "explanation": "The word 'ABCCED' exists in the board."
        },
        "answer": "def exist(board, word):\n    def dfs(i, j, k):\n        if k == len(word):\n            return True\n        if not (0 <= i < len(board) and 0 <= j < len(board[0])) or board[i][j] != word[k]:\n            return False\n        tmp, board[i][j] = board[i][j], '#'\n        found = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return found\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if dfs(i, j, 0):\n                return True\n    return False"
      },
      {
        "id": 19,
        "title": "Combination Sum",
        "description": "Given an array of candidate numbers (distinct integers) and a target, return all unique combinations of candidates where the sum equals the target.",
        "example": {
          "input": "[2, 3, 6, 7], 7",
          "output": "[[2, 2, 3], [7]]",
          "explanation": "The two combinations that sum up to 7 are [2, 2, 3] and [7]."
        },
        "answer": "def combinationSum(candidates, target):\n    def backtrack(start, target, current):\n        if target == 0:\n            result.append(list(current))\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                continue\n            current.append(candidates[i])\n            backtrack(i, target - candidates[i], current)\n            current.pop()\n    result = []\n    backtrack(0, target, [])\n    return result"
      },
      {
        "id": 20,
        "title": "Letter Combinations of a Phone Number",
        "description": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent based on a phone keypad.",
        "example": {
          "input": "\"23\"",
          "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
          "explanation": "Each digit corresponds to a set of characters. For example, '2' corresponds to 'a', 'b', 'c' and '3' corresponds to 'd', 'e', 'f'."
        },
        "answer": "def letterCombinations(digits):\n    if not digits:\n        return []\n    phone_map = {\n        '2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'],\n        '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'],\n        '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z']\n    }\n    def backtrack(start, current):\n        if len(current) == len(digits):\n            result.append(''.join(current))\n            return\n        for letter in phone_map[digits[start]]:\n            current.append(letter)\n            backtrack(start + 1, current)\n            current.pop()\n    result = []\n    backtrack(0, [])\n    return result"
      }      
    ]
}
  