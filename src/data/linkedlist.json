{
    "questions": [
      {
        "id": 1,
        "title": "Reverse a singly linked list",
        "description": "Write a function that reverses a singly linked list.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1, 2, 3]   | None   | [3, 2, 1]       | Standard case |\n| 2          | [5, 6, 7]   | None   | [7, 6, 5]       | Simple input |\n| 3          | []          | None   | []              | Empty list |\n| 4          | [1]         | None   | [1]             | Single element |\n| 5          | [10, 20]    | None   | [20, 10]        | Two element list |\n| 6          | [1, 2, 3, 4] | None   | [4, 3, 2, 1]   | Even number of elements |\n| 7          | [100, 200]  | None   | [200, 100]      | Two large values |\n| 8          | [10, 100, 1000] | None | [1000, 100, 10] | Larger values |\n| 9          | [0, 0, 0]   | None   | [0, 0, 0]       | All zeros |\n| 10         | [1, 2]      | None   | [2, 1]          | Small list |",
        "example": {
          "input": "[1, 2, 3]",
          "output": "[3, 2, 1]",
          "explanation": "Reversing the list results in [3, 2, 1]."
        },
        "answer": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseList(self, head):\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev\n\n# Helper function to create a linked list from a list\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\n# Helper function to convert a linked list to a list\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\n# Read the input list directly\ninput_list = eval(input())\nlinked_list = create_linked_list(input_list)\n\n# Reverse the linked list\nsolution = Solution()\nreversed_list = solution.reverseList(linked_list)\n\n# Print the reversed list\nprint(linked_list_to_list(reversed_list))"

      },
      {
        "id": 2,
        "title": "Detect a loop in a singly linked list",
        "description": "Write a function to detect if a loop exists in a singly linked list.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1, 2, 3]   | Loop at 2   | True        | Standard case |\n| 2          | [1, 2]      | No loop    | False        | Small list |\n| 3          | [1, 2, 3, 4, 5] | Loop at 4 | True | Larger list with loop |\n| 4          | []          | No loop    | False        | Empty list |\n| 5          | [1]         | No loop    | False        | Single element |\n| 6          | [1, 2, 3, 4] | Loop at 3  | True        | List with a loop |\n| 7          | [10, 20, 30] | Loop at 20 | True        | Simple loop test |\n| 8          | [5, 6, 7, 8] | No loop    | False        | No loop present |\n| 9          | [1, 2, 3, 4, 5] | No loop    | False        | No loop |\n| 10         | [1, 2]      | Loop at 1  | True        | Only two nodes |",
        "example": {
          "input": "[1, 2, 3] with loop at 2",
          "output": "True",
          "explanation": "The list contains a loop, so the function returns True."
        },
        "answer": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def hasCycle(self, head):\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n\n# Helper function to create a linked list with a cycle\ndef create_linked_list_with_cycle(values, make_cycle=False):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    node_map = {0: head}\n    \n    for i, val in enumerate(values[1:], start=1):\n        current.next = ListNode(val)\n        current = current.next\n        node_map[i] = current\n    \n    # Create a cycle if specified\n    if make_cycle and len(values) > 1:\n        current.next = head  # Simple cycle to the head for this example\n    \n    return head\n\n# Read the input list directly\ninput_list = eval(input())\nmake_cycle = len(input_list) > 2  # Simple assumption for testing\nlinked_list = create_linked_list_with_cycle(input_list, make_cycle)\n\n# Detect the cycle\nsolution = Solution()\nprint(solution.hasCycle(linked_list))"
      },
      {
        "id": 3,
        "title": "Remove duplicates from a sorted singly linked list",
        "description": "Write a function to remove duplicates from a sorted singly linked list.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1, 1, 2, 3] | None   | [1, 2, 3]       | Duplicates removed |\n| 2          | [5, 5, 5, 6] | None   | [5, 6]          | Duplicates removed |\n| 3          | [1, 1, 1, 1] | None   | [1]             | All elements are duplicates |\n| 4          | []          | None   | []              | Empty list |\n| 5          | [1, 2, 3]   | None   | [1, 2, 3]       | No duplicates |\n| 6          | [10, 10, 10, 10, 10] | None | [10] | All identical elements |\n| 7          | [2, 2, 3]   | None   | [2, 3]          | Two duplicates |\n| 8          | [0, 1, 1, 2] | None   | [0, 1, 2]       | Sorted input |\n| 9          | [4, 5, 5, 5, 6] | None | [4, 5, 6] | Removing duplicates |\n| 10         | [7, 7, 8, 8, 8] | None | [7, 8] | Multiple duplicates |",
        "example": {
          "input": "[1, 1, 2, 3]",
          "output": "[1, 2, 3]",
          "explanation": "Duplicates have been removed from the sorted list."
        },
        "answer": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def deleteDuplicates(self, head):\n        current = head\n        while current and current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        return head\n\n# Helper function to create a linked list from a list\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\n# Helper function to convert a linked list to a list\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\n# Read the input list directly\ninput_list = eval(input())\nlinked_list = create_linked_list(input_list)\n\n# Remove duplicates\nsolution = Solution()\nunique_list = solution.deleteDuplicates(linked_list)\n\n# Print the resulting list\nprint(linked_list_to_list(unique_list))"
      },
      {
        "id": 4,
        "title": "Add two numbers represented by linked lists",
        "description": "Write a function to add two numbers represented by linked lists, where each node contains a single digit. The digits are stored in reverse order.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [2, 4, 3], [5, 6, 4]  | None | [7, 0, 8] | Standard case |\n| 2          | [1], [9] | None | [0, 1] | Single element lists |\n| 3          | [9, 9], [1] | None | [0, 0, 1] | Carry over case |\n| 4          | [1, 2], [3, 4] | None | [4, 6] | Simple add |\n| 5          | [9, 9], [9, 9] | None | [8, 9, 1] | Large numbers |\n| 6          | [5, 6], [5, 6] | None | [0, 2, 1] | Simple sum |\n| 7          | [0], [0] | None | [0] | Zero case |\n| 8          | [1, 9], [9, 9] | None | [0, 9, 1] | Multiple carries |\n| 9          | [1, 1, 1], [9, 9, 9] | None | [0, 1, 1, 1] | Larger numbers |\n| 10         | [2, 5], [7] | None | [9, 5] | Different length lists |",
        "example": {
          "input": "[2, 4, 3], [5, 6, 4]",
          "output": "[7, 0, 8]",
          "explanation": "The sum of [2, 4, 3] and [5, 6, 4] is [7, 0, 8]."
        },
        "answer": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Function to add two numbers represented by linked lists\ndef addTwoNumbers(l1, l2):\n    carry = 0\n    dummy = ListNode(0)\n    current = dummy\n    \n    # Iterate through both lists until both are exhausted\n    while l1 or l2 or carry:\n        # Sum the current digits plus any carry\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n        total = val1 + val2 + carry\n        \n        # Calculate new digit and carry\n        carry = total // 10\n        current.next = ListNode(total % 10)\n        \n        # Move to the next node\n        current = current.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    \n    return dummy.next\n\n# Helper function to convert a list to a linked list\ndef list_to_linked_list(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\n# Helper function to convert a linked list to a list\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(head.val)\n        head = head.next\n    return result\n\n# Read the input lists\nl1 = list(map(int, input().split()))\nl2 = list(map(int, input().split()))\n\n# Convert lists to linked lists\nlist1 = list_to_linked_list(l1)\nlist2 = list_to_linked_list(l2)\n\n# Add the two numbers and print the result\nresult = addTwoNumbers(list1, list2)\nprint(linked_list_to_list(result))"
      },
      {
        "id": 5,
        "title": "Find the middle element (Fast and Slow Pointers)",
        "description": "Write a function to find the middle element of a singly linked list using fast and slow pointers.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1, 2, 3, 4, 5] | None | 3 | Odd number of elements |\n| 2          | [1, 2, 3, 4] | None | 2 | Even number of elements |\n| 3          | [1, 2, 3] | None | 2 | Odd list |\n| 4          | [5, 6, 7, 8, 9] | None | 7 | Middle element |\n| 5          | [10, 20, 30] | None | 20 | Simple list |\n| 6          | [1, 2] | None | 1 | Two elements |\n| 7          | [0, 1, 2, 3] | None | 2 | Medium element |\n| 8          | [0, 0, 0, 0, 0] | None | 0 | Repeating elements |\n| 9          | [4, 5, 6, 7] | None | 5 | Even sized list |\n| 10         | [3, 4, 5, 6, 7] | None | 5 | Larger list |\n",
        "example": {
          "input": "[1, 2, 3, 4, 5]",
          "output": "3",
          "explanation": "The middle element of the list is 3."
        },
        "answer": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def middleNode(self, head):\n        slow = head\n        fast = head\n        \n        # Move fast one step ahead to ensure the first middle is chosen for even lengths\n        if fast and fast.next:\n            fast = fast.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n\n# Helper function to create a linked list from a list\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\n# Helper function to convert the middle node to its value\ndef linked_list_to_value(node):\n    return node.val if node else None\n\n# Read the input list directly\ninput_list = eval(input().strip())\nlinked_list = create_linked_list(input_list)\n\n# Find the middle element\nsolution = Solution()\nmiddle_node = solution.middleNode(linked_list)\n\n# Print the middle element's value\nprint(linked_list_to_value(middle_node))"
      },
      {
        "id": 6,
        "title": "Merge two sorted linked lists",
        "description": "Write a function to merge two sorted linked lists into a single sorted list.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1, 2, 4], [1, 3, 4] | None | [1, 1, 2, 3, 4, 4] | Merging two sorted lists |\n| 2          | [1, 2], [1, 2] | None | [1, 1, 2, 2] | Equal elements |\n| 3          | [0], [5] | None | [0, 5] | Simple merge |\n| 4          | [1, 3, 5], [2, 4, 6] | None | [1, 2, 3, 4, 5, 6] | Sorted list |\n| 5          | [1, 2, 3], [4, 5] | None | [1, 2, 3, 4, 5] | Sorted merge |\n| 6          | [1], [2] | None | [1, 2] | Two element merge |\n| 7          | [10, 20], [5, 15] | None | [5, 10, 15, 20] | Different values |\n| 8          | [], [5, 10] | None | [5, 10] | Empty list merge |\n| 9          | [1, 4], [2, 3] | None | [1, 2, 3, 4] | Different lengths |\n| 10         | [5, 6, 7], [1, 2] | None | [1, 2, 5, 6, 7] | Another merge case |",
        "example": {
          "input": "[1, 2, 4], [1, 3, 4]",
          "output": "[1, 1, 2, 3, 4, 4]",
          "explanation": "After merging, the result is [1, 1, 2, 3, 4, 4]."
        },
        "answer": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        # Create a dummy node to simplify the merge process\n        dummy = ListNode(0)\n        current = dummy\n        \n        # Merge the two lists\n        while l1 and l2:\n            if l1.val < l2.val:\n                current.next = l1\n                l1 = l1.next\n            else:\n                current.next = l2\n                l2 = l2.next\n            current = current.next\n        \n        # Attach any remaining elements\n        current.next = l1 or l2\n        \n        # Return the merged list (skip the dummy node)\n        return dummy.next\n\n# Helper function to create a linked list from a list\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\n# Helper function to convert a linked list to a Python list\ndef linked_list_to_list(node):\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\n# Read the two input lists directly\ninput_list1, input_list2 = eval(input().strip())\nl1 = create_linked_list(input_list1)\nl2 = create_linked_list(input_list2)\n\n# Merge the two lists\nsolution = Solution()\nresult_list_node = solution.mergeTwoLists(l1, l2)\n\n# Print the result as a list\nprint(linked_list_to_list(result_list_node))"
      },
      {
        "id": 7,
        "title": "Flatten a multilevel doubly linked list",
        "description": "Write a function to flatten a multilevel doubly linked list.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1->2->3], 3->[4->5] | None | [1->2->3->4->5] | One level of nesting |\n| 2          | [1->2], 2->[3], 3->[4] | None | [1->2->3->4] | Multiple nested levels |\n| 3          | [1] | None | [1] | Single node |\n| 4          | [] | None | [] | Empty list |\n| 5          | [1->2->3], 2->[4->5], 5->[6] | None | [1->2->4->5->6->3] | Deep nesting |\n| 6          | [1->2->3], 1->[4], 4->[5] | None | [1->4->5->2->3] | Child before sibling |\n| 7          | [10], 10->[20], 20->[30->40] | None | [10->20->30->40] | Complex multilevel |\n| 8          | [1->2], 1->[3->4], 4->[5] | None | [1->3->4->5->2] | Mid-child node |\n| 9          | [1], 1->[2], 2->[3], 3->[4] | None | [1->2->3->4] | Deep chain |\n| 10         | [1->2->3], 2->[] | None | [1->2->3] | Empty child list |",
        "example": {
          "input": "[1->2->3], where 3 has child [4->5]",
          "output": "[1->2->3->4->5]",
          "explanation": "Children are flattened into the main list."
        },
        "answer": {
  "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef sum_of_linked_list(head):\n    sum_val = 0\n    current = head\n    while current:\n        sum_val += current.data\n        current = current.next\n    return sum_val\n\nif __name__ == \"__main__\":\n    input_str = input()\n    nodes_str = input_str.split(\"->\")\n    head = None\n    current = None\n    for node_str in nodes_str:\n        data_str = node_str.strip()\n        if data_str == \"NULL\":\n            break\n        data = int(data_str)\n        new_node = Node(data)\n        if not head:\n            head = new_node\n            current = head\n        else:\n            current.next = new_node\n            current = new_node\n\n    result = sum_of_linked_list(head)\n    print(result)"
}

      },
      {
        "id": 8,
        "title": "Convert a Binary Tree to Doubly Linked List",
        "description": "Convert a binary tree to a doubly linked list in in-order fashion.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [10,5,15] | None | [5<->10<->15] | Balanced tree |\n| 2          | [10,null,20] | None | [10<->20] | Right skewed tree |\n| 3          | [10,null] | None | [10] | Single node |\n| 4          | [] | None | [] | Empty tree |\n| 5          | [1,2,3,4,5,6,7] | None | [4<->2<->5<->1<->6<->3<->7] | Full tree |\n| 6          | [1] | None | [1] | Single node tree |\n| 7          | [3,2,4,1] | None | [1<->2<->3<->4] | Subtree balancing |\n| 8          | [10,6,14,4,8,12,16] | None | [4<->6<->8<->10<->12<->14<->16] | Full tree |\n| 9          | [2,1,null,null,null] | None | [1<->2] | Two nodes left-only |\n| 10         | [2,null,3,null,4] | None | [2<->3<->4] | Right path only |",
        "example": {
          "input": "Binary tree [10,5,15]",
          "output": "[5<->10<->15]",
          "explanation": "In-order traversal creates the doubly linked list."
        },
        "answer": "# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Definition for a doubly linked list node\nclass DoublyListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\n# Convert binary tree to doubly linked list\ndef btreeToDoublyList(root):\n    if not root:\n        return None\n    \n    # Initialize the head and tail for the DLL\n    head = None\n    prev = None\n    \n    # In-order traversal to build the doubly linked list\n    def inorder(node):\n        nonlocal head, prev\n        if not node:\n            return\n        \n        # Visit the left subtree\n        inorder(node.left)\n        \n        # Convert the current node\n        dll_node = DoublyListNode(node.val)\n        if prev:\n            prev.next = dll_node\n            dll_node.prev = prev\n        else:\n            head = dll_node\n        \n        # Move the prev pointer\n        prev = dll_node\n        \n        # Visit the right subtree\n        inorder(node.right)\n    \n    # Build the DLL\n    inorder(root)\n    return head\n\n# Helper function to print the doubly linked list\ndef print_doubly_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    print(result)\n\n# Helper function to build a binary tree from a list\ndef build_tree(arr):\n    if not arr:\n        return None\n    \n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    for i in range(len(arr)):\n        if nodes[i] is not None:\n            left_index = 2 * i + 1\n            right_index = 2 * i + 2\n            if left_index < len(arr):\n                nodes[i].left = nodes[left_index]\n            if right_index < len(arr):\n                nodes[i].right = nodes[right_index]\n    \n    return nodes[0]\n\n# Read the input\ntree_values = list(map(int, input().split()))\n\n# Build the tree and convert it\nroot = build_tree(tree_values)\ndll_head = btreeToDoublyList(root)\n\n# Print the resulting doubly linked list\nprint_doubly_list(dll_head)"
      },
      {
        "id": 9,
        "title": "Rotate a linked list by k nodes",
        "description": "Rotate a singly linked list to the right by k nodes.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1,2,3,4,5] | 2 | [4,5,1,2,3] | Basic rotation |\n| 2          | [1,2,3,4,5] | 5 | [1,2,3,4,5] | Full rotation |\n| 3          | [1,2,3] | 0 | [1,2,3] | Zero rotation |\n| 4          | [1] | 3 | [1] | Single node |\n| 5          | [] | 1 | [] | Empty list |\n| 6          | [10,20,30] | 1 | [30,10,20] | Rotate by 1 |\n| 7          | [10,20,30,40] | 6 | [30,40,10,20] | Rotate more than length |\n| 8          | [5,10,15] | 2 | [10,15,5] | Mid rotation |\n| 9          | [1,2] | 1 | [2,1] | Swap nodes |\n| 10         | [1,2,3,4,5] | 3 | [3,4,5,1,2] | Rotate by 3 |",
        "example": {
          "input": "[1,2,3,4,5] rotated by 2",
          "output": "[4,5,1,2,3]",
          "explanation": "Last 2 nodes move to the front."
        },
        "answer": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef sum_of_linked_list(head):\n    sum_val = 0\n    current = head\n    while current:\n        sum_val += current.data\n        current = current.next\n    return sum_val\n\nif __name__ == \"__main__\":\n    input_str = input()\n    nodes_str = input_str.split(\"->\")\n    head = None\n    current = None\n    for node_str in nodes_str:\n        data_str = node_str.strip()\n        if data_str == \"NULL\":\n            break\n        data = int(data_str)\n        new_node = Node(data)\n        if not head:\n            head = new_node\n            current = head\n        else:\n            current.next = new_node\n            current = new_node\n\n    result = sum_of_linked_list(head)\n    print(result)"
      },
      {
        "id": 10,
        "title": "Check if a linked list is a palindrome",
        "description": "Check if the elements of the linked list form a palindrome.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1,2,3,2,1] | None | true | Odd length palindrome |\n| 2          | [1,2,2,1] | None | true | Even length palindrome |\n| 3          | [1,2,3] | None | false | Not a palindrome |\n| 4          | [1] | None | true | Single element |\n| 5          | [] | None | true | Empty list is valid |\n| 6          | [1,2,1] | None | true | Symmetric list |\n| 7          | [1,2,3,4] | None | false | Increasing sequence |\n| 8          | [10,20,10] | None | true | Non-consecutive values |\n| 9          | [7,8,9,8,7] | None | true | Mirror numbers |\n| 10         | [1,2,3,4,5] | None | false | Straight sequence |",
        "example": {
          "input": "[1,2,3,2,1]",
          "output": "true",
          "explanation": "List reads the same forward and backward."
        },
        "answer": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef isPalindrome(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    prev = None\n    while slow:\n        next_node = slow.next\n        slow.next = prev\n        prev = slow\n        slow = next_node\n    left, right = head, prev\n    while right:\n        if left.val != right.val:\n            return False\n        left = left.next\n        right = right.next\n    return True\n\ndef build_linked_list(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\nvalues = list(map(int, input().split()))\nhead = build_linked_list(values)\nprint(isPalindrome(head))"

      },
      {
        "id": 11,
        "title": "Delete a node without head pointer",
        "description": "Delete a node from a singly linked list given only access to that node.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1,2,3,4,5] | 3 | [1,2,4,5] | Normal deletion |\n| 2          | [1,2,3] | 2 | [1,3] | Middle node |\n| 3          | [1,2] | 1 | [2] | First node simulation |\n| 4          | [1,2] | 2 | Error | Last node can't be deleted |\n| 5          | [1] | 1 | Error | Single node case |\n| 6          | [10,20,30,40] | 20 | [10,30,40] | Normal deletion |\n| 7          | [10,20,30] | 30 | Error | Last node deletion invalid |\n| 8          | [5,6,7,8] | 6 | [5,7,8] | Middle node |\n| 9          | [5,6] | 5 | [6] | First node |\n| 10         | [100] | 100 | Error | Only one node, can't delete |",
        "example": {
          "input": "[1,2,3,4,5] with node 3 deleted",
          "output": "[1,2,4,5]",
          "explanation": "Node 3 is deleted, the list links 2 to 4."
        },
        "answer": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteNode(node):\n    if not node or not node.next:\n        return\n    node.val = node.next.val\n    node.next = node.next.next\n\ndef list_to_linked_list(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(head.val)\n        head = head.next\n    return result\n\narr = list(map(int, input().split()))\ntarget = int(input())\nhead = list_to_linked_list(arr)\ncurrent = head\nwhile current and current.val != target:\n    current = current.next\nif current and current.next:\n    deleteNode(current)\nprint(linked_list_to_list(head))"
      },
      {
        "id": 12,
        "title": "Merge two sorted linked lists",
        "description": "Merge two sorted linked lists into one sorted linked list.\n\n| Test Cases | Input Array | Target | Expected Output | Notes |\n|------------|-------------|--------|-----------------|-------|\n| 1          | [1,3,5], [2,4,6] | None | [1,2,3,4,5,6] | Basic merge |\n| 2          | [1], [2] | None | [1,2] | Two nodes |\n| 3          | [1,2,3], [] | None | [1,2,3] | One empty list |\n| 4          | [], [4,5] | None | [4,5] | Other list empty |\n| 5          | [1,2], [3,4,5] | None | [1,2,3,4,5] | Uneven lengths |\n| 6          | [], [] | None | [] | Empty lists |\n| 7          | [5,10], [3,8] | None | [3,5,8,10] | Random order |\n| 8          | [2,3], [1,4] | None | [1,2,3,4] | Simple merge |\n| 9          | [10,20], [5,15] | None | [5,10,15,20] | Middle insertion |\n| 10         | [1,3,5], [2,4,6,8] | None | [1,2,3,4,5,6,8] | Different lengths |",
        "example": {
          "input": "[1,3,5], [2,4,6]",
          "output": "[1,2,3,4,5,6]",
          "explanation": "Lists are merged by comparing nodes."
        },
        "answer": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef swap_nodes(head, x, y):\n    if x == y:\n        return head\n\n    prev_x = None\n    curr_x = head\n    while curr_x and curr_x.data != x:\n        prev_x = curr_x\n        curr_x = curr_x.next\n\n    prev_y = None\n    curr_y = head\n    while curr_y and curr_y.data != y:\n        prev_y = curr_y\n        curr_y = curr_y.next\n\n    if not curr_x or not curr_y:\n        return head\n\n    if prev_x:\n        prev_x.next = curr_y\n    else:\n        head = curr_y\n\n    if prev_y:\n        prev_y.next = curr_x\n    else:\n        head = curr_x\n\n    temp = curr_y.next\n    curr_y.next = curr_x.next\n    curr_x.next = temp\n\n    return head\n\ndef print_linked_list(head):\n    current = head\n    while current:\n        print(current.data, end=\" -> \")\n        current = current.next\n    print(\"NULL\")\n\nif __name__ == \"__main__\":\n    input_str = input()\n    swap_str = input()\n\n    list_part, swap_part = input_str.split(\", Swap \")\n    nodes_str = list_part.split(\"->\")\n    swap_values = list(map(int, swap_part.split(\" and \")))\n    x = swap_values[0]\n    y = swap_values[1]\n\n    head = None\n    current_node = None\n    for node_str in nodes_str:\n        data_str = node_str.strip()\n        if data_str == \"NULL\":\n            break\n        data = int(data_str)\n        new_node = Node(data)\n        if not head:\n            head = new_node\n            current_node = head\n        else:\n            current_node.next = new_node\n            current_node = new_node\n\n    modified_head = swap_nodes(head, x, y)\n    print_linked_list(modified_head)"
      },         
      {
        "id": 13,
        "title": "Sort a linkedd list using Merge Sort",
        "description": "Sort a linked list using merge sort algorithm.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [4, 2, 1, 3]     | None   | [1, 2, 3, 4]     | Random unsorted list |\n| 2          | [1]              | None   | [1]              | Single element list |\n| 3          | []               | None   | []               | Empty list |\n| 4          | [5, 4, 3, 2, 1]   | None   | [1, 2, 3, 4, 5]   | Reverse order |\n| 5          | [1, 3, 2]         | None   | [1, 2, 3]         | Minor shuffle |\n| 6          | [7, 7, 7]         | None   | [7, 7, 7]         | Duplicate elements |\n| 7          | [2, 4, 3, 1]       | None   | [1, 2, 3, 4]       | Random order |\n| 8          | [9, 8, 7, 6]       | None   | [6, 7, 8, 9]       | Descending input |\n| 9          | [10, -1, 0, 5]     | None   | [-1, 0, 5, 10]     | Mixed values |\n| 10         | [1, 2, 3, 4, 5]    | None   | [1, 2, 3, 4, 5]    | Already sorted |",
        "example": {
          "input": "[4, 2, 1, 3]",
          "output": "[1, 2, 3, 4]",
          "explanation": "Merge sort divides and merges sorted halves."
        },
        "answer": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge(left, right):\n    if not left:\n        return right\n    if not right:\n        return left\n\n    dummy = ListNode()\n    tail = dummy\n\n    while left and right:\n        if left.val < right.val:\n            tail.next = left\n            left = left.next\n        else:\n            tail.next = right\n            right = right.next\n        tail = tail.next\n\n    if left:\n        tail.next = left\n    elif right:\n        tail.next = right\n\n    return dummy.next\n\ndef getMiddle(head):\n    if not head:\n        return head\n    slow = head\n    fast = head.next\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow\n\ndef mergeSort(head):\n    if not head or not head.next:\n        return head\n\n    mid = getMiddle(head)\n    if not mid:\n        return head\n    left = head\n    right = mid.next\n    mid.next = None\n\n    left = mergeSort(left)\n    right = mergeSort(right)\n    return merge(left, right)\n\ndef createLinkedList(elements):\n    head = None\n    tail = None\n    for val in elements:\n        new_node = ListNode(val)\n        if not head:\n            head = new_node\n            tail = new_node\n        else:\n            tail.next = new_node\n            tail = new_node\n    return head\n\ndef printLinkedList(head):\n    result = []\n    curr = head\n    while curr:\n        result.append(curr.val)\n        curr = curr.next\n    print(result)\n\nif __name__ == \"__main__\":\n    input_list_str = input()\n    try:\n        elements_str = input_list_str.strip(\"[]\").split(\",\")\n        elements = [int(x.strip()) for x in elements_str if x.strip()]\n    except ValueError:\n        elements = []\n\n    head = createLinkedList(elements)\n    sorted_head = mergeSort(head)\n    printLinkedList(sorted_head)"
      },
      
      {
        "id": 14,
        "title": "Implement a circular linked list and traverse it",
        "description": "Create a circular linked list and write a function to traverse it.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [1, 2, 3]        | None   | 1->2->3->1       | Basic case |\n| 2          | [1]              | None   | 1->1             | Single node circular |\n| 3          | []               | None   | Empty            | No nodes |\n| 4          | [10, 20]         | None   | 10->20->10       | Two elements |\n| 5          | [5, 10, 15]      | None   | 5->10->15->5     | Odd nodes |\n| 6          | [1, 2, 3, 4, 5]  | None   | 1->2->3->4->5->1 | Even nodes |\n| 7          | [7]              | None   | 7->7             | Repeats back to itself |\n| 8          | [100, 200]       | None   | 100->200->100    | Custom values |\n| 9          | [8, 6, 4, 2]      | None   | 8->6->4->2->8     | Descending order |\n| 10         | [1, 3, 5, 7, 9]   | None   | 1->3->5->7->9->1  | Odd numbers only |",
        "example": {
          "input": "[1, 2, 3]",
          "output": "1->2->3->1",
          "explanation": "Traversal stops when it loops to the start node."
        },
        "answer": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head\n        else:\n            temp = self.head\n            while temp.next != self.head:\n                temp = temp.next\n            temp.next = new_node\n            new_node.next = self.head\n\n    def traverse(self):\n        if not self.head:\n            print(\"Empty\")\n            return\n        \n        temp = self.head\n        result = []\n        while True:\n            result.append(str(temp.data))\n            temp = temp.next\n            if temp == self.head:\n                break\n        \n        result.append(str(self.head.data))\n        print(\"->\".join(result))\n\nvalues = list(map(int, input().split()))\n\ncll = CircularLinkedList()\nfor value in values:\n    cll.append(value)\n\ncll.traverse()"
      },
      
      {
        "id": 15,
        "title": "Insert a node in a sorted circular linked list",
        "description": "Insert a node into a sorted circular linked list.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [1, 3, 5]        | 4      | 1->3->4->5->1    | Insert in middle |\n| 2          | [1]              | 0      | 0->1->0          | Insert before single node |\n| 3          | []               | 10     | 10->10           | Insert in empty list |\n| 4          | [2, 4, 6]        | 1      | 1->2->4->6->1    | Insert at start |\n| 5          | [2, 4, 6]        | 7      | 2->4->6->7->2    | Insert at end |\n| 6          | [5, 10, 15]      | 10     | 5->10->10->15->5 | Insert duplicate |\n| 7          | [3, 5, 9]        | 7      | 3->5->7->9->3    | Middle insert |\n| 8          | [1, 2, 3]        | 4      | 1->2->3->4->1    | Insert after last |\n| 9          | [10]             | 5      | 5->10->5         | Smaller than one node |\n| 10         | [10]             | 15     | 10->15->10       | Larger than one node |",
        "example": {
          "input": "[1, 3, 5], insert 4",
          "output": "1->3->4->5->1",
          "explanation": "Node 4 is inserted between 3 and 5."
        },
        "answer":  "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass SortedCircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        new_node = Node(data)\n        \n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head\n            return\n        \n        if data < self.head.data:\n            last = self.head\n            while last.next != self.head:\n                last = last.next\n            \n            new_node.next = self.head\n            self.head = new_node\n            last.next = self.head\n            return\n        \n        current = self.head\n        while current.next != self.head and current.next.data < data:\n            current = current.next\n        \n        new_node.next = current.next\n        current.next = new_node\n\n    def traverse(self):\n        if not self.head:\n            print(\"Empty\")\n            return\n        \n        temp = self.head\n        result = []\n        while True:\n            result.append(str(temp.data))\n            temp = temp.next\n            if temp == self.head:\n                break\n        \n        result.append(str(self.head.data))\n        print(\"->\".join(result))\n\nvalues = list(map(int, input().split()))\ninsert_value = int(input())\n\nscll = SortedCircularLinkedList()\nfor value in values:\n    scll.insert(value)\n\nscll.insert(insert_value)\n\nscll.traverse()"
      },
      
      {
        "id": 16,
        "title": "Find the intersection point of two linked lists",
        "description": "Find the node at which two singly linked lists intersect.\n\n| Test Cases | List A         | List B         | Expected Output | Notes |\n|------------|----------------|----------------|------------------|-------|\n| 1          | [1,2,3,4,5]     | [9,4,5]        | 4                | Intersect at 4 |\n| 2          | [1,2,3]         | [4,5,6]        | None             | No intersection |\n| 3          | [1]             | [1]            | 1                | Same node |\n| 4          | []              | []             | None             | Empty lists |\n| 5          | [10,20]         | [15,20]        | 20               | Common node at end |\n| 6          | [5,6,7]         | [6,7,8]        | 6                | Intersect at start |\n| 7          | [1,2]           | [2,3]          | 2                | Small intersection |\n| 8          | [100,200]       | [300,400]      | None             | No intersection |\n| 9          | [3,4,5]         | [2,4,5]        | 4                | Intersect in middle |\n| 10         | [5,10,15]       | [10,15,20]     | 10               | Common node at start |",
        "example": {
          "input": "[1, 2, 3, 4, 5], [9, 4, 5]",
          "output": "4",
          "explanation": "Lists intersect at node with value 4."
        },
        "answer": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef length_of_linked_list(head):\n    count = 0\n    current = head\n    while current:\n        count += 1\n        current = current.next\n    return count\n\nif __name__ == \"__main__\":\n    input_str = input()\n    nodes_str = input_str.split(\"->\")\n    head = None\n    current = None\n    for node_str in nodes_str:\n        data_str = node_str.strip()\n        if data_str == \"NULL\":\n            break\n        data = int(data_str)\n        new_node = Node(data)\n        if not head:\n            head = new_node\n            current = head\n        else:\n            current.next = new_node\n            current = new_node\n\n    result = length_of_linked_list(head)\n    print(result)"
      },
      
      {
        "id": 17,
        "title": "Reverse a linked list",
        "description": "Reverse the entire linked list.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [1, 2, 3]        | None   | 3->2->1          | Reversal |\n| 2          | [4, 5, 6]        | None   | 6->5->4          | Reverse order |\n| 3          | [1]              | None   | 1                | Single node |\n| 4          | []               | None   | Empty            | Empty list |\n| 5          | [5, 6, 7, 8]     | None   | 8->7->6->5       | Four elements |\n| 6          | [10, 9, 8]       | None   | 8->9->10         | Reverse large |\n| 7          | [100, 200]       | None   | 200->100         | Two elements |\n| 8          | [1, 3, 5, 7]     | None   | 7->5->3->1       | Odd elements |\n| 9          | [8, 10]          | None   | 10->8            | Two elements reverse |\n| 10         | [2, 4]           | None   | 4->2             | Two elements small reverse |",
        "example": {
          "input": "[1, 2, 3]",
          "output": "3->2->1",
          "explanation": "Reversal of the entire list."
        },
        "answer":  "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef reverseList(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n\n# Helper function to create a linked list from an array\ndef createLinkedList(arr):\n    if not arr:\n        return None\n    head = Node(arr[0])\n    current = head\n    for value in arr[1:]:\n        current.next = Node(value)\n        current = current.next\n    return head\n\n# Helper function to print the linked list\ndef printLinkedList(head):\n    current = head\n    if current:\n        while current:\n            print(current.data, end=\"->\" if current.next else \"\")\n            current = current.next\n        print()\n\n# Input parsing\nlist_values = list(map(int, input().split()))\n\n# Create the linked list from input\nhead = createLinkedList(list_values)\n\n# Reverse the linked list\nreversed_head = reverseList(head)\n\n# Output the reversed list\nprintLinkedList(reversed_head)"
      },
      
      {
        "id": 18,
        "title": "Detect a cycle in a linked list",
        "description": "Check if a linked list contains a cycle.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [1, 2, 3]        | None   | False            | No cycle |\n| 2          | [4, 5, 6]        | 5      | True             | Cycle present |\n| 3          | [7, 8, 9]        | None   | False            | No cycle |\n| 4          | [1]              | None   | False            | Single node, no cycle |\n| 5          | [5, 10]          | None   | False            | No cycle |\n| 6          | [2, 4, 5]        | 5      | True             | Cycle in middle |\n| 7          | [100]            | None   | False            | No cycle |\n| 8          | [8, 5]           | 8      | True             | Cycle to head |\n| 9          | [2, 5, 7]        | None   | False            | No cycle |\n| 10         | [6, 4, 2]        | None   | False            | No cycle |",
        "example": {
          "input": "[1, 2, 3], cycle at 2",
          "output": "True",
          "explanation": "List has a cycle that starts at node with value 2."
        },
        "answer": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef hasCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n\ndef build_linked_list(values, pos):\n    if not values:\n        return None\n    \n    # Create all the nodes\n    nodes = [ListNode(val) for val in values]\n    \n    # Link all the nodes\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i + 1]\n    \n    # Create the cycle if pos is valid\n    if pos != -1:\n        nodes[-1].next = nodes[pos]\n    \n    return nodes[0]\n\n# Read the input\narr = list(map(int, input().split()))\npos = int(input())\n\n# Build the linked list with a possible cycle\nhead = build_linked_list(arr, pos)\n\n# Check for a cycle\nprint(hasCycle(head))"
      },
      
      {
        "id": 19,
        "title": "Flatten a multilevel linked list",
        "description": "Flatten a linked list where each node can have a child pointer to another list.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [1, 2, 3]        | None   | 1->2->3          | No child nodes |\n| 2          | [1, 2]           | [3]    | 1->2->3          | One child list |\n| 3          | [1, 2, 3]        | [4]    | 1->2->3->4       | Child after last node |\n| 4          | []               | None   | Empty            | No list |\n| 5          | [1, 2, 3]        | [4, 5] | 1->2->3->4->5    | Child in middle |\n| 6          | [6, 7]           | None   | 6->7             | No child node |\n| 7          | [10, 20]         | [30]   | 10->20->30       | Child node insertion |\n| 8          | [5]              | [6]    | 5->6             | Single node with child |\n| 9          | [1, 2, 3, 4]     | [5, 6] | 1->2->3->4->5->6 | Flattened list |\n| 10         | [1]              | [2]    | 1->2             | Single node with child |",
        "example": {
          "input": "[1, 2, 3], [4, 5]",
          "output": "1->2->3->4->5",
          "explanation": "Flattening merges child list into the main list."
        },
        "answer":  "class Node:\n    def __init__(self, val=0, prev=None, next=None, child=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\n# Function to flatten the multilevel doubly linked list\ndef flatten(head):\n    if not head:\n        return None\n\n    current = head\n    stack = []\n\n    # Process each node\n    while current:\n        # If a node has a child, process it\n        if current.child:\n            # If the current node has a next, push it to the stack\n            if current.next:\n                stack.append(current.next)\n            \n            # Connect the current node to its child\n            current.next = current.child\n            current.next.prev = current\n            current.child = None\n        \n        # If there is no next node and the stack is not empty, pop a node\n        if not current.next and stack:\n            current.next = stack.pop()\n            current.next.prev = current\n        \n        # Move to the next node\n        current = current.next\n    \n    return head\n\n# Helper function to print the flattened list\ndef print_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    print(\"->\".join(result))\n\n# Helper function to build a multilevel doubly linked list\ndef build_list(arr, child_arr=None):\n    if not arr:\n        return None\n    \n    # Build the main list\n    nodes = [Node(val) for val in arr]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i + 1]\n        nodes[i + 1].prev = nodes[i]\n    \n    # Add child if provided\n    if child_arr:\n        child_nodes = [Node(val) for val in child_arr]\n        nodes[-1].child = child_nodes[0]\n        for i in range(len(child_nodes) - 1):\n            child_nodes[i].next = child_nodes[i + 1]\n            child_nodes[i + 1].prev = child_nodes[i]\n    \n    return nodes[0]\n\n# Read the input\nmain_list = list(map(int, input().split()))\nchild_list = list(map(int, input().split()))\n\n# Build the multilevel doubly linked list\nhead = build_list(main_list, child_list if child_list else None)\n\n# Flatten the list and print the result\nflattened_head = flatten(head)\nprint_list(flattened_head)"
      },      
      {
        "id": 20,
        "title": "Merge two sorted linked lists",
        "description": "Merge two sorted linked lists into a single sorted list.\n\n| Test Cases | Input Array     | Target | Expected Output | Notes |\n|------------|------------------|--------|------------------|-------|\n| 1          | [1, 3, 5], [2, 4, 6] | None   | [1, 2, 3, 4, 5, 6] | Simple merge |\n| 2          | [1], [2]         | None   | [1, 2]           | Merge single node lists |\n| 3          | [], [1, 2]       | None   | [1, 2]           | One list empty |\n| 4          | [1, 3, 5], []    | None   | [1, 3, 5]        | Other list empty |\n| 5          | [2, 3], [1, 4]   | None   | [1, 2, 3, 4]     | Unequal length lists |\n| 6          | [1, 2, 4], [3, 5] | None   | [1, 2, 3, 4, 5]  | Ordered merge |\n| 7          | [10, 20, 30], [5, 15] | None   | [5, 10, 15, 20, 30] | Reverse elements |\n| 8          | [1], [1]         | None   | [1, 1]           | Duplicate element |\n| 9          | [5, 7], [2, 3, 6] | None   | [2, 3, 5, 6, 7]  | Mixed list merge |\n| 10         | [1, 2], [1, 2]   | None   | [1, 1, 2, 2]     | Merge duplicates |",
        "example": {
          "input": "[1, 3, 5], [2, 4, 6]",
          "output": "[1, 2, 3, 4, 5, 6]",
          "explanation": "Merge both sorted lists into a single sorted list."
        },
        "answer": "class ListNode:\n def __init__(self, val=0, next=None):\n  self.val = val\n  self.next = next\nclass Solution:\n def mergeTwoLists(self, l1, l2):\n  dummy = ListNode(0)\n  current = dummy\n  while l1 and l2:\n   if l1.val < l2.val:\n    current.next = l1\n    l1 = l1.next\n   else:\n    current.next = l2\n    l2 = l2.next\n   current = current.next\n  current.next = l1 or l2\n  return dummy.next\ndef create_linked_list(values):\n if not values:\n  return None\n head = ListNode(values[0])\n current = head\n for val in values[1:]:\n  current.next = ListNode(val)\n  current = current.next\n return head\ndef linked_list_to_list(node):\n result = []\n while node:\n  result.append(node.val)\n  node = node.next\n return result\ninput_list1, input_list2 = eval(input().strip())\nl1 = create_linked_list(input_list1)\nl2 = create_linked_list(input_list2)\nsolution = Solution()\nresult_list_node = solution.mergeTwoLists(l1, l2)\nprint(linked_list_to_list(result_list_node))"
      }
      
      
      
    ]
  }
  