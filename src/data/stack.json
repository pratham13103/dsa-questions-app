{
    "questions": [
        {
            "id": 1,
            "title": "Implement a stack using arrays",
            "description": "Implement a basic stack using arrays with push, pop, peek, and isEmpty operations.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-----------------------------|-------------------|-------------------------------|\n| 1 | push(1), push(2) | [1, 2] | Basic stack operations |\n| 2 | pop() | [1] | Pop operation |\n| 3 | peek() | 2 | Peek operation |\n| 4 | isEmpty() | false | Check if stack is empty |\n| 5 | pop(), pop() | [] | Pop all elements |\n| 6 | push(5), pop() | [5] | One element stack |\n| 7 | push(1), push(2), pop() | [1] | Pop after multiple pushes |\n| 8 | isEmpty() | false | Stack is not empty |\n| 9 | push(10) | [10] | Pushing one element |\n| 10 | pop(), peek() | [] | Stack becomes empty |\n| 11 | push(3), push(4), push(5) | [3,4,5] | Multiple pushes |\n| 12 | pop(), pop() | [3] | Multiple pops |\n| 13 | peek() | 3 | Peek after pops |\n| 14 | isEmpty() | false | Not empty after pops |\n| 15 | pop(), pop(), pop() | [] | Pop until empty |\n| 16 | isEmpty() | true | Now empty |\n| 17 | push(7), push(8), pop(), push(9) | [7,9] | Mixed operations |\n| 18 | peek() | 9 | Peek after mixed |\n| 19 | pop() | [7] | Pop after mixed |\n| 20 | pop() | [] | Pop last element |\n| 21 | isEmpty() | true | Empty again |\n| 22 | push(1), push(2), push(3), pop(), pop(), pop() | [] | Push and pop all |\n| 23 | push(4), peek() | 4 | Peek after push |\n| 24 | pop() | [] | Pop after single push |\n| 25 | isEmpty() | true | Empty after pop |\n| 26 | push(5), push(6), push(7), pop(), peek() | 6 | Peek after pop |\n| 27 | pop(), pop() | [5] | Pop to one element |\n| 28 | pop() | [] | Pop last |\n| 29 | isEmpty() | true | Empty again |\n| 30 | push(8), push(9), push(10), pop(), pop(), push(11), peek() | 11 | Peek after mixed |\n| 31 | pop(), pop() | [8] | Pop to one element |\n| 32 | pop() | [] | Pop last |\n| 33 | isEmpty() | true | Empty again |\n| 34 | push(12), pop(), push(13), peek() | 13 | Peek after pop and push |\n| 35 | pop() | [] | Pop last |\n| 36 | isEmpty() | true | Empty again |\n| 37 | push(14), push(15), pop(), push(16), pop(), peek() | 14 | Peek after mixed |\n| 38 | pop() | [] | Pop last |\n| 39 | isEmpty() | true | Empty again |\n| 40 | pop() | [] | Pop from empty stack |",
            "example": {
              "input": "push(1), push(2), pop()",
              "output": "[1]",
              "explanation": "After pushing 1 and 2, popping removes 2 leaving [1]."
            },
            "answer": "class Stack:\n    def __init__(self):\n        self.stack = []\n    def push(self, x):\n        self.stack.append(x)\n    def pop(self):\n        if self.isEmpty():\n            return None\n        return self.stack.pop()\n    def peek(self):\n        if self.isEmpty():\n            return None\n        return self.stack[-1]\n    def isEmpty(self):\n        return len(self.stack) == 0"
          },
          {
            "id": 2,
            "title": "Implement a stack using linked list",
            "description": "Implement a stack using a linked list with push, pop, peek, and isEmpty operations.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-----------------------------|-------------------|-------------------------------|\n| 1 | push(1), push(2) | [1, 2] | Basic stack operations |\n| 2 | pop() | [1] | Pop operation |\n| 3 | peek() | 2 | Peek operation |\n| 4 | isEmpty() | false | Check if stack is empty |\n| 5 | pop(), pop() | [] | Pop all elements |\n| 6 | push(5), pop() | [5] | One element stack |\n| 7 | push(1), push(2), pop() | [1] | Pop after multiple pushes |\n| 8 | isEmpty() | false | Stack is not empty |\n| 9 | push(10) | [10] | Pushing one element |\n| 10 | pop(), peek() | [] | Stack becomes empty |\n| 11 | push(3), push(4), push(5) | [3,4,5] | Multiple pushes |\n| 12 | pop(), pop() | [3] | Multiple pops |\n| 13 | peek() | 3 | Peek after pops |\n| 14 | isEmpty() | false | Not empty after pops |\n| 15 | pop(), pop(), pop() | [] | Pop until empty |\n| 16 | isEmpty() | true | Now empty |\n| 17 | push(7), push(8), pop(), push(9) | [7,9] | Mixed operations |\n| 18 | peek() | 9 | Peek after mixed |\n| 19 | pop() | [7] | Pop after mixed |\n| 20 | pop() | [] | Pop last element |\n| 21 | isEmpty() | true | Empty again |\n| 22 | push(1), push(2), push(3), pop(), pop(), pop() | [] | Push and pop all |\n| 23 | push(4), peek() | 4 | Peek after push |\n| 24 | pop() | [] | Pop after single push |\n| 25 | isEmpty() | true | Empty after pop |\n| 26 | push(5), push(6), push(7), pop(), peek() | 6 | Peek after pop |\n| 27 | pop(), pop() | [5] | Pop to one element |\n| 28 | pop() | [] | Pop last |\n| 29 | isEmpty() | true | Empty again |\n| 30 | push(8), push(9), push(10), pop(), pop(), push(11), peek() | 11 | Peek after mixed |\n| 31 | pop(), pop() | [8] | Pop to one element |\n| 32 | pop() | [] | Pop last |\n| 33 | isEmpty() | true | Empty again |\n| 34 | push(12), pop(), push(13), peek() | 13 | Peek after pop and push |\n| 35 | pop() | [] | Pop last |\n| 36 | isEmpty() | true | Empty again |\n| 37 | push(14), push(15), pop(), push(16), pop(), peek() | 14 | Peek after mixed |\n| 38 | pop() | [] | Pop last |\n| 39 | isEmpty() | true | Empty again |\n| 40 | pop() | [] | Pop from empty stack |",
            "example": {
              "input": "push(1), push(2), pop()",
              "output": "[1]",
              "explanation": "After pushing 1 and 2, popping removes 2 leaving [1]."
            },
            "answer": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.top\n        self.top = new_node\n    def pop(self):\n        if self.isEmpty():\n            return None\n        temp = self.top\n        self.top = self.top.next\n        return temp.data\n    def peek(self):\n        if self.isEmpty():\n            return None\n        return self.top.data\n    def isEmpty(self):\n        return self.top is None"
          },
      {
        "id": 3,
        "title": "Design a stack that supports getMin()",
        "description": "Design a stack that supports the basic operations of a stack and an additional operation getMin(), which returns the minimum element in the stack.\n\n| Test Cases | Input                    | Expected Output   | Notes                         |\n|------------|--------------------------|-------------------|-------------------------------|\n| 1          | push(1), push(2), getMin() | 1                 | Getting minimum value         |\n| 2          | push(1), push(0), getMin() | 0                 | Handling minimum push         |\n| 3          | pop(), getMin()            | 1                 | After popping minimum         |\n| 4          | push(5), push(3), getMin() | 3                 | Handling minimum after push   |\n| 5          | push(2), getMin()          | 1                 | After multiple operations     |\n| 6          | pop(), getMin()            | 1                 | After popping minimum         |\n| 7          | push(-1), getMin()         | -1                | Negative number handling      |\n| 8          | push(3), push(2), getMin() | 2                 | Handling push operations      |\n| 9          | push(6), push(7), getMin() | 6                 | Another basic operation       |\n| 10         | push(0), getMin()          | 0                 | Edge case with zero           |",
        "example": {
          "input": "push(1), push(2), getMin()",
          "output": "1",
          "explanation": "The minimum value after pushing 1 and 2 is 1."
        },
        "answer": "class Stack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    def push(self, x):\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n    def pop(self):\n        if self.stack:\n            popped = self.stack.pop()\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n    def getMin(self):\n        if self.min_stack:\n            return self.min_stack[-1]\n    def isEmpty(self):\n        return len(self.stack) == 0"
      },
      {
        "id": 4,
        "title": "Evaluate postfix expression",
        "description": "Evaluate a postfix expression using a stack.\n\n| Test Cases | Input                    | Expected Output   | Notes                         |\n|------------|--------------------------|-------------------|-------------------------------|\n| 1          | '2 3 + 5 *'               | 25                | Basic expression               |\n| 2          | '10 2 / 3 +'              | 8                 | Division and addition          |\n| 3          | '5 3 4 + *'               | 35                | Multiplication after addition  |\n| 4          | '4 5 * 3 2 * +'           | 26                | Multiple operations            |\n| 5          | '7 3 - 2 *'               | 8                 | Subtraction and multiplication |\n| 6          | '3 5 + 2 /'               | 4                 | Addition and division          |\n| 7          | '5 1 2 + 4 * + 3 -'       | 14                | Complex operation              |\n| 8          | '2 5 3 + *'               | 16                | More complex operation         |\n| 9          | '2 3 4 + *'               | 14                | Handling multiple operators    |\n| 10         | '5 3 + 7 * 2 +'           | 32                | Mixed operations               |",
        "example": {
          "input": "'2 3 + 5 *'",
          "output": "25",
          "explanation": "Evaluating the expression step by step: (2 + 3) * 5 = 25."
        },
        "answer": "def evaluate_postfix(exp):\n    stack = []\n    for char in exp.split():\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a / b)\n    return stack[0]"
      },
      {
        "id": 5,
        "title": "Convert infix to postfix",
        "description": "Convert an infix expression to a postfix expression using a stack.\n\n| Test Cases | Input                     | Expected Output    | Notes                         |\n|------------|---------------------------|--------------------|-------------------------------|\n| 1          | '3 + 2'                   | '3 2 +'            | Basic addition                 |\n| 2          | 'a * b + c'               | 'a b * c +'        | Parentheses handling          |\n| 3          | '3 * (2 + 5)'             | '3 2 5 + *'        | Parentheses with multiplication |\n| 4          | '(a + b) * (c - d)'       | 'a b + c d - *'    | Multiple operators             |\n| 5          | 'a + b * c'               | 'a b c * +'        | Mixed operators                |\n| 6          | '(3 + 4) * (2 - 5)'       | '3 4 + 2 5 - *'    | Parentheses with multiple operations |\n| 7          | 'a + b * (c + d)'         | 'a b c d + * +'    | Parentheses and addition       |\n| 8          | '(x + y) * z'             | 'x y + z *'        | Parentheses handling           |\n| 9          | 'x * (y + z)'             | 'x y z + *'        | Multiplication first           |\n| 10         | '(a + b) * (c + d)'       | 'a b + c d + *'    | Complex infix expression       |",
        "example": {
          "input": "'3 + 2'",
          "output": "'3 2 +'",
          "explanation": "Simple infix to postfix conversion."
        },
        "answer": "class Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        return self.stack.pop() if not self.isEmpty() else None\n\n    def peek(self):\n        return self.stack[-1] if not self.isEmpty() else None\n\n    def isEmpty(self):\n        return len(self.stack) == 0\n\n\ndef precedence(op):\n    if op == '+' or op == '-':\n        return 1\n    if op == '*' or op == '/':\n        return 2\n    if op == '^':\n        return 3\n    return 0\n\n\ndef infix_to_postfix(expression):\n    result = \"\"\n    stack = Stack()\n\n    for ch in expression:\n        if ch.isalnum():  # operand\n            result += ch\n        elif ch == '(': \n            stack.push(ch)\n        elif ch == ')':\n            while not stack.isEmpty() and stack.peek() != '(': \n                result += stack.pop()\n            stack.pop()  # pop '('\n        else:  # operator\n            while (not stack.isEmpty() and precedence(stack.peek()) >= precedence(ch)):\n                result += stack.pop()\n            stack.push(ch)\n\n    while not stack.isEmpty():\n        result += stack.pop()\n\n    return result\n\n\n# Input\nexpr = input()\n# Output\nprint(infix_to_postfix(expr))"
      },
      {
        "id": 6,
        "title": "Check for balanced parentheses",
        "description": "Check if the parentheses in a string are balanced using a stack.\n\n| Test Cases | Input                | Expected Output   | Notes                         |\n|------------|----------------------|-------------------|-------------------------------|\n| 1          | '(())'                | true              | Basic balanced parentheses     |\n| 2          | '(()'                 | false             | Unbalanced parentheses        |\n| 3          | '()()'                | true              | Multiple balanced parentheses  |\n| 4          | '((()))'              | true              | Nested balanced parentheses    |\n| 5          | ')('                  | false             | Reverse order                 |\n| 6          | '(()())'              | true              | Nested balanced parentheses    |\n| 7          | '(()))'               | false             | Extra closing parenthesis     |\n| 8          | '(((())))'            | true              | More nested parentheses       |\n| 9          | '())('                 | false             | Unbalanced parentheses        |\n| 10         | '(())()'              | true              | Balanced mixed parentheses    |",
        "example": {
          "input": "'(())'",
          "output": "true",
          "explanation": "The parentheses are properly balanced."
        },
        "answer": "class Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        return self.stack.pop() if not self.isEmpty() else None\n\n    def peek(self):\n        return self.stack[-1] if not self.isEmpty() else None\n\n    def isEmpty(self):\n        return len(self.stack) == 0\n\n\ndef is_balanced(expression):\n    stack = Stack()\n    for char in expression:\n        if char == '(': \n            stack.push(char)\n        elif char == ')':\n            if stack.isEmpty():\n                return False\n            stack.pop()\n    return stack.isEmpty()\n\n\n# Input\nexpr = input()\n# Output\nprint(is_balanced(expr))"
      },
      {
        "id": 7,
        "title": "Sort a stack using recursion",
        "description": "Sort a stack using recursion without using any other data structure.\n\n| Test Cases | Input                    | Expected Output   | Notes                         |\n|------------|--------------------------|-------------------|-------------------------------|\n| 1          | [3, 1, 2]                | [1, 2, 3]         | Basic unsorted stack          |\n| 2          | [1, 2, 3]                | [1, 2, 3]         | Already sorted                |\n| 3          | [5, 4, 3, 2, 1]          | [1, 2, 3, 4, 5]   | Larger stack                  |\n| 4          | [3, 5, 2, 4]             | [2, 3, 4, 5]      | Random order                  |\n| 5          | [10, 5, 2]               | [2, 5, 10]        | Mixed numbers                 |\n| 6          | [0, -1, 2]               | [-1, 0, 2]        | Negative numbers               |\n| 7          | [-5, -3, -1]             | [-5, -3, -1]      | Already sorted negative       |\n| 8          | [8, 3, 1]                | [1, 3, 8]         | Small stack                   |\n| 9          | [10, 30, 20]             | [10, 20, 30]      | Simple unsorted stack         |\n| 10         | [10, 20, 30, 5]          | [5, 10, 20, 30]   | Larger unsorted stack         |",
        "example": {
          "input": "[3, 1, 2]",
          "expected_output": "[1, 2, 3]",
          "notes": "Basic unsorted stack"
        
      },
      
        "id": 8,
        "title": "Reverse a stack using recursion",
        "description": "Reverse a stack using recursion without using any other data structure.\n\n| Test Cases | Input                    | Expected Output   | Notes                         |\n|------------|--------------------------|-------------------|-------------------------------|\n| 1          | [1, 2, 3]                | [3, 2, 1]         | Basic stack reversal          |\n| 2          | [10, 5, 2]               | [2, 5, 10]        | Mixed numbers                 |\n| 3          | [3, 2, 1]                | [1, 2, 3]         | Reversed sorted stack         |\n| 4          | [5, 10, 15, 20]          | [20, 15, 10, 5]   | Larger stack                  |\n| 5          | [10]                     | [10]              | Single element                |\n| 6          | [1]                      | [1]               | Single element stack          |\n| 7          | [8, 4, 6]                | [6, 4, 8]         | Random order                  |\n| 8          | [7, 2, 3, 9]             | [9, 3, 2, 7]      | Unsorted stack                |\n| 9          | [100, 200, 300]          | [300, 200, 100]   | Larger values                 |\n| 10         | [9, 8, 7, 6]             | [6, 7, 8, 9]      | Sequential order              |",
        "example": {
          "input": "[1, 2, 3]",
          "output": "[3, 2, 1]",
          "explanation": "After reversing, the elements appear in reverse order."
        },
        "answer": "def insertAtBottom(stack, item):\n    if not stack:\n        stack.append(item)\n    else:\n        temp = stack.pop()\n        insertAtBottom(stack, item)\n        stack.append(temp)\n\ndef reverseStack(stack):\n    if stack:\n        temp = stack.pop()\n        reverseStack(stack)\n        insertAtBottom(stack, temp)\n\nstack = list(map(int, input().split()))\nreverseStack(stack)\nprint(*stack)"
      },
      {
        "id": 9,
        "title": "Implement stack with two queues",
        "description": "Implement a stack using two queues with push and pop operations.\n\n| Test Cases | Input                    | Expected Output   | Notes                         |\n|------------|--------------------------|-------------------|-------------------------------|\n| 1          | push(1), push(2)          | [2, 1]            | Basic stack operations         |\n| 2          | pop()                     | [1]               | Pop operation                  |\n| 3          | push(3), pop()            | [3]               | Push and pop sequence          |\n| 4          | push(4), push(5), pop()   | [5, 4]            | Multiple operations            |\n| 5          | pop(), pop()              | []                | Empty stack                    |\n| 6          | push(6), push(7)          | [7, 6]            | New push operations            |\n| 7          | push(8), pop()            | [8]               | Push and pop                   |\n| 8          | push(9), pop(), push(10)  | [10]              | Mixed operations                |\n| 9          | push(11), pop(), pop()    | []                | Multiple pops                  |\n| 10         | push(12)                  | [12]              | Single push operation          |",
        "example": {
          "input": "push(1), push(2), pop()",
          "output": "[1]",
          "explanation": "The stack is implemented using two queues, pushing and popping elements accordingly."
        },
        "answer": "class Stack:\n    def __init__(self):\n        self.queue1 = []\n        self.queue2 = []\n    def push(self, x):\n        self.queue1.append(x)\n    def pop(self):\n        if len(self.queue1) == 0:\n            return None\n        while len(self.queue1) > 1:\n            self.queue2.append(self.queue1.pop(0))\n        popped = self.queue1.pop(0)\n        self.queue1, self.queue2 = self.queue2, self.queue1\n        return popped"
      },
      {
        "id": 10,
        "title": "Find the middle element of a stack",
        "description": "Find the middle element of a stack in constant time without using any extra space.\n\n| Test Cases | Input                    | Expected Output   | Notes                         |\n|------------|--------------------------|-------------------|-------------------------------|\n| 1          | push(1), push(2), push(3) | 2                 | Middle element after push     |\n| 2          | push(1), push(2)          | 1                 | Only two elements             |\n| 3          | push(10), push(20)        | 10                | Middle of two elements        |\n| 4          | push(5), push(8), push(9) | 8                 | Middle element after push     |\n| 5          | push(7), push(8), push(9), push(10) | 8         | Middle of even number of elements |\n| 6          | push(3), push(4), pop()    | 4                 | After popping an element      |\n| 7          | push(0), pop(), push(2)   | 2                 | After pop operation           |\n| 8          | push(3), push(5), push(7) | 5                 | Middle element                |\n| 9          | push(6), push(8)          | 6                 | After pushing two elements    |\n| 10         | push(3), push(6), push(9) | 6                 | Middle element after push     |",
        "example": {
          "input": "push(1), push(2), push(3)",
          "output": "2",
          "explanation": "The middle element after pushing 1, 2, and 3 is 2."
        },
        "answer": "class Stack:\n    def __init__(self):\n        self.stack = []\n    def push(self, x):\n        self.stack.append(x)\n    def pop(self):\n        if not self.isEmpty():\n            return self.stack.pop()\n    def peek(self):\n        return self.stack[-1] if self.stack else None\n    def isEmpty(self):\n        return len(self.stack) == 0\n    def getMiddle(self):\n        if not self.isEmpty():\n            return self.stack[len(self.stack) // 2]"
      },
      {
        "id": 11,
        "title": "Celebrity problem using stack",
        "description": "Find the celebrity in a group using stack.\n\n| Test Cases | Input                    | Expected Output | Notes                          |\n|------------|--------------------------|-----------------|--------------------------------|\n| 1          | stack(1), stack(2)        | 1               | Two people with celebrity      |\n| 2          | stack(1), stack(3)        | 3               | Person 3 is the celebrity      |\n| 3          | stack(1), stack(2), stack(3) | 2           | Stack after three people       |\n| 4          | pop(), pop()              | []              | Stack after popping two items  |\n| 5          | peek()                    | 2               | Check if celebrity is correct  |\n| 6          | isEmpty()                 | false           | Check if stack is empty        |\n| 7          | push(4)                   | [4]             | Stack after pushing element    |\n| 8          | stack(4), stack(5)        | 5               | Larger group with celebrity    |\n| 9          | stack(1), stack(3)        | 3               | Celebrity should be 3          |\n| 10         | push(10), push(2), pop()  | [10]            | Mixed operations                |\n| 11         | push(1), push(5), pop()   | [1]             | Stack after popping            |\n| 12         | pop(), peek()             | []              | After popping check stack      |\n| 13         | stack(1), stack(2), stack(3), pop() | [1, 2]  | Pop an element from stack      |\n| 14         | push(5), pop(), push(6)   | [6]             | Push and pop elements          |\n| 15         | isEmpty()                 | true            | Stack empty after pop          |\n| 16         | peek()                    | 3               | Verify peek operation          |\n| 17         | push(1), push(4), push(3) | [1, 4, 3]       | Stack after pushing three      |\n| 18         | stack(1), stack(5), pop() | [1]             | Test with different numbers    |\n| 19         | isEmpty()                 | false           | Stack is not empty             |\n| 20         | pop(), pop(), pop()       | []              | Stack becomes empty            |\n| 21         | push(2), peek()           | 2               | Peek after pushing an element  |\n| 22         | stack(4), stack(2)        | 2               | Person 2 is the celebrity      |\n| 23         | pop(), push(3)            | [3]             | Pop then push new element      |\n| 24         | push(7), push(2), pop()   | [7]             | Test with various elements     |\n| 25         | isEmpty()                 | false           | Stack not empty after operations |\n| 26         | stack(2), stack(4), pop() | [2]             | Test with a few elements       |\n| 27         | peek()                    | 2               | Peek to get the celebrity      |\n| 28         | push(8), push(3), pop()   | [8]             | After pop, check remaining stack |\n| 29         | push(5), peek()           | 5               | Peek operation test            |\n| 30         | push(2), pop(), push(5)   | [5]             | Push and pop test              |\n| 31         | stack(1), pop(), peek()   | 1               | Test case with multiple operations |\n| 32         | stack(1), stack(6)        | 6               | Stack with more elements       |\n| 33         | push(5), pop(), push(6), peek() | 6        | Multiple stack operations      |\n| 34         | isEmpty()                 | true            | Check stack is empty after pop |\n| 35         | push(9), pop(), pop()     | []              | Push and multiple pops         |\n| 36         | peek()                    | 1               | Check after pop                |\n| 37         | pop(), push(8)            | [8]             | Pop, then push a new value     |\n| 38         | stack(1), push(2)         | [1, 2]          | Stack after pushing second item |\n| 39         | isEmpty()                 | false           | Check non-empty stack          |\n| 40         | pop()                     | []              | Empty stack after pop          |",
        "example": {
            "input": "stack(1), stack(2), stack(3), pop()",
            "output": "[1, 2]",
            "explanation": "After pushing 1, 2, 3, popping removes 3, leaving [1, 2]."
        },
        "answer": "class Stack:\n    def __init__(self):\n        self.stack = []\n    def push(self, x):\n        self.stack.append(x)\n    def pop(self):\n        if self.isEmpty():\n            return None\n        return self.stack.pop()\n    def peek(self):\n        if self.isEmpty():\n            return None\n        return self.stack[-1]\n    def isEmpty(self):\n        return len(self.stack) == 0"
    },
    {
        "id": 12,
        "title": "Largest rectangle in histogram",
        "description": "Find the largest rectangle in a histogram using stack.\n\n| Test Cases | Input                 | Expected Output | Notes                          |\n|------------|-----------------------|-----------------|--------------------------------|\n| 1          | histogram(2, 1, 5)     | 5               | Simple histogram               |\n| 2          | histogram(6, 2, 5)     | 12              | Larger area                    |\n| 3          | histogram(1, 1, 1, 1)  | 4               | All bars of equal height       |\n| 4          | histogram(3, 1, 6)     | 6               | Maximum area                   |\n| 5          | histogram(7, 8, 3)     | 21              | Larger width and height        |\n| 6          | histogram(5, 2, 6)     | 10              | Test case with varying heights |\n| 7          | histogram(3, 5, 2)     | 15              | Mix of high and low bars       |\n| 8          | histogram(10, 4)       | 40              | Simple test case               |\n| 9          | histogram(4, 5, 2, 7)  | 12              | Mixed heights and widths       |\n| 10         | histogram(6, 3, 4, 5)  | 15              | Simple test case               |\n| 11         | histogram(2, 4, 1, 6)  | 8               | Test with decreasing heights   |\n| 12         | histogram(1, 4, 6, 3)  | 12              | Mixed height values            |\n| 13         | histogram(3, 3, 3)     | 9               | Same heights                   |\n| 14         | histogram(6, 8, 2, 4)  | 16              | Another histogram               |\n| 15         | histogram(1, 6, 2, 3)  | 12              | Varying bars                   |\n| 16         | histogram(3, 2, 1, 4)  | 4               | Decreasing heights             |\n| 17         | histogram(4, 1, 3, 2)  | 6               | Testing decreasing and rising heights |\n| 18         | histogram(7, 6, 5)     | 21              | Descending bars                |\n| 19         | histogram(8, 3, 6)     | 18              | Varying heights                |\n| 20         | histogram(9, 4, 2)     | 18              | Simple descending heights      |\n| 21         | histogram(2, 4, 5)     | 10              | Mixed values                    |\n| 22         | histogram(5, 3, 4)     | 12              | Test case with different areas  |\n| 23         | histogram(4, 2, 7)     | 14              | Mixed with large value         |\n| 24         | histogram(10, 8, 3)    | 24              | Larger values                   |\n| 25         | histogram(6, 5, 4)     | 15              | Test case with diverse heights  |\n| 26         | histogram(7, 9, 3, 2)  | 21              | Mixed bars                      |\n| 27         | histogram(3, 2, 8, 4)  | 16              | Test with various values       |\n| 28         | histogram(1, 5, 7)     | 21              | Decreasing then increasing      |\n| 29         | histogram(9, 1, 5)     | 10              | Mixed case                     |\n| 30         | histogram(2, 5, 6, 8)  | 20              | Test case with height variance |\n| 31         | histogram(3, 4, 5, 7)  | 20              | Larger values                   |\n| 32         | histogram(5, 3, 7)     | 15              | Ascending heights              |\n| 33         | histogram(1, 3, 4, 5)  | 12              | Smaller range                  |\n| 34         | histogram(7, 4, 3)     | 14              | Descending then ascending      |\n| 35         | histogram(4, 5, 8)     | 16              | Varying values                 |\n| 36         | histogram(9, 4, 3, 2)  | 18              | Simple case                    |\n| 37         | histogram(3, 1, 6)     | 6               | Mix of bars                    |\n| 38         | histogram(7, 5, 4)     | 20              | Test with smaller heights      |\n| 39         | histogram(4, 2, 6)     | 12              | Ascending and descending mix   |\n| 40         | histogram(3, 6, 5)     | 15              | Mixed histogram heights        |",
        "example": {
            "input": "histogram(2, 1, 5)",
            "output": "5",
            "explanation": "The largest rectangle formed is 5, formed by the third bar."
        },
        "answer": "class Solution:\n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] >= heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        return max_area"
    },
    {
        "id": 13,
        "title": "Implement stack using queues",
        "description": "Implement a stack using two queues with push, pop, top, and empty operations.\n\n| Test Cases | Input                | Expected Output   | Notes                         |\n|------------|----------------------|-------------------|-------------------------------|\n| 1          | push(1), push(2)     | [1, 2]            | Basic push operations         |\n| 2          | pop()                | 2                 | Pop latest pushed element     |\n| 3          | top()                | 1                 | Check top after pop           |\n| 4          | empty()              | False             | Stack is not empty            |\n| 5          | pop(), pop()         | 1                 | Multiple pops                 |\n| 6          | push(5), top()       | 5                 | Top after one push            |\n| 7          | push(10), push(20), pop() | 20            | Pop in LIFO                   |\n| 8          | push(3), empty()     | False             | Check empty with one element  |\n| 9          | pop(), pop()         | []                | Popping empty stack           |\n| 10         | push(8), push(9), pop() | 9              | Last in first out            |\n| 11         | push(11), top()      | 11                | Push and top                  |\n| 12         | push(12), top()      | 12                | Push and top                  |\n| 13         | push(13), top()      | 13                | Push and top                  |\n| 14         | push(14), top()      | 14                | Push and top                  |\n| 15         | push(15), top()      | 15                | Push and top                  |\n| 16         | push(16), top()      | 16                | Push and top                  |\n| 17         | push(17), top()      | 17                | Push and top                  |\n| 18         | push(18), top()      | 18                | Push and top                  |\n| 19         | push(19), top()      | 19                | Push and top                  |\n| 20         | push(20), top()      | 20                | Push and top                  |\n| 21         | push(21), pop(), empty() | True         | Push pop and check empty      |\n| 22         | push(22), pop(), empty() | True         | Push pop and check empty      |\n| 23         | push(23), pop(), empty() | True         | Push pop and check empty      |\n| 24         | push(24), pop(), empty() | True         | Push pop and check empty      |\n| 25         | push(25), pop(), empty() | True         | Push pop and check empty      |\n| 26         | push(26), pop(), empty() | True         | Push pop and check empty      |\n| 27         | push(27), pop(), empty() | True         | Push pop and check empty      |\n| 28         | push(28), pop(), empty() | True         | Push pop and check empty      |\n| 29         | push(29), pop(), empty() | True         | Push pop and check empty      |\n| 30         | push(30), pop(), empty() | True         | Push pop and check empty      |\n| 31         | empty()              | True              | Empty stack initially         |\n| 32         | empty()              | True              | Empty stack initially         |\n| 33         | empty()              | True              | Empty stack initially         |\n| 34         | empty()              | True              | Empty stack initially         |\n| 35         | empty()              | True              | Empty stack initially         |\n| 36         | empty()              | True              | Empty stack initially         |\n| 37         | empty()              | True              | Empty stack initially         |\n| 38         | empty()              | True              | Empty stack initially         |\n| 39         | empty()              | True              | Empty stack initially         |\n| 40         | empty()              | True              | Empty stack initially         |",
        "example": {
          "input": "push(1), push(2), pop()",
          "output": "2",
          "explanation": "After pushing 1 and 2, popping removes 2 (LIFO order)."
        },
        "answer": "from collections import deque\nclass Stack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self):\n        if not self.q1:\n            return None\n        return self.q1.popleft()\n\n    def top(self):\n        if not self.q1:\n            return None\n        return self.q1[0]\n\n    def empty(self):\n        return not self.q1"
      },
      {
        "id": 14,
        "title": "Remove adjacent duplicates",
        "description": "Remove all adjacent duplicates in a string until none remain.\n\n| Test Cases | Input      | Expected Output | Notes                        |\n|------------|------------|----------------|------------------------------|\n| 1          | aabbcc     | abc            | Basic adjacent duplicates     |\n| 2          | aabccbaa   | abcba          | Remove adjacent then repeat   |\n| 3          |            |                | Empty string                  |\n| 4          | abc        | abc            | No duplicates                 |\n| 5          | aa         |                | All duplicates                |\n| 6          | abccba     | abccba         | Middle pair duplicate         |\n| 7          | abbaca     | ca             | Mixed adjacent                |\n| 8          | aaaaaaaa   |                | All same letters              |\n| 9          | aabbaa     |                | Nested duplicates             |\n| 10         | azxxzy     | ay             | Multi-level removal           |\n| 11         | bcd        | bcd            | Odd pattern                   |\n| 12         | aoa        | aoa            | Even pattern                  |\n| 13         | bcd        | bcd            | Odd pattern                   |\n| 14         | aoa        | aoa            | Even pattern                  |\n| 15         | bcd        | bcd            | Odd pattern                   |\n| 16         | aoa        | aoa            | Even pattern                  |\n| 17         | bcd        | bcd            | Odd pattern                   |\n| 18         | aoa        | aoa            | Even pattern                  |\n| 19         | bcd        | bcd            | Odd pattern                   |\n| 20         | aoa        | aoa            | Even pattern                  |\n| 21         | bcd        | bcd            | Odd pattern                   |\n| 22         | aoa        | aoa            | Even pattern                  |\n| 23         | bcd        | bcd            | Odd pattern                   |\n| 24         | aoa        | aoa            | Even pattern                  |\n| 25         | bcd        | bcd            | Odd pattern                   |\n| 26         | aoa        | aoa            | Even pattern                  |\n| 27         | bcd        | bcd            | Odd pattern                   |\n| 28         | aoa        | aoa            | Even pattern                  |\n| 29         | bcd        | bcd            | Odd pattern                   |\n| 30         | aoa        | aoa            | Even pattern                  |\n| 31         | bcd        | bcd            | Odd pattern                   |\n| 32         | aoa        | aoa            | Even pattern                  |\n| 33         | bcd        | bcd            | Odd pattern                   |\n| 34         | aoa        | aoa            | Even pattern                  |\n| 35         | bcd        | bcd            | Odd pattern                   |\n| 36         | aoa        | aoa            | Even pattern                  |\n| 37         | bcd        | bcd            | Odd pattern                   |\n| 38         | aoa        | aoa            | Even pattern                  |\n| 39         | bcd        | bcd            | Odd pattern                   |\n| 40         | aoa        | aoa            | Even pattern                  |",
        "example": {
          "input": "abbaca",
          "output": "ca",
          "explanation": "Remove 'bb' → 'aaca', then 'aa' → 'ca'"
        },
        "answer": "def remove_adjacent_duplicates(s):\n    stack = []\n    for ch in s:\n        if stack and stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    return ''.join(stack)"
      },
   
      {
        "id": 16,
        "title": "Redundant brackets",
        "description": "Check if an expression contains redundant brackets.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|---------------------|-----------------|-----------------------------|\n| 1  | (a+(b))           | True   | Redundant around b           |\n| 2  | ((a+b))           | True   | Double redundant             |\n| 3  | (a+(b*c))         | False  | Not redundant                |\n| 4  | ((a))             | True   | Single variable, redundant   |\n| 5  | (a+b)             | False  | No redundancy                |\n| 6  | ((a+b)+c)         | True   | Redundant around a+b         |\n| 7  | (a+(b+c))         | False  | No redundancy                |\n| 8  | ((a)+(b))         | True   | Both redundant               |\n| 9  | (a+(b+(c)))       | True   | Nested redundant             |\n| 10 | (a+(b+c+d))       | False  | No redundancy                |\n| 11 | ((a+b)+(c+d))     | True   | Both sides redundant         |\n| 12 | (a+(b*c)+(d))     | True   | Redundant around d           |\n| 13 | (a+b*(c))         | True   | Redundant around c           |\n| 14 | (a+(b*c+d))       | False  | No redundancy                |\n| 15 | ((a+b)*c)         | True   | Redundant around a+b         |\n| 16 | (a+(b/(c)))       | True   | Redundant around c           |\n| 17 | (a+(b/(c+d)))     | False  | No redundancy                |\n| 18 | ((a+b)+(c))       | True   | Redundant around c           |\n| 19 | (a+(b+(c+d)))     | False  | No redundancy                |\n| 20 | (a+(b+(c)))       | True   | Nested redundant             |\n| 21 | (a)               | True   | Single variable, redundant   |\n| 22 | ((a+b)*((c)))     | True   | Redundant around c           |\n| 23 | (a+(b+c)*(d))     | True   | Redundant around d           |\n| 24 | (a+(b+c)*d)       | False  | No redundancy                |\n| 25 | ((a+b)+(c+d+e))   | True   | Redundant around a+b         |\n| 26 | (a+(b+(c+d+e)))   | False  | No redundancy                |\n| 27 | ((a+b)+(c+d+e))   | True   | Redundant around a+b         |\n| 28 | (a+(b+(c+d+e)))   | False  | No redundancy                |\n| 29 | (a+(b+(c+(d))))   | True   | Deep nested redundant        |\n| 30 | (a+(b+(c+(d+e)))) | False  | No redundancy                |\n| 31 | ((a))             | True   | Single variable, redundant   |\n| 32 | (a+(b))           | True   | Redundant around b           |\n| 33 | (a+b)             | False  | No redundancy                |\n| 34 | ((a+b))           | True   | Double redundant             |\n| 35 | (a+(b*c))         | False  | No redundancy                |\n| 36 | (a+(b))           | True   | Redundant around b           |\n| 37 | (a+(b+c))         | False  | No redundancy                |\n| 38 | ((a)+(b))         | True   | Both redundant               |\n| 39 | (a+(b+(c)))       | True   | Nested redundant             |\n| 40 | (a+(b+c+d))       | False  | No redundancy                |",
        "example": {
          "input": "(a+(b))",
          "output": "True",
          "explanation": "The bracket around b is redundant."
        },
        "answer": "def hasRedundantBrackets(expr):\n    stack = []\n    for ch in expr:\n        if ch == ')':\n            top = stack.pop()\n            elements_inside = 0\n            while top != '(': \n                elements_inside += 1\n                top = stack.pop()\n            if elements_inside <= 1:\n                return True\n        else:\n            stack.append(ch)\n    return False"
      },
      {
        "id": 17,
        "title": "Reverse a stack using recursion",
        "description": "Reverse a stack using only recursion (no loops).\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|---------------------|-----------------|-----------------------------|\n| 1  | [1,2,3]           | [3,2,1]   | Simple reversal           |\n| 2  | [1]               | [1]       | One element              |\n| 3  | []                | []        | Empty stack              |\n| 4  | [5,4,3,2,1]       | [1,2,3,4,5] | Odd number of elements   |\n| 5  | [10,20,30,40]     | [40,30,20,10] | Even number of elements |\n| 6  | [7,8,9]           | [9,8,7]   | Three elements           |\n| 7  | [0]               | [0]       | Zero as element          |\n| 8  | [100,200]         | [200,100] | Two elements             |\n| 9  | [1,2,3,4,5,6]     | [6,5,4,3,2,1] | Six elements           |\n| 10 | [9,8,7,6,5]       | [5,6,7,8,9] | Descending order        |\n| 11 | [2,4,6,8]         | [8,6,4,2] | Even numbers             |\n| 12 | [1,3,5,7,9]       | [9,7,5,3,1] | Odd numbers             |\n| 13 | [11,22,33]        | [33,22,11] | Double digits            |\n| 14 | [1,1,1,1]         | [1,1,1,1] | All same elements        |\n| 15 | [5,10,15,20,25]   | [25,20,15,10,5] | Multiples of 5        |\n| 16 | [2,3,2,3]         | [3,2,3,2] | Repeated pattern         |\n| 17 | [0,0,0]           | [0,0,0]   | All zeros                |\n| 18 | [1,2,1,2,1]       | [1,2,1,2,1] | Palindrome              |\n| 19 | [3,2,1,2,3]       | [3,2,1,2,3] | Palindrome              |\n| 20 | [4,3,2,1,0]       | [0,1,2,3,4] | Reverse order           |\n| 21 | [1,2]             | [2,1]     | Two elements             |\n| 22 | [7,6,5,4,3,2,1]   | [1,2,3,4,5,6,7] | Long stack           |\n| 23 | [1,2,3,4,5,6,7,8] | [8,7,6,5,4,3,2,1] | Eight elements      |\n| 24 | [9,7,5,3,1]       | [1,3,5,7,9] | Odd descending         |\n| 25 | [2,4,6,8,10]      | [10,8,6,4,2] | Even ascending         |\n| 26 | [1,3,2,4]         | [4,2,3,1] | Mixed order              |\n| 27 | [5,4,3,2,1,0]     | [0,1,2,3,4,5] | Six elements          |\n| 28 | [10,9,8,7,6,5,4]  | [4,5,6,7,8,9,10] | Seven elements      |\n| 29 | [1,2,3,4,5,6,7,8,9,10] | [10,9,8,7,6,5,4,3,2,1] | Ten elements |\n| 30 | [0,1,0,1,0,1]     | [1,0,1,0,1,0] | Alternating pattern     |\n| 31 | [100]             | [100]     | Single large element     |\n| 32 | [1,2,3,2,1]       | [1,2,3,2,1] | Palindrome              |\n| 33 | [2,4,6,8,10,12]   | [12,10,8,6,4,2] | Even numbers         |\n| 34 | [3,6,9,12,15]     | [15,12,9,6,3] | Multiples of 3         |\n| 35 | [5,10,15,20,25,30]| [30,25,20,15,10,5] | Multiples of 5      |\n| 36 | [1,3,5,7,9,11,13] | [13,11,9,7,5,3,1] | Odd numbers         |\n| 37 | [2,4,6,8,10,12,14]| [14,12,10,8,6,4,2] | Even numbers        |\n| 38 | [1,2,3,4,5,6,7,8,9]| [9,8,7,6,5,4,3,2,1] | Nine elements     |\n| 39 | [0,1,2,3,4,5,6,7,8,9,10]| [10,9,8,7,6,5,4,3,2,1,0] | Eleven elements |\n| 40 | [1,1,2,2,3,3]     | [3,3,2,2,1,1] | Pairs pattern           |",
        "example": {
          "input": "[1, 2, 3]",
          "output": "[3, 2, 1]",
          "explanation": "Reverse by recursive call and insert at bottom."
        },
        "answer": "def insertAtBottom(stack, item):\n    if not stack:\n        stack.append(item)\n    else:\n        temp = stack.pop()\n        insertAtBottom(stack, item)\n        stack.append(temp)\n\ndef reverseStack(stack):\n    if stack:\n        temp = stack.pop()\n        reverseStack(stack)\n        insertAtBottom(stack, temp)\n\nstack = list(map(int, input().split()))\nreverseStack(stack)\nprint(*stack)"
      },
      {
        "id": 18,
        "title": "Count the reversals to balance parentheses",
        "description": "Count minimum reversals to balance an expression of '{' and '}'.\n\n| Test Cases | Input   | Expected Output | Notes                  |\n|------------|---------|----------------|------------------------|\n| 1  | {{{{      | 2              | All opening             |\n| 2  | }}}{{     | 2              | Mixed reversals         |\n| 3  | {{{}}     | -1             | Odd length              |\n| 4  | {}{}      | 0              | Already balanced        |\n| 5  | }}}}      | 2              | All closing             |\n| 6  | {{}}      | 0              | Balanced                |\n| 7  | }{        | 2              | Both need reversal      |\n| 8  | {{}}{}    | 0              | Balanced with extra     |\n| 9  | }}}}{{{{  | 4              | All closing then opening|\n| 10 | }}}}{{    | 3              | More closing            |\n| 11 | {{{}}}    | 1              | One extra opening       |\n| 12 | }{{}      | 1              | One reversal needed     |\n| 13 | {}}{      | 1              | One reversal needed     |\n| 14 | }{}}      | 2              | Two reversals needed    |\n| 15 | {{}}}}    | 1              | One extra closing       |\n| 16 | {{}}{{    | 1              | One extra opening       |\n| 17 | }}}}{{    | 3              | More closing            |\n| 18 | {{}}}}    | 1              | One extra closing       |\n| 19 | }}}}{{{{  | 4              | All closing then opening|\n| 20 | {{}}      | 0              | Balanced                |\n| 21 | }{        | 2              | Both need reversal      |\n| 22 | {{{{      | 2              | All opening             |\n| 23 | }}}}      | 2              | All closing             |\n| 24 | {{}}      | 0              | Balanced                |\n| 25 | }{        | 2              | Both need reversal      |\n| 26 | {{}}{}    | 0              | Balanced with extra     |\n| 27 | }}}}{{{{  | 4              | All closing then opening|\n| 28 | }}}}{{    | 3              | More closing            |\n| 29 | {{{}}}    | 1              | One extra opening       |\n| 30 | }{{}      | 1              | One reversal needed     |\n| 31 | {}}{      | 1              | One reversal needed     |\n| 32 | }{}}      | 2              | Two reversals needed    |\n| 33 | {{}}}}    | 1              | One extra closing       |\n| 34 | {{}}{{    | 1              | One extra opening       |\n| 35 | }}}}{{    | 3              | More closing            |\n| 36 | {{}}}}    | 1              | One extra closing       |\n| 37 | }}}}{{{{  | 4              | All closing then opening|\n| 38 | {{}}      | 0              | Balanced                |\n| 39 | }{        | 2              | Both need reversal      |\n| 40 | {{{{      | 2              | All opening             |",
        "example": {
          "input": "}}{{",
          "output": "2",
          "explanation": "Needs 2 reversals to balance."
        },
        "answer": "def countReversals(expr):\n    if len(expr) % 2 != 0: return -1\n    stack = []\n    for c in expr:\n        if c == '{': stack.append(c)\n        elif stack and stack[-1] == '{': stack.pop()\n        else: stack.append(c)\n    return len(stack) // 2"
      },
      {
        "id": 19,
        "title": "Max area of histogram",
        "description": "Find the largest rectangular area in a histogram.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|---------------------|-----------------|-----------------------------|\n| 1  | [2,1,5,6,2,3]         | 10  | Max area between bars 3-4 |\n| 2  | [2,4]                 | 4   | Two bars                  |\n| 3  | [6,2,5,4,5,1,6]       | 12  | Classic case              |\n| 4  | [1,1,1,1]             | 4   | All same height           |\n| 5  | [4,3,2,1]             | 6   | Descending                |\n| 6  | [1,2,3,4]             | 6   | Ascending                 |\n| 7  | [2,1,2]               | 3   | Valley                    |\n| 8  | [5,4,1,2]             | 5   | Peak at start             |\n| 9  | [1,2,3,4,5]           | 9   | Increasing                |\n| 10 | [5,4,3,2,1]           | 9   | Decreasing                |\n| 11 | [2,2,2,2,2]           | 10  | All same                  |\n| 12 | [1]                   | 1   | Single bar                |\n| 13 | [2,1,2,3,1]           | 4   | Multiple valleys          |\n| 14 | [3,6,5,7,4,8,1,0]     | 16  | Mixed heights             |\n| 15 | [2,1,2,3,1,2,1]       | 5   | Multiple valleys          |\n| 16 | [1,2,3,4,5,3,3,2]     | 12  | Plateau                   |\n| 17 | [2,4,2,1,10,6,10]     | 12  | Tall bar in middle        |\n| 18 | [2,1,2,3,1,2,1,2]     | 5   | Multiple valleys          |\n| 19 | [1,2,3,4,5,6,7,8,9,10]| 30  | Long increasing           |\n| 20 | [10,9,8,7,6,5,4,3,2,1]| 30  | Long decreasing           |\n| 21 | [2,1,2,3,1,2,1,2,1]   | 5   | Multiple valleys          |\n| 22 | [1,2,3,4,5,6,7,8,9]   | 20  | Increasing                |\n| 23 | [9,8,7,6,5,4,3,2,1]   | 20  | Decreasing                |\n| 24 | [2,1,2,3,1,2,1,2,1,2] | 6   | Multiple valleys          |\n| 25 | [1,2,3,4,5,6,7,8]     | 16  | Increasing                |\n| 26 | [8,7,6,5,4,3,2,1]     | 16  | Decreasing                |\n| 27 | [2,1,2,3,1,2,1,2,1,2,1]| 6  | Multiple valleys          |\n| 28 | [1,2,3,4,5,6,7]       | 12  | Increasing                |\n| 29 | [7,6,5,4,3,2,1]       | 12  | Decreasing                |\n| 30 | [2,1,2,3,1,2,1,2,1,2,1,2]| 8 | Multiple valleys         |\n| 31 | [1,2,3,4,5,6]         | 9   | Increasing                |\n| 32 | [6,5,4,3,2,1]         | 9   | Decreasing                |\n| 33 | [2,1,2,3,1,2,1,2,1,2,1,2,1]| 8| Multiple valleys         |\n| 34 | [1,2,3,4,5]           | 9   | Increasing                |\n| 35 | [5,4,3,2,1]           | 9   | Decreasing                |\n| 36 | [2,1,2,3,1,2,1,2,1,2,1,2,1,2]| 10| Multiple valleys      |\n| 37 | [1,2,3,4]             | 6   | Increasing                |\n| 38 | [4,3,2,1]             | 6   | Decreasing                |\n| 39 | [2,1,2,3,1,2,1,2,1,2,1,2,1,2,1]| 10| Multiple valleys     |\n| 40 | [1,2,3]               | 4   | Short increasing          |",
        "example": {
          "input": "[2,1,5,6,2,3]",
          "output": "10",
          "explanation": "Max area from bar 2 to bar 3 with height 5."
        },
        "answer": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    i = 0\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, heights[top] * width)\n    while stack:\n        top = stack.pop()\n        width = i if not stack else i - stack[-1] - 1\n        max_area = max(max_area, heights[top] * width)\n    return max_area\n\nheights = list(map(int, input().split()))\nprint(largestRectangleArea(heights))"
      },
      {
        "id": 20,
        "title": "Histogram with width",
        "description": "Each histogram bar has width. Find max rectangular area.\n\n| Test Cases | Input | Expected Output | Notes |\n|------------|-----------------------------|----------------|-----------------------------|\n| 1  | [(2,1),(1,1)]                   | 2  | Simple case                |\n| 2  | [(2,2),(1,2)]                   | 4  | Width 2                    |\n| 3  | [(1,1),(1,1),(1,1)]             | 3  | All bars width 1           |\n| 4  | [(3,2),(2,1)]                   | 4  | Tall then short            |\n| 5  | [(1,2),(2,2)]                   | 4  | Short then tall            |\n| 6  | [(2,1),(2,1),(2,1)]             | 6  | All bars width 2           |\n| 7  | [(1,3),(2,2),(1,3)]             | 6  | Valley                     |\n| 8  | [(2,2),(2,2),(2,2)]             | 12 | All bars width 2           |\n| 9  | [(1,1),(2,2),(1,1)]             | 4  | Middle wide                |\n| 10 | [(3,1),(1,2),(2,1)]             | 3  | Mixed widths               |\n| 11 | [(1,1),(1,2),(1,3)]             | 3  | Increasing width           |\n| 12 | [(1,3),(1,2),(1,1)]             | 3  | Decreasing width           |\n| 13 | [(2,1),(1,2),(2,1)]             | 4  | Valley                     |\n| 14 | [(1,2),(2,1),(1,2)]             | 2  | Middle short               |\n| 15 | [(2,2),(1,1),(2,2)]             | 4  | Short in middle            |\n| 16 | [(1,1),(2,2),(3,1)]             | 4  | Ascending width            |\n| 17 | [(3,1),(2,2),(1,1)]             | 4  | Descending width           |\n| 18 | [(1,2),(1,2),(1,2)]             | 6  | All same                   |\n| 19 | [(2,1),(1,2),(2,1),(1,2)]       | 4  | Alternating                |\n| 20 | [(1,1),(2,2),(1,1),(2,2)]       | 4  | Alternating                |\n| 21 | [(2,2),(2,2),(2,2),(2,2)]       | 16 | All bars width 2           |\n| 22 | [(1,1),(1,1),(1,1),(1,1)]       | 4  | All bars width 1           |\n| 23 | [(3,1),(2,1),(1,1),(2,1)]       | 4  | Mixed                      |\n| 24 | [(1,2),(2,2),(1,2),(2,2)]       | 8  | All width 2                |\n| 25 | [(2,1),(2,1),(2,1),(2,1)]       | 8  | All bars width 2           |\n| 26 | [(1,3),(2,2),(1,3),(2,2)]       | 8  | Alternating                |\n| 27 | [(2,2),(1,1),(2,2),(1,1)]       | 4  | Alternating                |\n| 28 | [(1,1),(2,2),(3,3)]             | 6  | Increasing width           |\n| 29 | [(3,3),(2,2),(1,1)]             | 6  | Decreasing width           |\n| 30 | [(1,2),(2,1),(3,2)]             | 4  | Mixed                      |\n| 31 | [(2,1),(1,2),(2,1),(1,2),(2,1)] | 4  | Alternating                |\n| 32 | [(1,1),(2,2),(1,1),(2,2),(1,1)] | 4  | Alternating                |\n| 33 | [(2,2),(2,2),(2,2),(2,2),(2,2)] | 20 | All bars width 2           |\n| 34 | [(1,1),(1,1),(1,1),(1,1),(1,1)] | 5  | All bars width 1           |\n| 35 | [(3,1),(2,1),(1,1),(2,1),(3,1)] | 5  | Mixed                      |\n| 36 | [(1,2),(2,2),(1,2),(2,2),(1,2)] | 10 | All width 2                |\n| 37 | [(2,1),(2,1),(2,1),(2,1),(2,1)] | 10 | All bars width 2           |\n| 38 | [(1,3),(2,2),(1,3),(2,2),(1,3)] | 9  | Alternating                |\n| 39 | [(2,2),(1,1),(2,2),(1,1),(2,2)] | 6  | Alternating                |\n| 40 | [(1,1),(2,2),(3,3),(4,4)]       | 10 | Increasing width           |",
        "example": {
          "input": "[(2,2),(1,2)]",
          "output": "4",
          "explanation": "Two bars with width 2, height 1 gives 4."
        },
        "answer": "# Placeholder: This requires detailed bar width processing logic"
      }
    ]
  }
        
  