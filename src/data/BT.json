{
    "questions": [
      {
        "id": 1,
        "title": "Binary Tree Inorder Traversal",
        "description": "Traverse a binary tree in inorder (Left, Root, Right).\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,null,2,3]  | [1,3,2]         | Basic case       |\n| 2         | [1]           | [1]             | Single node      |\n| 3         | []            | []              | Empty tree       |\n| 4         | [1,2]         | [2,1]           | Left child only  |\n| 5         | [1,null,2]    | [1,2]           | Right child only |\n| 6         | [3,1,2]       | [1,3,2]         | Balanced tree    |\n| 7         | [4,2,5,1,3]   | [1,2,4,3,5]     | Multiple levels  |\n| 8         | [1,2,null,3]  | [2,1,3]         | Left skewed      |\n| 9         | [1,null,2]    | [1,2]           | Right skewed     |\n| 10        | [5,3,6,2,4]   | [2,3,4,5,6]     | Tree with full nodes |",
        "example": {
          "input": "[1,null,2,3]",
          "output": "[1,3,2]",
          "explanation": "Visit left first, then root, then right."
        },
        "answer": "def inorderTraversal(root):\n    res = []\n    def dfs(node):\n        if not node: return\n        dfs(node.left)\n        res.append(node.val)\n        dfs(node.right)\n    dfs(root)\n    return res"
      },
      {
        "id": 2,
        "title": "Binary Tree Preorder Traversal",
        "description": "Traverse a binary tree in preorder (Root, Left, Right).\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,null,2,3]  | [1,2,3]         | Basic case       |\n| 2         | [1]           | [1]             | Single node      |\n| 3         | []            | []              | Empty tree       |\n| 4         | [1,2]         | [1,2]           | Left child only  |\n| 5         | [1,null,2]    | [1,2]           | Right child only |\n| 6         | [3,1,2]       | [3,1,2]         | Balanced tree    |\n| 7         | [4,2,5,1,3]   | [4,2,1,3,5]     | Multiple levels  |\n| 8         | [1,2,null,3]  | [1,2,3]         | Left skewed      |\n| 9         | [1,null,2,null,3] | [1,2,3]      | Right skewed     |\n| 10        | [5,3,6,2,4]   | [5,3,2,4,6]     | Tree with full nodes |",
        "example": {
          "input": "[1,null,2,3]",
          "output": "[1,2,3]",
          "explanation": "Visit root first, then left, then right."
        },
        "answer": "def preorderTraversal(root):\n    res = []\n    def dfs(node):\n        if not node: return\n        res.append(node.val)\n        dfs(node.left)\n        dfs(node.right)\n    dfs(root)\n    return res"
      },
      {
        "id": 3,
        "title": "Binary Tree Postorder Traversal",
        "description": "Traverse a binary tree in postorder (Left, Right, Root).\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,null,2,3]  | [3,2,1]         | Basic case       |\n| 2         | [1]           | [1]             | Single node      |\n| 3         | []            | []              | Empty tree       |\n| 4         | [1,2]         | [2,1]           | Left child only  |\n| 5         | [1,null,2]    | [2,1]           | Right child only |\n| 6         | [3,1,2]       | [1,2,3]         | Balanced tree    |\n| 7         | [4,2,5,1,3]   | [1,3,2,5,4]     | Multiple levels  |\n| 8         | [1,2,null,3]  | [3,2,1]         | Left skewed      |\n| 9         | [1,null,2,null,3] | [3,2,1]      | Right skewed     |\n| 10        | [5,3,6,2,4]   | [2,4,3,6,5]     | Tree with full nodes |",
        "example": {
          "input": "[1,null,2,3]",
          "output": "[3,2,1]",
          "explanation": "Visit left first, then right, then root."
        },
        "answer": "def postorderTraversal(root):\n    res = []\n    def dfs(node):\n        if not node: return\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)\n    dfs(root)\n    return res"
      },
      {
        "id": 4,
        "title": "Level Order Traversal (BFS)",
        "description": "Print level-by-level nodes of the binary tree.\n\n| Test Case | Input             | Expected Output   | Notes             |\n|-----------|-------------------|-------------------|-------------------|\n| 1         | [3,9,20,null,null,15,7] | [[3],[9,20],[15,7]] | Basic case       |\n| 2         | [1]               | [[1]]             | Single node       |\n| 3         | []                | []                | Empty tree        |\n| 4         | [1,2,3]           | [[1],[2,3]]       | Balanced tree     |\n| 5         | [1,null,2]        | [[1],[2]]         | Right skewed      |\n| 6         | [1,2,null,3]      | [[1],[2],[3]]     | Left skewed       |\n| 7         | [1,2,3,4,5,6]     | [[1],[2,3],[4,5,6]] | Multiple levels  |\n| 8         | [4,2,7,1,3]       | [[4],[2,7],[1,3]] | Tree with varying levels |\n| 9         | [1,2,null,4]      | [[1],[2],[4]]     | Tree with sparse branches |\n| 10        | [1,2,3,4,5,6,7]   | [[1],[2,3],[4,5,6,7]] | Full tree        |",
        "example": {
          "input": "[3,9,20,null,null,15,7]",
          "output": "[[3],[9,20],[15,7]]",
          "explanation": "Level by level traversal of the tree."
        },
        "answer": "from collections import deque\n\ndef levelOrder(root):\n    if not root: return []\n    queue = deque([root])\n    res = []\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        res.append(level)\n    return res"
      },
      {
        "id": 5,
        "title": "Maximum Depth of Binary Tree",
        "description": "Find the maximum depth (height) of the tree.\n\n| Test Case | Input             | Expected Output | Notes             |\n|-----------|-------------------|-----------------|-------------------|\n| 1         | [3,9,20,null,null,15,7] | 3               | Basic case       |\n| 2         | [1]               | 1               | Single node       |\n| 3         | []                | 0               | Empty tree        |\n| 4         | [1,2,3]           | 2               | Balanced tree     |\n| 5         | [1,null,2]        | 2               | Right skewed      |\n| 6         | [1,2,null,3]      | 3               | Left skewed       |\n| 7         | [1,2,3,4,5]       | 3               | Multiple levels   |\n| 8         | [1,2,3,4,5,6]     | 4               | Full tree         |\n| 9         | [1,2,3,null,4]    | 4               | Tree with varying nodes |\n| 10        | [1,2,3,4,5,6]     | 4               | Full tree         |",
        "example": {
          "input": "[3,9,20,null,null,15,7]",
          "output": "3",
          "explanation": "Depth of the tree is 3."
        },
        "answer": "def maxDepth(root):\n    if not root: return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))"
      },
      {
        "id": 6,
        "title": "Minimum Depth of Binary Tree",
        "description": "Find the minimum depth (from root to nearest leaf).\n\n| Test Case | Input             | Expected Output | Notes             |\n|-----------|-------------------|-----------------|-------------------|\n| 1         | [2,null,3,null,4,null,5,null,6] | 5               | Deep tree        |\n| 2         | [1]               | 1               | Single node       |\n| 3         | []                | 0               | Empty tree        |\n| 4         | [1,2]             | 2               | Balanced tree     |\n| 5         | [1,null,2]        | 2               | Right skewed      |\n| 6         | [1,2,null,3]      | 3               | Left skewed       |\n| 7         | [1,2,3,4,5]       | 3               | Shallow tree      |\n| 8         | [1,2,3,4,5,6]     | 3               | Full tree         |\n| 9         | [1,2,3,null,4]    | 3               | Tree with sparse branches |\n| 10        | [1,2,3,4,5]       | 3               | Full tree         |",
        "example": {
          "input": "[2,null,3,null,4,null,5,null,6]",
          "output": "5",
          "explanation": "Depth of the tree is 5."
        },
        "answer": "def minDepth(root):\n    if not root: return 0\n    if not root.left: return 1 + minDepth(root.right)\n    if not root.right: return 1 + minDepth(root.left)\n    return 1 + min(minDepth(root.left), minDepth(root.right))"
      },
      {
        "id": 7,
        "title": "Check if Tree is Symmetric",
        "description": "Check if the tree is a mirror of itself.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,2,3,4,4,3] | True            | Symmetric tree   |\n| 2         | [1,2,2,3,4,5]   | False           | Asymmetric tree  |\n| 3         | [1,2,2,3,4,5,6] | False           | Asymmetric tree  |\n| 4         | [1,2,3]         | False           | Missing symmetry |\n| 5         | []              | True            | Empty tree       |\n| 6         | [1]             | True            | Single node      |\n| 7         | [1,2,2]         | True            | Simple symmetric |\n| 8         | [1,2,2,3,4]     | False           | Missing symmetry |\n| 9         | [1,2,2,3,4,4]   | True            | Full symmetry    |\n| 10        | [1,2,2,3,4,4,3] | True            | Full symmetry    |",
        "example": {
          "input": "[1,2,2,3,4,4,3]",
          "output": "True",
          "explanation": "The tree is symmetric as left and right subtrees are mirror images."
        },
        "answer": "def isSymmetric(root):\n    def isMirror(t1, t2):\n        if not t1 and not t2: return True\n        if not t1 or not t2: return False\n        return (t1.val == t2.val and\n                isMirror(t1.left, t2.right) and\n                isMirror(t1.right, t2.left))\n    return isMirror(root, root)"
      },
      {
        "id": 8,
        "title": "Check if Two Trees are Identical",
        "description": "Check if two trees are the same.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,3]       | True            | Identical trees  |\n| 2         | [1,2,3]       | True            | Identical trees  |\n| 3         | [1,2]         | False           | Different shapes |\n| 4         | []            | True            | Empty trees      |\n| 5         | [1]           | True            | Single node      |\n| 6         | [1,2]         | False           | Different shapes |\n| 7         | [1,2,3]       | True            | Identical trees  |\n| 8         | [2,3]         | False           | Missing node     |\n| 9         | [1,2,3]       | True            | Identical trees  |\n| 10        | [5,3,6,2,4]   | False           | Trees differ     |",
        "example": {
          "input": "[1,2,3]",
          "output": "True",
          "explanation": "The two trees are identical as all nodes are in the same structure."
        },
        "answer": "def isSameTree(p, q):\n    if not p and not q: return True\n    if not p or not q: return False\n    return (p.val == q.val and\n            isSameTree(p.left, q.left) and\n            isSameTree(p.right, q.right))"
      },
      {
        "id": 9,
        "title": "Diameter of Binary Tree",
        "description": "Find the longest path between any two nodes.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,3,4,5]   | 3               | Basic case       |\n| 2         | [1]           | 0               | Single node      |\n| 3         | []            | 0               | Empty tree       |\n| 4         | [1,2,3]       | 2               | Balanced tree    |\n| 5         | [1,null,2]    | 1               | Right skewed     |\n| 6         | [1,2,null,3]  | 2               | Left skewed      |\n| 7         | [1,2,3,4,5]   | 3               | Multiple levels  |\n| 8         | [1,2,3,4,5,6] | 4               | Full tree        |\n| 9         | [1,2,3,4]     | 3               | Sparse branches  |\n| 10        | [5,3,6,2,4]   | 3               | Multiple levels  |",
        "example": {
          "input": "[1,2,3,4,5]",
          "output": "3",
          "explanation": "The longest path is from node 4 to node 5."
        },
        "answer": "def diameterOfBinaryTree(root):\n    diameter = 0\n    def dfs(node):\n        nonlocal diameter\n        if not node: return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        diameter = max(diameter, left + right)\n        return 1 + max(left, right)\n    dfs(root)\n    return diameter"
      },
      {
        "id": 10,
        "title": "Invert a Binary Tree",
        "description": "Flip the binary tree left-right.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [4,2,7,1,3,6,9] | [4,7,2,9,6,3,1] | Basic case       |\n| 2         | [1]           | [1]             | Single node      |\n| 3         | []            | []              | Empty tree       |\n| 4         | [1,2,3]       | [1,3,2]         | Simple swap      |\n| 5         | [1,2,null,3]  | [1,3,null,2]    | Left skewed      |\n| 6         | [1,null,2]    | [1,2]           | Right skewed     |\n| 7         | [1,2,3,4,5]   | [1,3,2,5,4]     | Multiple levels  |\n| 8         | [1,2,3,4,5,6] | [1,3,2,5,4,6]   | Full tree        |\n| 9         | [1,2,3,4]     | [1,3,2,4]       | Sparse branches  |\n| 10        | [1,2,3,4,5]   | [1,3,2,5,4]     | Varying levels   |",
        "example": {
          "input": "[4,2,7,1,3,6,9]",
          "output": "[4,7,2,9,6,3,1]",
          "explanation": "Swap the left and right subtrees of each node."
        },
        "answer": "def invertTree(root):\n    if not root: return None\n    root.left, root.right = invertTree(root.right), invertTree(root.left)\n    return root"
      },
      {
        "id": 11,
        "title": "Path Sum",
        "description": "Check if tree has a root-to-leaf path that sums to a given value.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [5,4,8,11,null,13,4,7,2,null,null,null,1], TargetSum: 22 | True | Valid path with sum 22 |\n| 2         | [1,2,3], TargetSum: 3 | True | Valid path with sum 3 |\n| 3         | [1,2,3], TargetSum: 5 | False | No valid path with sum 5 |\n| 4         | [1,2,3], TargetSum: 6 | False | No valid path with sum 6 |\n| 5         | [3,9,20,null,null,15,7], TargetSum: 38 | True | Valid path with sum 38 |\n| 6         | [3,9,20,null,null,15,7], TargetSum: 22 | True | Valid path with sum 22 |\n| 7         | [1,2,3], TargetSum: 1 | False | No valid path with sum 1 |\n| 8         | [1,-2,-3,1,3,-2,null,-1], TargetSum: -1 | True | Valid path with sum -1 |\n| 9         | [1,2,3,4,5], TargetSum: 10 | True | Valid path with sum 10 |\n| 10        | [1,2,3,4], TargetSum: 7 | True | Valid path with sum 7 |",
        "example": {
          "input": "[5,4,8,11,null,13,4,7,2,null,null,null,1], TargetSum: 22",
          "output": "True",
          "explanation": "The root-to-leaf path 5 -> 4 -> 11 -> 7 sums up to 22."
        },
        "answer": "def hasPathSum(root, targetSum):\n    if not root: return False\n    if not root.left and not root.right:\n        return root.val == targetSum\n    return (hasPathSum(root.left, targetSum-root.val) or\n            hasPathSum(root.right, targetSum-root.val))"
      },
      {
        "id": 12,
        "title": "Sum of Left Leaves",
        "description": "Find the sum of all left leaf nodes.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [3,9,20,null,null,15,7] | 24 | Left leaf nodes are 9 and 15. Sum = 9 + 15 = 24 |\n| 2         | [1,2,3,4,5]   | 4  | Left leaf node is 4 |\n| 3         | [1,2,3]       | 2  | Left leaf node is 2 |\n| 4         | [1,2,null,3]  | 3  | Left leaf node is 3 |\n| 5         | [1,null,2]    | 0  | No left leaves |\n| 6         | [1,2,3,4,5]   | 4  | Left leaf node is 4 |\n| 7         | [5,4,6,7,8]   | 7  | Left leaf node is 7 |\n| 8         | [1,2,3,4,5]   | 4  | Left leaf node is 4 |\n| 9         | [2,4,5,6,7]   | 6  | Left leaf node is 6 |\n| 10        | [1,2,3,4,5]   | 4  | Left leaf node is 4 |",
        "example": {
          "input": "[3,9,20,null,null,15,7]",
          "output": "24",
          "explanation": "The left leaf node values are 9 and 15, so the sum is 24."
        },
        "answer": "def sumOfLeftLeaves(root):\n    if not root: return 0\n    ans = 0\n    if root.left and not root.left.left and not root.left.right:\n        ans += root.left.val\n    return ans + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)"
      },
      {
        "id": 13,
        "title": "Count Complete Tree Nodes",
        "description": "Count nodes of a complete binary tree.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,3,4,5,6] | 6 | Full binary tree with 6 nodes |\n| 2         | [1,2,3,4,5]   | 5  | Tree missing last leaf node |\n| 3         | [1,2,3]       | 3  | Tree has 3 nodes |\n| 4         | [1,2,null,3]  | 3  | Left-skewed tree with 3 nodes |\n| 5         | [1,2,3,4]     | 4  | Full binary tree with 4 nodes |\n| 6         | [1,2,3,4,5]   | 5  | Tree has 5 nodes |\n| 7         | [1]           | 1  | Single node tree |\n| 8         | [1,2]         | 2  | Simple two-node tree |\n| 9         | [1,2,3,null]  | 3  | Tree with 3 nodes, one missing right child |\n| 10        | [1,2,3,4,5,6,7] | 7 | Full binary tree with 7 nodes |",
        "example": {
          "input": "[1,2,3,4,5,6]",
          "output": "6",
          "explanation": "The tree has 6 nodes in total."
        },
        "answer": "def countNodes(root):\n    if not root: return 0\n    return 1 + countNodes(root.left) + countNodes(root.right)"
      },
      {
        "id": 14,
        "title": "Right Side View",
        "description": "Return the rightmost nodes at each level.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,3,null,5,null,4] | [1,3,4] | Rightmost nodes are 1, 3, and 4 |\n| 2         | [1,2,3,4,5,6] | [1,3,6] | Rightmost nodes are 1, 3, and 6 |\n| 3         | [1,2]         | [1,2]   | Rightmost nodes are 1 and 2 |\n| 4         | [1,2,3,4,5]   | [1,3,5] | Rightmost nodes are 1, 3, and 5 |\n| 5         | [1]           | [1]     | Single node tree |\n| 6         | [1,2,3]       | [1,3]   | Rightmost nodes are 1 and 3 |\n| 7         | [1,2,3,4,5]   | [1,3,5] | Rightmost nodes are 1, 3, and 5 |\n| 8         | [1,2,3,4,5,6] | [1,3,6] | Rightmost nodes are 1, 3, and 6 |\n| 9         | [1,2,3,4]     | [1,3,4] | Rightmost nodes are 1, 3, and 4 |\n| 10        | [1,2,3,4,5]   | [1,3,5] | Rightmost nodes are 1, 3, and 5 |",
        "example": {
          "input": "[1,2,3,null,5,null,4]",
          "output": "[1,3,4]",
          "explanation": "The rightmost nodes at each level are 1, 3, and 4."
        },
        "answer": "def rightSideView(root):\n    res = []\n    def dfs(node, level):\n        if not node: return\n        if level == len(res):\n            res.append(node.val)\n        dfs(node.right, level+1)\n        dfs(node.left, level+1)\n    dfs(root, 0)\n    return res"
      },
      {
        "id": 15,
        "title": "Left Side View",
        "description": "Return the leftmost nodes at each level.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,3,4,5,null,6] | [1,2,4] | Leftmost nodes are 1, 2, and 4 |\n| 2         | [1,2,3,4,5,6] | [1,2,4] | Leftmost nodes are 1, 2, and 4 |\n| 3         | [1,2,3,4]     | [1,2,4] | Leftmost nodes are 1, 2, and 4 |\n| 4         | [1,2,3]       | [1,2]   | Leftmost nodes are 1 and 2 |\n| 5         | [1]           | [1]     | Single node tree |\n| 6         | [1,2,3]       | [1,2]   | Leftmost nodes are 1 and 2 |\n| 7         | [1,2,3,4,5]   | [1,2,4] | Leftmost nodes are 1, 2, and 4 |\n| 8         | [1,2,3,4,5,6] | [1,2,4] | Leftmost nodes are 1, 2, and 4 |\n| 9         | [1,2,3,4]     | [1,2,4] | Leftmost nodes are 1, 2, and 4 |\n| 10        | [1,2,3,4,5]   | [1,2,4] | Leftmost nodes are 1, 2, and 4 |",
        "example": {
          "input": "[1,2,3,4,5,null,6]",
          "output": "[1,2,4]",
          "explanation": "The leftmost nodes at each level are 1, 2, and 4."
        },
        "answer": "def leftSideView(root):\n    res = []\n    def dfs(node, level):\n        if not node: return\n        if level == len(res):\n            res.append(node.val)\n        dfs(node.left, level+1)\n        dfs(node.right, level+1)\n    dfs(root, 0)\n    return res"
      },
      {
        "id": 16,
        "title": "Check if Tree is Balanced",
        "description": "Tree is height-balanced if depth difference ≤ 1.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [3,9,20,null,null,15,7] | True | Tree is balanced |\n| 2         | [1,2,3,4,5]   | False | Tree is not balanced |\n| 3         | [1,2,3,null,null,4] | False | Left side is deeper |\n| 4         | [1,2,3]       | True | Tree is balanced |\n| 5         | [1]           | True | Single node tree |\n| 6         | [1,2,3,4]     | False | Tree is unbalanced |\n| 7         | [1,2,null,3]  | False | Left subtree deeper |\n| 8         | [1,2,3,4,5]   | False | Left side deeper |\n| 9         | [1,2]         | True | Tree is balanced |\n| 10        | [1,2,3,null,4] | False | Right side deeper |",
        "example": {
          "input": "[3,9,20,null,null,15,7]",
          "output": "True",
          "explanation": "The tree is balanced because the difference in heights is ≤ 1."
        },
        "answer": "def isBalanced(root):\n    def height(node):\n        if not node: return 0\n        left_height = height(node.left)\n        right_height = height(node.right)\n        if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n            return -1\n        return 1 + max(left_height, right_height)\n    return height(root) != -1"
      },
      {
        "id": 17,
        "title": "Symmetric Tree",
        "description": "Check if tree is symmetric around its center.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [1,2,2,3,4,4,3] | True | Tree is symmetric |\n| 2         | [1,2,2,null,3,null,3] | False | Tree is not symmetric |\n| 3         | [1,2,2,3,4,4] | False | Tree is not symmetric |\n| 4         | [1,2,2,3,3]   | True | Tree is symmetric |\n| 5         | [1,2,3]       | False | Tree is not symmetric |\n| 6         | [1,2,2,3]     | False | Tree is not symmetric |\n| 7         | [1,2,2,null,3] | False | Tree is not symmetric |\n| 8         | [1,2]         | False | Tree is not symmetric |\n| 9         | [1,2,3,4]     | False | Tree is not symmetric |\n| 10        | [1,2,3]       | False | Tree is not symmetric |",
        "example": {
          "input": "[1,2,2,3,4,4,3]",
          "output": "True",
          "explanation": "The tree is symmetric because left and right subtrees are mirror images of each other."
        },
        "answer": "def isSymmetric(root):\n    def mirror(left, right):\n        if not left and not right: return True\n        if not left or not right: return False\n        return left.val == right.val and mirror(left.left, right.right) and mirror(left.right, right.left)\n    return mirror(root, root)"
      },
      {
        "id": 18,
        "title": "Maximum Depth of Binary Tree",
        "description": "Find the maximum depth of a binary tree.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [3,9,20,null,null,15,7] | 3  | Depth is 3 |\n| 2         | [1,2,3,4,5,6] | 3  | Depth is 3 |\n| 3         | [1,2,3,4,5]   | 3  | Depth is 3 |\n| 4         | [1,2,3,null,4] | 3  | Depth is 3 |\n| 5         | [1,2,3]       | 2  | Depth is 2 |\n| 6         | [1,2]         | 2  | Depth is 2 |\n| 7         | [1]           | 1  | Depth is 1 |\n| 8         | [1,2,3,4,5]   | 3  | Depth is 3 |\n| 9         | [1,2,3,4]     | 3  | Depth is 3 |\n| 10        | [1,2,3,4,5]   | 3  | Depth is 3 |",
        "example": {
          "input": "[3,9,20,null,null,15,7]",
          "output": "3",
          "explanation": "The tree has a depth of 3, with the longest path being from the root to the leaf node 7."
        },
        "answer": "def maxDepth(root):\n    if not root: return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))"
      },
      {
        "id": 19,
        "title": "Balanced Binary Tree",
        "description": "Determine if a binary tree is balanced.\n\n| Test Case | Input         | Expected Output | Notes            |\n|-----------|---------------|-----------------|------------------|\n| 1         | [3,9,20,null,null,15,7] | True | Balanced tree |\n| 2         | [1,2,3,4,5]   | False | Not balanced |\n| 3         | [1,2,3,4]     | False | Not balanced |\n| 4         | [1,2,3]       | True | Balanced tree |\n| 5         | [1]           | True | Single node tree |\n| 6         | [1,2,3,4]     | False | Not balanced |\n| 7         | [1,2,null,3]  | False | Not balanced |\n| 8         | [1,2,3,4,5]   | False | Not balanced |\n| 9         | [1,2]         | True | Balanced tree |\n| 10        | [1,2,3,null,4] | False | Not balanced |",
        "example": {
          "input": "[3,9,20,null,null,15,7]",
          "output": "True",
          "explanation": "The tree is balanced because the difference in heights is ≤ 1."
        },
        "answer": "def isBalanced(root):\n    def height(node):\n        if not node: return 0\n        left_height = height(node.left)\n        right_height = height(node.right)\n        if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n            return -1\n        return 1 + max(left_height, right_height)\n    return height(root) != -1"
      },
      {
        "id": 20,
        "title": "Find Duplicate Subtrees",
        "description": "Find all duplicate subtrees in binary tree.\n\n| Test Case | Input                           | Expected Output  | Notes               |\n|-----------|---------------------------------|------------------|---------------------|\n| 1         | [1,2,3,4,null,2,4,null,null,4]  | [[2,4],[4]]       | Duplicate subtrees  |\n| 2         | [1,2,3,null,null,2,3,null]      | [[2,3]]           | Simple case         |\n| 3         | [1,1,1,1,null,null,1]           | [[1,1]]           | Identical subtrees  |\n| 4         | [3,2,1,4,null,2,5]              | []                | No duplicate        |\n| 5         | [1,2,3,4,5,2,4]                | [[2,4]]           | Duplicate on right  |\n| 6         | [1,2,3,4,5,3,4]                | [[3,4]]           | Duplicate on left   |\n| 7         | [1,2,3,2,4,5,4]                | [[2,4],[4]]       | Multiple duplicates |\n| 8         | [1,2,3,4,5]                    | []                | No duplicates       |\n| 9         | [3,2,1,2,1,3,4]                | [[2,1]]           | Duplicate subtree   |\n| 10        | [1,1,2,2,3,3]                  | [[2,3]]           | Identical subtrees  |",
        "example": {
          "input": "[1,2,3,4,null,2,4,null,null,4]",
          "output": "[[2,4],[4]]",
          "explanation": "There are two duplicate subtrees [2,4] and [4] in the tree."
        },
        "answer": "from collections import defaultdict\n\ndef findDuplicateSubtrees(root):\n    count = defaultdict(int)\n    res = []\n    def dfs(node):\n        if not node: return \"#\"\n        serial = f\"{node.val},{dfs(node.left)},{dfs(node.right)}\"\n        count[serial] += 1\n        if count[serial] == 2:\n            res.append(node)\n        return serial\n    dfs(root)\n    return res"
      },
      {
        "id": 21,
        "title": "Construct Binary Tree from Inorder and Preorder Traversal",
        "description": "Build tree from given traversals.\n\n| Test Case | Preorder             | Inorder              | Notes                            |\n|-----------|----------------------|----------------------|----------------------------------|\n| 1         | [3,9,20,15,7]        | [9,3,15,20,7]        | Balanced binary tree             |\n| 2         | [1,2,4,5,3,6]        | [4,2,5,1,3,6]        | Left and right subtree           |\n| 3         | [1,2]                | [2,1]                | Skewed to left                   |\n| 4         | [1,2]                | [1,2]                | Skewed to right                  |\n| 5         | [1]                  | [1]                  | Single node                      |\n| 6         | [1,2,3]              | [3,2,1]              | Reversed structure               |\n| 7         | [1,2,3,4,5]          | [5,4,3,2,1]          | All nodes to the left            |\n| 8         | [5,4,3,2,1]          | [1,2,3,4,5]          | All nodes to the right           |\n| 9         | [10,20,30,40,50]     | [20,10,40,30,50]     | Random structure                 |\n| 10        | [1,2,3,4,5,6,7]      | [4,2,5,1,6,3,7]      | Complete binary tree             |\n| 11        | [7,6,5,4,3,2,1]      | [1,2,3,4,5,6,7]      | Right-skewed reversed tree       |\n| 12        | [3,1,2]              | [1,3,2]              | Complex branching                |\n| 13        | [8,4,2,6,12,10,14]   | [2,4,6,8,10,12,14]   | BST formation                    |\n| 14        | [5,3,2,4,8,7,9]      | [2,3,4,5,7,8,9]      | Balanced BST                     |\n| 15        | [4,2,1,3,6,5,7]      | [1,2,3,4,5,6,7]      | Symmetric tree                   |\n| 16        | [1,3,2,5,4,6]        | [2,3,5,1,6,4]        | Nested left-right combinations   |\n| 17        | [6,2,0,4,3,5,8,7,9]  | [0,2,3,4,5,6,7,8,9]  | Larger BST example               |\n| 18        | [2,1,3]              | [1,2,3]              | Small complete tree              |\n| 19        | [3,2,1,4,5]          | [1,2,3,4,5]          | Mixed skewed tree                |\n| 20        | [1,2,3,4,5,6]        | [6,5,4,3,2,1]        | Reverse of skewed                |\n| 21        | [1,3,2]              | [3,1,2]              | Random branching                 |\n| 22        | [1,2,3]              | [1,3,2]              | One child on wrong side          |\n| 23        | [9,8,7,6,5]          | [5,6,7,8,9]          | Reversed right skewed            |\n| 24        | [5,2,1,3,8,6,10]     | [1,2,3,5,6,8,10]     | Larger BST tree                  |\n| 25        | [1,4,2,3]            | [1,2,4,3]            | Misaligned branches              |\n| 26        | [3,5,4,6]            | [3,4,5,6]            | Middle branch first              |\n| 27        | [4,5,6,7]            | [4,5,6,7]            | Straight chain right             |\n| 28        | [7,6,5,4]            | [4,5,6,7]            | Straight chain left              |\n| 29        | [1,3,5,7]            | [1,3,5,7]            | Right heavy                      |\n| 30        | [8,6,4,7,10,9,11]    | [4,6,7,8,9,10,11]    | Balanced with depth              |\n| 31        | [10,5,1,7,15,12,20]  | [1,5,7,10,12,15,20]  | Complete BST                     |\n| 32        | [1,2,3,4]            | [2,1,4,3]            | Unusual nesting                  |\n| 33        | [6,4,2,5,8,7,9]      | [2,4,5,6,7,8,9]      | BST with close branches          |\n| 34        | [7,2,1,5,4,6,9,8,10] | [1,2,4,5,6,7,8,9,10] | Complete but unordered BST       |\n| 35        | [5,3,1,4,8,6,9]      | [1,3,4,5,6,8,9]      | Standard BST                     |\n| 36        | [4,2,1,3,6,5,7,8]    | [1,2,3,4,5,6,7,8]    | Extended symmetric tree          |\n| 37        | [1,2,4,3]            | [1,2,3,4]            | Reversed levels                  |\n| 38        | [8,3,1,6,4,7,10,9,11]| [1,3,4,6,7,8,9,10,11]| Classic BST                      |\n| 39        | [1,3,2,4]            | [1,2,3,4]            | Skewed in middle                 |\n| 40        | [6,2,1,4,3,5,7]      | [1,2,3,4,5,6,7]      | Nested left-skewed structure     |",
        "example": {
          "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
          "output": "Constructed binary tree with root = 3 and proper left/right structure",
          "explanation": "3 is the root, 9 is the left child, and 20 is the right subtree with 15 and 7 as its children."
        },
        "answer": "def buildTree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    root = TreeNode(preorder.pop(0))\n    idx = inorder.index(root.val)\n    root.left = buildTree(preorder, inorder[:idx])\n    root.right = buildTree(preorder, inorder[idx+1:])\n    return root"
      },
      
      {
          "id": 22,
          "title": "Construct Binary Tree from Inorder and Postorder Traversal",
          "description": "Build tree from given traversals.\n\n| Test Case | Postorder            | Inorder              | Notes                            |\n|-----------|----------------------|----------------------|----------------------------------|\n| 1         | [9,15,7,20,3]        | [9,3,15,20,7]        | Balanced binary tree             |\n| 2         | [4,5,2,6,3,1]        | [4,2,5,1,6,3]        | Left and right subtree           |\n| 3         | [2,1]                | [2,1]                | Skewed to left                   |\n| 4         | [2,1]                | [1,2]                | Skewed to right                  |\n| 5         | [1]                  | [1]                  | Single node                      |\n| 6         | [1,2,3]              | [3,2,1]              | Reversed structure               |\n| 7         | [1,2,3,4,5]          | [5,4,3,2,1]          | All nodes to the left            |\n| 8         | [1,2,3,4,5]          | [1,2,3,4,5]          | All nodes to the right           |\n| 9         | [20,40,50,30,10]     | [20,10,40,30,50]     | Random structure                 |\n| 10        | [4,5,2,6,7,3,1]      | [4,2,5,1,6,3,7]      | Complete binary tree             |\n| 11        | [1,2,3,4,5,6,7]      | [1,2,3,4,5,6,7]      | Right-skewed reversed tree       |\n| 12        | [2,1,3]              | [1,3,2]              | Complex branching                |\n| 13        | [2,6,4,10,14,12,8]   | [2,4,6,8,10,12,14]   | BST formation                    |\n| 14        | [2,4,3,7,9,8,5]      | [2,3,4,5,7,8,9]      | Balanced BST                     |\n| 15        | [1,3,2,5,7,6,4]      | [1,2,3,4,5,6,7]      | Symmetric tree                   |\n| 16        | [2,3,5,6,4,1]        | [2,3,5,1,6,4]        | Nested left-right combinations   |\n| 17        | [0,3,5,4,2,7,9,8,6]  | [0,2,3,4,5,6,7,8,9]  | Larger BST example               |\n| 18        | [1,3,2]              | [1,2,3]              | Small complete tree              |\n| 19        | [1,2,5,4,3]          | [1,2,3,4,5]          | Mixed skewed tree                |\n| 20        | [6,5,4,3,2,1]        | [6,5,4,3,2,1]        | Reverse of skewed                |\n| 21        | [2,3,1]              | [3,1,2]              | Random branching                 |\n| 22        | [3,2,1]              | [1,3,2]              | One child on wrong side          |\n| 23        | [5,6,7,8,9]          | [5,6,7,8,9]          | Reversed right skewed            |\n| 24        | [1,3,2,6,10,8,5]     | [1,2,3,5,6,8,10]     | Larger BST tree                  |\n| 25        | [1,2,3,4]            | [1,2,4,3]            | Misaligned branches              |\n| 26        | [3,4,6,5]            | [3,4,5,6]            | Middle branch first              |\n| 27        | [4,5,6,7]            | [4,5,6,7]            | Straight chain right             |\n| 28        | [7,6,5,4]            | [4,5,6,7]            | Straight chain left              |\n| 29        | [1,3,5,7]            | [1,3,5,7]            | Right heavy                      |\n| 30        | [4,7,6,9,11,10,8]    | [4,6,7,8,9,10,11]    | Balanced with depth              |\n| 31        | [1,7,5,12,20,15,10]  | [1,5,7,10,12,15,20]  | Complete BST                     |\n| 32        | [2,4,3,1]            | [2,1,4,3]            | Unusual nesting                  |\n| 33        | [2,5,4,7,9,8,6]      | [2,4,5,6,7,8,9]      | BST with close branches          |\n| 34        | [1,4,3,2,6,9,10,8,7] | [1,2,3,4,6,7,8,9,10] | Complete but unordered BST       |\n| 35        | [1,4,3,5,6,9,8]      | [1,3,4,5,6,8,9]      | Standard BST                     |\n| 36        | [1,3,2,5,7,6,8,4]    | [1,2,3,4,5,6,7,8]    | Extended symmetric tree          |\n| 37        | [4,3,2,1]            | [1,2,3,4]            | Reversed levels                  |\n| 38        | [1,4,3,6,7,5,9,11,10,8] | [1,3,4,5,6,7,8,9,10,11] | Classic BST              |\n| 39        | [2,3,1,4]            | [1,2,3,4]            | Skewed in middle                 |\n| 40        | [1,3,2,5,4,7,6]      | [1,2,3,4,5,6,7]      | Nested left-skewed structure     |",
          "example": {
            "input": "inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]",
            "output": "Constructed binary tree with root = 3 and proper left/right structure",
            "explanation": "3 is the root, 9 is the left child, and 20 is the right subtree with 15 and 7 as its children."
          },
          "answer": "def buildTree(inorder, postorder):\n    if not inorder or not postorder: return None\n    root = TreeNode(postorder.pop())\n    idx = inorder.index(root.val)\n    root.right = buildTree(inorder[idx+1:], postorder)\n    root.left = buildTree(inorder[:idx], postorder)\n    return root"
      },
      {
        "id": 23,
        "title": "Flatten Binary Tree to Linked List",
        "description": "Flatten tree into a linked list in-place.\n\n| Test Case | Input             | Output              | Notes                      |\n|-----------|-------------------|-----------------------|----------------------------|\n| 1         | [1,2,5,3,4,null,6] | [1,null,2,null,3,null,4,null,5,null,6] | Mixed left-right subtrees   |\n| 2         | [1,2,null,3]       | [1,null,2,null,3]     | Skewed to the left         |\n| 3         | [1,null,2,null,3]   | [1,null,2,null,3]     | Skewed to the right        |\n| 4         | [1,2,3]            | [1,null,2,null,3]     | Simple tree                |\n| 5         | [1,2,3,4,5]        | [1,null,2,null,3,null,4,null,5] | Full binary tree            |\n| 6         | [1]                 | [1]                   | Single node                |\n| 7         | [1,2]               | [1,null,2]            | Simple two-node tree       |\n| 8         | [1,null,2]          | [1,null,2]            | One node on right          |\n| 9         | [1,2,3,null,4]      | [1,null,2,null,3,null,4] | Imbalanced tree            |\n| 10        | [1,2,5,3,null,4,6]  | [1,null,2,null,3,null,4,null,5,null,6] | Mixed structure            |\n| 11        | []                  | []                    | Empty tree                 |\n| 12        | [1,2,3,null,null,4,5] | [1,null,2,null,3,null,4,null,5] | Alternating children      |\n| 13        | [1,null,null]       | [1]                   | Only root, both null       |\n| 14        | [5,3,6,2,null,null,7] | [5,null,3,null,2,null,6,null,7] | Value-based case           |\n| 15        | [10,5,null,2,7]     | [10,null,5,null,2,null,7] | BST-like tree              |\n| 16        | [1,2,3,4,null,null,5] | [1,null,2,null,4,null,3,null,5] | Complex left-right         |\n| 17        | [1,2,3,4,5,6,7]     | [1,null,2,null,4,null,5,null,3,null,6,null,7] | Complete binary tree |\n| 18        | [1,2,3,null,null,4,null,5] | [1,null,2,null,3,null,4,null,5] | Sparse tree               |\n| 19        | [1,2,null,3,4,5,null] | [1,null,2,null,3,null,4,null,5] | Irregular left-heavy      |\n| 20        | [1,null,2,3,null,null,4] | [1,null,2,null,3,null,4] | Irregular right-heavy     |\n| 21        | [1,2,3,4,null,null,null,null,5] | [1,null,2,null,4,null,5,null,3] | Deep left path        |\n| 22        | [1,2,3,4,5,6,7,8,9,10] | [1,null,2,null,4,null,8,null,9,null,5,null,10,null,3,null,6,null,7] | Wide and deep tree |\n| 23        | [2,1,3]             | [2,null,1,null,3]     | Small BST                  |\n| 24        | [1,2,null,null,3,null,4] | [1,null,2,null,3,null,4] | Right chain through left  |\n| 25        | [1,2,3,4,5,null,null,null,null,6] | [1,null,2,null,4,null,5,null,6,null,3] | Right at end  |\n| 26        | [1,null,2,3,4,null,null,5] | [1,null,2,null,3,null,4,null,5] | Deep right with left      |\n| 27        | [1,2,null,3,null,4] | [1,null,2,null,3,null,4] | Staggered left            |\n| 28        | [1,null,2,null,3,null,4,null,5] | [1,null,2,null,3,null,4,null,5] | Fully right skewed        |\n| 29        | [1,2,3,4,5,6,7,8,null,null,null,null,null,null,9] | [1,null,2,null,4,null,8,null,3,null,5,null,6,null,7,null,9] | Deep leaf     |\n| 30        | [3,2,4,1]           | [3,null,2,null,1,null,4] | Reverse-order nodes        |\n| 31        | [7,3,9,2,5,null,10] | [7,null,3,null,2,null,5,null,9,null,10] | Complex BST            |\n| 32        | [1,2,null,3,null,4,null,5] | [1,null,2,null,3,null,4,null,5] | Deep left-line            |\n| 33        | [1,null,2,3,null,4,null,5] | [1,null,2,null,3,null,4,null,5] | Deep right-line           |\n| 34        | [1,2,3,null,null,4,null,5,null,null,null,null,null,null,6] | [1,null,2,null,3,null,4,null,5,null,6] | Deep nest  |\n| 35        | [8,3,10,1,6,null,14,null,null,4,7,13] | [8,null,3,null,1,null,6,null,4,null,7,null,10,null,14,null,13] | Large tree  |\n| 36        | [1,2,3,null,4,5,null,null,null,6] | [1,null,2,null,4,null,6,null,3,null,5] | Irregular shape           |\n| 37        | [1,null,2,null,3,null,4,null,5,null,6,null,7] | [1,null,2,null,3,null,4,null,5,null,6,null,7] | Right-heavy chain |\n| 38        | [1,2,3,4,null,null,5,null,null,null,null,null,null,null,6] | [1,null,2,null,4,null,3,null,5,null,6] | Bottom-right leaf         |\n| 39        | [1,2,3,4,5,null,null,null,null,null,null,null,null,null,6,7] | [1,null,2,null,4,null,5,null,6,null,7,null,3] | Edge leafs       |\n| 40        | [1,2,3,null,4,null,5,null,null,null,null,null,null,null,null,6] | [1,null,2,null,4,null,6,null,3,null,5] | Very deep irregular tree |",
        "example": {
          "input": "[1,2,5,3,4,null,6]",
          "output": "[1,null,2,null,3,null,4,null,5,null,6]",
          "explanation": "The tree is flattened into a right-skewed linked list, where each node's right pointer points to the next node in preorder."
        },
        "answer": "def flatten(root):\n    if not root: return\n    flatten(root.left)\n    flatten(root.right)\n    if root.left:\n        temp = root.right\n        root.right = root.left\n        root.left = None\n        curr = root.right\n        while curr.right:\n            curr = curr.right\n        curr.right = temp"
      },      
      {
        "id": 24,
        "title": "Find Bottom Left Tree Value",
        "description": "Find the leftmost value in the last row.\n\n| Test Case | Input       | Output | Notes       |\n|-----------|-------------|--------|-------------|\n| 1         | [2,1,3]     | 1      | Simple tree |\n| 2         | [1,2,3,4,5] | 4      | Skewed tree |\n| 3         | [1,2,3]     | 2      | Simple tree |\n| 4         | [1,2,null,4] | 4      | Left child on last row |\n| 5         | [1,2,3,4,5] | 4      | Complete tree |\n| 6         | [1,2,3,4,5,6] | 4    | Right-heavy tree |\n| 7         | [2,1,3,5,6] | 5      | Deep left tree |\n| 8         | [1,2,null,3,4] | 4    | Skewed right tree |\n| 9         | [1,2,3,4,5,6] | 6    | Balanced tree |\n| 10        | [1,2,3,4,5,6,7] | 4    | Full binary tree |\n| 11        | [0] | 0 | Single node |\n| 12        | [1,null,2,null,3,null,4] | 4 | Skewed to right |\n| 13        | [1,2,null,3,null,4] | 4 | Skewed to left |\n| 14        | [5,4,6,3,null,null,7] | 3 | Unbalanced left |\n| 15        | [5,6,4,null,7,null,3] | 7 | Unbalanced right |\n| 16        | [1,2,3,null,null,null,4,5] | 5 | Deep left-most |\n| 17        | [1,2,3,null,4,5,6] | 4 | Mid-depth left |\n| 18        | [3,9,20,null,null,15,7] | 15 | Leetcode style tree |\n| 19        | [1,2,3,null,4,null,null,null,null,5] | 5 | Deepest left |\n| 20        | [1,2,3,4,5,6,7,8,9] | 8 | Complete tree deeper |\n| 21        | [1,2,3,null,null,4,5,null,null,null,null,6] | 6 | Sparse right bottom |\n| 22        | [1,null,2,null,3,null,4,null,5] | 5 | Right skew |\n| 23        | [1,2,null,3,null,4,null,5] | 5 | Left skew |\n| 24        | [1,2,3,null,null,4,5,null,null,6] | 6 | Bottommost right |\n| 25        | [1,2,null,3,null,4,null,5,null,6] | 6 | Deep skew left |\n| 26        | [1,null,2,null,3,null,4,null,5,null,6] | 6 | Deep skew right |\n| 27        | [1,2,3,null,null,4,null,null,5] | 5 | Bottommost on left |\n| 28        | [1,2,3,4,null,5,6,null,null,7,null] | 7 | Jagged bottom |\n| 29        | [1,2,3,4,5,null,null,null,null,6] | 6 | Zigzag shape |\n| 30        | [1,2,3,null,4,null,5,null,6] | 6 | Unbalanced deep left |\n| 31        | [10,20,30,40,null,null,50,null,null,null,60] | 60 | Deepest right child |\n| 32        | [3,null,4,null,5,null,6] | 6 | Only right children |\n| 33        | [7,6,null,5,null,4,null,3] | 3 | Descending left chain |\n| 34        | [1,2,3,4,5,null,null,null,null,6] | 6 | Left-heavy middle depth |\n| 35        | [8,null,9,10,null,11] | 11 | Right-skew with bottom value |\n| 36        | [1,2,3,4,5,6,7,8,null,null,null,null,null,null,9] | 8 | Bottom left edge |\n| 37        | [1,2,null,null,3,4] | 4 | Lopsided structure |\n| 38        | [1,null,2,3,null,null,4] | 4 | Deeper right branch |\n| 39        | [1,null,2,null,3,null,4,null,5,null,6,null,7] | 7 | Deep skew right |\n| 40        | [1,2,3,4,null,null,null,5,null,null,null,6] | 6 | Mixed deep structure |",
        "example": {
          "input": "[2,1,3]",
          "output": "1",
          "explanation": "The leftmost value of the last row of the tree is 1."
        },
        "answer": "def findBottomLeftValue(root):\n    queue = [root]\n    while queue:\n        root = queue.pop(0)\n        if root.right: queue.append(root.right)\n        if root.left: queue.append(root.left)\n    return root.val"
      },      
      {
        "id": 25,
        "title": "Populating Next Right Pointers in Each Node",
        "description": "| Test Case | Input | Output | Notes |\n|-----------|-------|--------|-------|\n| 1 | [1] | modified tree with next pointers | Generated test case 1 |\n| 2 | [1,2] | modified tree with next pointers | Generated test case 2 |\n| 3 | [1,2,3] | modified tree with next pointers | Generated test case 3 |\n| 4 | [1,2,3,4] | modified tree with next pointers | Generated test case 4 |\n| 5 | [1,2,3,4,5] | modified tree with next pointers | Generated test case 5 |\n| 6 | [1,2,3,4,5,6] | modified tree with next pointers | Generated test case 6 |\n| 7 | [1,2,3,4,5,6,7] | modified tree with next pointers | Generated test case 7 |\n| 8 | [1,2,3,4,5,6,7,8] | modified tree with next pointers | Generated test case 8 |\n| 9 | [1,2,3,4,5,6,7,8,9] | modified tree with next pointers | Generated test case 9 |\n| 10 | [1,2,3,null,4,5,6] | modified tree with next pointers | Generated test case 10 |\n| 11 | [1,2,null,3,4] | modified tree with next pointers | Generated test case 11 |\n| 12 | [1,null,2,null,3] | modified tree with next pointers | Generated test case 12 |\n| 13 | [1,2,null,3,null,4] | modified tree with next pointers | Generated test case 13 |\n| 14 | [1,2,3,4,null,null,5] | modified tree with next pointers | Generated test case 14 |\n| 15 | [1,null,null] | modified tree with next pointers | Generated test case 15 |\n| 16 | [1,2,3,null,null,4,5] | modified tree with next pointers | Generated test case 16 |\n| 17 | [1,2,3,null,4,5,6] | modified tree with next pointers | Generated test case 17 |\n| 18 | [1,2,3,4,null,5,6] | modified tree with next pointers | Generated test case 18 |\n| 19 | [1,2,null,3,4,5] | modified tree with next pointers | Generated test case 19 |\n| 20 | [1,2,3,4,5,6,7,8,9,10] | modified tree with next pointers | Generated test case 20 |\n| 21 | [1,2,3,4,5,6,7,8,null,null,9] | modified tree with next pointers | Generated test case 21 |\n| 22 | [1,2,null,null,3,null,null,4] | modified tree with next pointers | Generated test case 22 |\n| 23 | [1,2,3,null,null,null,4,null,null,null,5] | modified tree with next pointers | Generated test case 23 |\n| 24 | [1,2,3,null,null,null,null,4] | modified tree with next pointers | Generated test case 24 |\n| 25 | [1,null,null,null,2] | modified tree with next pointers | Generated test case 25 |\n| 26 | [1,2,3,4,5,null,null,null,null,6] | modified tree with next pointers | Generated test case 26 |\n| 27 | [1,2,3,4,5,6,7,null,null,null,null,8] | modified tree with next pointers | Generated test case 27 |\n| 28 | [1,2,3,null,4,null,null,null,null,5] | modified tree with next pointers | Generated test case 28 |\n| 29 | [1,2,3,null,null,null,null,null,4,null,null,5] | modified tree with next pointers | Generated test case 29 |\n| 30 | [1,2,null,3,null,null,4,null,null,null,5] | modified tree with next pointers | Generated test case 30 |\n| 31 | [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] | modified tree with next pointers | Generated test case 31 |\n| 32 | [1,2,3,4,5,null,null,null,null,6,7,null,null,8,9] | modified tree with next pointers | Generated test case 32 |\n| 33 | [1,null,2,null,3,null,4,null,5] | modified tree with next pointers | Generated test case 33 |\n| 34 | [1,2,3,4,null,5,null,null,null,6,7] | modified tree with next pointers | Generated test case 34 |\n| 35 | [1,2,null,3,4,null,null,5] | modified tree with next pointers | Generated test case 35 |\n| 36 | [1,null,2,3,null,null,4,null,null,null,5] | modified tree with next pointers | Generated test case 36 |\n| 37 | [1,2,3,null,null,4,null,null,null,null,5] | modified tree with next pointers | Generated test case 37 |\n| 38 | [1,2,null,null,3,null,null,null,4] | modified tree with next pointers | Generated test case 38 |\n| 39 | [1,2,3,4,5,6,7,null,null,null,null,null,null,null,8] | modified tree with next pointers | Generated test case 39 |",
        "example": {
          "input": "[1,2,3,4,5,6,7]",
          "output": "[1,null,2,null,3,null,4,null,5,null,6,null,7]",
          "explanation": "Each node's next pointer is populated with the node on the right of the same level."
        },
        "answer": "def connect(root):\n    if not root: return None\n    leftmost = root\n    while leftmost.left:\n        head = leftmost\n        while head:\n            head.left.next = head.right\n            if head.next:\n                head.right.next = head.next.left\n            head = head.next\n        leftmost = leftmost.left\n    return root"
      },      
      {
        "id": 26,
        "title": "Search in a BST",
        "description": "Search for a node with a given value.\n\n| Test Case | Input                     | Output               | Notes                          |\n|-----------|---------------------------|------------------------|-------------------------------|\n| 11        | [5,3,6,2,4], val=4        | Node with value 4     | Leaf node in left subtree     |\n| 12        | [5,3,6,2,4], val=6        | Node with value 6     | Right child                   |\n| 13        | [8,3,10,1,6,null,14], val=6 | Node with value 6   | Right-left grandchild         |\n| 14        | [8,3,10,1,6,null,14], val=14 | Node with value 14 | Rightmost leaf                |\n| 15        | [8,3,10,1,6,null,14], val=5 | None                 | Non-existent node             |\n| 16        | [4,2,6,1,3,5,7], val=5     | Node with value 5     | Deep node in balanced tree    |\n| 17        | [4,2,6,1,3,5,7], val=8     | None                  | Value not in tree             |\n| 18        | [50], val=50              | Node with value 50    | Single-node tree              |\n| 19        | [50], val=10              | None                  | Single-node, not found        |\n| 20        | [20,10,30,5,15,25,35], val=35 | Node with value 35 | Deep right leaf               |\n| 21        | [20,10,30,5,15,25,35], val=15 | Node with value 15 | Middle of left subtree        |\n| 22        | [5,3,7,2,4,6,8], val=2     | Node with value 2     | Deep left                     |\n| 23        | [5,3,7,2,4,6,8], val=6     | Node with value 6     | Deep right                    |\n| 24        | [5,3,7,2,4,6,8], val=9     | None                  | Rightmost not found           |\n| 25        | [3,1,4,null,2], val=2      | Node with value 2     | Sparse left-heavy tree        |\n| 26        | [3,1,4,null,2], val=5      | None                  | Value missing in sparse tree  |\n| 27        | [100,50,150,25,75,125,175], val=125 | Node with value 125 | Multi-level balanced     |\n| 28        | [100,50,150,25,75,125,175], val=101 | None              | Near match                   |\n| 29        | [10,5,15,null,null,12,18], val=18 | Node with value 18 | Deepest right                |\n| 30        | [10,5,15,null,null,12,18], val=11 | None              | Missing in complete structure |\n| 31        | [10,5,null,3,7], val=7     | Node with value 7     | Right grandchild              |\n| 32        | [10,5,null,3,7], val=8     | None                  | Close value not present       |\n| 33        | [15,10,20,5,null,null,25], val=25 | Node with value 25 | Skewed to right              |\n| 34        | [15,10,20,5,null,null,25], val=6 | None               | Not found in sparse tree      |\n| 35        | [6,4,8,2,5,7,9], val=9     | Node with value 9     | Leaf node                     |\n| 36        | [6,4,8,2,5,7,9], val=0     | None                  | Below min                     |\n| 37        | [6,4,8,2,5,7,9], val=10    | None                  | Above max                     |\n| 38        | [6,4,8,2,5,7,9], val=8     | Node with value 8     | Right subtree root            |\n| 39        | [3,null,5,null,7], val=7   | Node with value 7     | Right skewed                  |\n| 40        | [3,null,5,null,7], val=4   | None                  | Not found in skewed right     |",
        "example": {
          "input": "[4,2,7,1,3], val=2",
          "output": "Node with value 2",
          "explanation": "The node with value 2 is found in the left subtree of the root node."
        },
        "answer": "def searchBST(root, val):\n    if not root or root.val == val:\n        return root\n    if val < root.val:\n        return searchBST(root.left, val)\n    return searchBST(root.right, val)"
      },
      {
        "id": 27,
        "title": "Insert into BST",
        "description": "Insert a value and return the root.\n\n| Test Case | Input                | Output                | Notes                         |\n|-----------|----------------------|------------------------|-------------------------------|\n| 1         | [4,2,7,1,3], val=5    | [4,2,7,1,3,5]          | Insert in right subtree       |\n| 2         | [4,2,7,1,3], val=0    | [4,2,7,1,3,0]           | Insert in left leaf           |\n| 3         | [1,2,3,4,5], val=6    | [1,2,3,4,5,6]          | Insert in right leaf         |\n| 4         | [5,3,6,2,4], val=3    | [5,3,6,2,4]            | Duplicate value               |\n| 5         | [5,3,6,2,4], val=0    | [5,3,6,2,4,0]          | Insert at the extreme left    |\n| 6         | [5,3,6,2,4], val=7    | [5,3,6,2,4,7]          | Insert at the extreme right   |\n| 7         | [5,3,6,2,4], val=8    | [5,3,6,2,4,8]          | Insert at the far right       |\n| 8         | [10,5,15], val=12     | [10,5,15,12]           | Insert between 10 and 15      |\n| 9         | [4,2,7,1,3], val=4    | [4,2,7,1,3]            | No change in tree             |\n| 10        | [1,2,3,4], val=5      | [1,2,3,4,5]            | Insert at rightmost leaf      |\n| 11        | [50], val=25          | [50,25]                | Inserting as left child       |\n| 12        | [50], val=75          | [50,75]                | Inserting as right child      |\n| 13        | [4,2,7,1,3], val=6    | [4,2,7,1,3,6]          | Insert between 7 and root     |\n| 14        | [8,3,10,1,6,null,14], val=7 | [8,3,10,1,6,7,null,14] | Insert as leaf node          |\n| 15        | [8,3,10,1,6,null,14], val=5 | [8,3,10,1,6,5,null,14] | Insert to left of 6          |\n| 16        | [5,3,6,2,4,null,7], val=8 | [5,3,6,2,4,null,7,8]    | Insert as far-right leaf      |\n| 17        | [4,2,7,1,3], val=2    | [4,2,7,1,3]            | Duplicate value               |\n| 18        | [5,3,6,2,4], val=5    | [5,3,6,2,4]            | No change                     |\n| 19        | [3,1,4], val=2        | [3,1,4,2]              | Insert as left leaf           |\n| 20        | [2,1,3], val=2        | [2,1,3]                | No change                     |\n| 21        | [5,3,6,2,4], val=1    | [5,3,6,2,4,1]          | Insert as leftmost leaf       |\n| 22        | [3,2,7], val=5        | [3,2,7,5]              | Insert as right child         |\n| 23        | [3,2,7], val=8        | [3,2,7,8]              | Insert as far-right leaf      |\n| 24        | [10,5,15], val=8      | [10,5,15,8]            | Insert as left child          |\n| 25        | [50,25], val=30       | [50,25,30]             | Insert between 25 and 50      |\n| 26        | [50,25], val=20       | [50,25,20]             | Insert as left child of 25    |\n| 27        | [5,3,6,2,4], val=6    | [5,3,6,2,4]            | Duplicate value               |\n| 28        | [50], val=10          | [50,10]                | Insert as left child          |\n| 29        | [5,3,6,2,4], val=9    | [5,3,6,2,4,9]          | Insert as right child         |\n| 30        | [10,5,15], val=13     | [10,5,15,13]           | Insert between 10 and 15      |\n| 31        | [4,2,7,1,3], val=3    | [4,2,7,1,3]            | No change                     |\n| 32        | [4,2,7,1,3], val=0    | [4,2,7,1,3,0]          | Insert as left leaf           |\n| 33        | [4,2,7,1,3], val=8    | [4,2,7,1,3,8]          | Insert as rightmost leaf      |\n| 34        | [4,2,7,1,3], val=5    | [4,2,7,1,3,5]          | Insert between 4 and 7        |\n| 35        | [3,1,4,null,2], val=0  | [3,1,4,null,2,0]        | Insert at leftmost leaf       |\n| 36        | [1,2,3,4], val=5      | [1,2,3,4,5]            | Insert at far-right leaf      |\n| 37        | [3,2,7], val=4        | [3,2,7,4]              | Insert between 3 and 7        |\n| 38        | [3,2,7], val=6        | [3,2,7,6]              | Insert as left child of 7     |\n| 39        | [3,2,7], val=5        | [3,2,7,5]              | Insert as right child of 2    |\n| 40        | [4,2,7,1,3], val=5    | [4,2,7,1,3,5]          | Insert between 4 and 7        |",
        "example": {
          "input": "[4,2,7,1,3], val=5",
          "output": "[4,2,7,1,3,5]",
          "explanation": "The node with value 5 is inserted as a right child of node 3."
        },
        "answer": "def insertIntoBST(root, val):\n    if not root:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root"
      },
      {
        "id": 28,
        "title": "Delete Node in BST",
        "description": "Delete a node and rearrange BST.\n\n| Test Case | Input                           | Output                          | Notes                        |\n|-----------|---------------------------------|--------------------------------|------------------------------|\n| 1         | [5,3,6,2,4,null,7], key=3       | [5,4,6,2,null,null,7]          | Delete node with two children |\n| 2         | [5,3,6,2,4,null,7], key=6       | [5,4,7,2,null,null]            | Delete node with right child  |\n| 3         | [5,3,6,2,4,null,7], key=2       | [5,3,6,null,4,null,7]          | Delete node with left child   |\n| 4         | [5,3,6,2,4,null,7], key=7       | [5,3,6,2,4,null]               | Delete leaf node              |\n| 5         | [5,3,6,2,4,null,7], key=5       | [4,3,6,2,4,null,7]             | Delete root node              |\n| 6         | [3,1,4], key=4                  | [3,1]                          | Delete node with one child    |\n| 7         | [4,2,6,1,3], key=3              | [4,2,6,1]                      | Delete node with one child    |\n| 8         | [5,3,6,2,4], key=0              | [5,3,6,2,4]                    | Delete non-existing node      |\n| 9         | [50,25,75], key=25              | [50,75]                        | Delete leaf node              |\n| 10        | [50,25,75], key=50              | [25,75]                        | Delete root node              |\n| 11        | [4,2,7,1,3], key=7             | [4,2,1,3]                      | Delete node with no right child |\n| 12        | [5,3,6,2,4], key=4             | [5,3,6,2]                      | Delete node with one child    |\n| 13        | [5,3,6,2,4,null,7], key=7      | [5,3,6,2,4]                    | Delete leaf node              |\n| 14        | [8,3,10,1,6,null,14], key=10    | [8,3,14,1,6]                   | Delete node with two children |\n| 15        | [8,3,10,1,6,null,14], key=3     | [8,4,10,1,6,null,14]           | Delete node with left child   |\n| 16        | [3,2,7,1,6,8,10], key=6        | [3,2,7,1,8,10]                 | Delete node with right child  |\n| 17        | [5,3,6,2,4], key=5             | [3,4,6,2]                      | Delete root node with two children |\n| 18        | [4,2,7,1,3], key=1             | [4,2,7,3]                      | Delete leaf node              |\n| 19        | [5,3,6,2,4,null,7], key=4      | [5,3,6,2,null,null,7]          | Delete middle node            |\n| 20        | [3,1,4,null,2], key=4          | [3,1,2]                        | Delete node with one child    |\n| 21        | [3,2,5], key=2                 | [3,5]                          | Delete node with left child   |\n| 22        | [1,2,3,4], key=4               | [1,2,3]                        | Delete leaf node              |\n| 23        | [1,2,3,4], key=3               | [1,2,4]                        | Delete node with right child  |\n| 24        | [1,2,3,4], key=1               | [2,3,4]                        | Delete root node              |\n| 25        | [5,3,7,1,4], key=4             | [5,3,7,1]                      | Delete node with one child    |\n| 26        | [10,5,20,15,25], key=15        | [10,5,20,25]                   | Delete node with right child  |\n| 27        | [10,5,20,15,25], key=20        | [10,5,25]                      | Delete node with right child  |\n| 28        | [5,3,6,2,4], key=5            | [4,3,6,2]                      | Delete root node with one child |\n| 29        | [4,3,7,1,5], key=7            | [4,3,1,5]                      | Delete leaf node              |\n| 30        | [5,3,6,2,4,null,7], key=7     | [5,3,6,2,4]                    | Delete node with no children  |",
        "example": {
          "input": "[5,3,6,2,4,null,7], key=3",
          "output": "[5,4,6,2,null,null,7]",
          "explanation": "The node with value 3 is deleted, and the left child with value 4 is promoted."
        },
        "answer": "def deleteNode(root, key):\n    if not root:\n        return root\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if not root.left:\n            return root.right\n        elif not root.right:\n            return root.left\n        min_node = self._minNode(root.right)\n        root.val = min_node.val\n        root.right = deleteNode(root.right, min_node.val)\n    return root\n\ndef _minNode(self, root):\n    while root.left:\n        root = root.left\n    return root"
      },
      {
        "id": 29,
        "title": "Validate BST",
        "description": "Check if a tree is a valid BST.\n\n| Test Case | Input                           | Output      |\n|-----------|---------------------------------|-------------|\n| 1         | [2,1,3]                         | True        |\n| 2         | [5,1,4,null,null,3,6]           | False       |\n| 3         | [10,5,15,1,8]                   | False       |\n| 4         | [7,3,10,2,5,8,12]               | True        |\n| 5         | [3,1,4,null,null,2]              | False       |\n| 6         | [1,0,2]                         | True        |\n| 7         | [1,2]                           | False       |\n| 8         | [3,1,4,null,5,6]                 | True        |\n| 9         | [2,1,3,4]                       | False       |\n| 10        | [5,3,6,2,4,null,7]               | True        |\n| 11        | [3,1,5,0,2]                     | False       |\n| 12        | [8,4,12,2,6,10,14]              | True        |\n| 13        | [6,5,7,3,4,2,8]                 | True        |\n| 14        | [5,3,7,1,6,8,4,2]               | False       |\n| 15        | [6,3,9,1,5,7,11]                | True        |\n| 16        | [2,1,3,4]                       | False       |\n| 17        | [9,3,15,7,10,20]                | False       |\n| 18        | [10,5,8,2,4,6,7]                | True        |\n| 19        | [4,2,6,1,3,5,7]                 | True        |\n| 20        | [7,4,9,1,3,6,8,5,2]             | True        |\n| 21        | [8,5,3,1,4,7]                   | False       |\n| 22        | [5,3,8,1,4,7,9]                 | True        |\n| 23        | [3,1,2]                         | True        |\n| 24        | [9,5,12,2,6,10,14]              | True        |\n| 25        | [1,2,3,4]                       | False       |\n| 26        | [3,1,2]                         | True        |\n| 27        | [5,4,7,1,3,6]                   | True        |\n| 28        | [3,2,7,1,6,8,10]                | True        |\n| 29        | [4,2,6,1,5,3]                   | False       |\n| 30        | [5,6,7,3,4,1,2]                 | False       |\n| 31        | [3,5,4,7]                       | False       |\n| 32        | [8,5,7,3,1,6]                   | True        |\n| 33        | [10,9,8,7,6,5,4]                | False       |\n| 34        | [7,3,8,1,5,6,9]                 | True        |\n| 35        | [1,3,5,2,4]                     | False       |\n| 36        | [4,2,5,3,1]                     | True        |\n| 37        | [10,7,9,5,8,3,2]                | False       |\n| 38        | [5,2,8,1,4]                     | False       |\n| 39        | [8,5,12,3,9,4,6]                | True        |",
        "example": {
          "input": "[2,1,3]",
          "output": "True",
          "explanation": "The tree is a valid BST as it follows the rules of BST."
        },
        "answer": "def isValidBST(root):\n    def helper(node, lower=float('-inf'), upper=float('inf')):\n        if not node: return True\n        if node.val <= lower or node.val >= upper:\n            return False\n        return (helper(node.left, lower, node.val) and\n                helper(node.right, node.val, upper))\n    return helper(root)"
      },
      
      {
        "id": 30,
        "title": "Lowest Common Ancestor in BST",
        "description": "Find LCA of two nodes in BST.\n\n| Test Case | Input                                  | Output | Notes                        |\n|-----------|----------------------------------------|--------|------------------------------|\n| 1         | [6,2,8,0,4,7,9,null,null,3,5], p=2, q=8 | 6      | LCA is the root              |\n| 2         | [6,2,8,0,4,7,9,null,null,3,5], p=2, q=4 | 2      | LCA is node 2                |\n| 3         | [6,2,8,0,4,7,9,null,null,3,5], p=2, q=5 | 2      | LCA is node 2                |\n| 4         | [3,2,7,1,6,8,10], p=6, q=8           | 7      | LCA is node 7                |\n| 5         | [6,2,8,0,4,7,9,null,null,3,5], p=3, q=5 | 4      | LCA is node 4                |\n| 6         | [5,3,6,2,4,null,7], p=2, q=7          | 5      | LCA is node 5                |\n| 7         | [3,2,7,1,6,8,10], p=1, q=10          | 7      | LCA is node 7                |\n| 8         | [6,2,8,0,4,7,9,null,null,3,5], p=3, q=7 | 6      | LCA is root 6                |\n| 9         | [6,2,8,0,4,7,9,null,null,3,5], p=1, q=9 | 6      | LCA is root 6                |\n| 10        | [4,2,7,1,3], p=1, q=3               | 2      | LCA is node 2                |\n| 11        | [8,3,10,1,6,null,14], p=3, q=10      | 8      | LCA is node 8                |\n| 12        | [8,3,10,1,6,null,14], p=1, q=14      | 8      | LCA is node 8                |\n| 13        | [6,2,8,0,4,7,9,null,null,3,5], p=4, q=9 | 6      | LCA is node 6                |\n| 14        | [6,2,8,0,4,7,9,null,null,3,5], p=0, q=5 | 5      | LCA is node 5                |\n| 15        | [5,3,6,2,4,null,7], p=6, q=7         | 6      | LCA is node 6                |\n| 16        | [5,3,6,2,4,null,7], p=3, q=2         | 2      | LCA is node 2                |\n| 17        | [6,2,8,0,4,7,9,null,null,3,5], p=4, q=7 | 6      | LCA is node 6                |\n| 18        | [6,2,8,0,4,7,9,null,null,3,5], p=3, q=6 | 6      | LCA is node 6                |\n| 19        | [8,3,10,1,6,null,14], p=1, q=6       | 6      | LCA is node 6                |\n| 20        | [5,3,6,2,4,null,7], p=4, q=7         | 7      | LCA is node 7                |\n| 21        | [3,2,7,1,6,8,10], p=2, q=6          | 7      | LCA is node 7                |\n| 22        | [6,2,8,0,4,7,9,null,null,3,5], p=2, q=0 | 2      | LCA is node 2                |\n| 23        | [8,3,10,1,6,null,14], p=3, q=6       | 3      | LCA is node 3                |\n| 24        | [5,3,6,2,4,null,7], p=7, q=6         | 6      | LCA is node 6                |\n| 25        | [6,2,8,0,4,7,9,null,null,3,5], p=3, q=3 | 3      | LCA is node 3                |\n| 26        | [5,3,6,2,4,null,7], p=2, q=4         | 4      | LCA is node 4                |\n| 27        | [6,2,8,0,4,7,9,null,null,3,5], p=8, q=9 | 8      | LCA is node 8                |\n| 28        | [6,2,8,0,4,7,9,null,null,3,5], p=0, q=3 | 3      | LCA is node 3                |\n| 29        | [3,2,7,1,6,8,10], p=8, q=1         | 7      | LCA is node 7                |\n| 30        | [6,2,8,0,4,7,9,null,null,3,5], p=9, q=4 | 4      | LCA is node 4                |",
        "example": {
          "input": "[6,2,8,0,4,7,9,null,null,3,5], p=2, q=8",
          "output": "6",
          "explanation": "The lowest common ancestor of nodes 2 and 8 is node 6, which is the root of the tree."
        },
        "answer": "def lowestCommonAncestor(root, p, q):\n    if p.val < root.val and q.val < root.val:\n        return lowestCommonAncestor(root.left, p, q)\n    if p.val > root.val and q.val > root.val:\n        return lowestCommonAncestor(root.right, p, q)\n    return root"
      },
      {
        "id": 31,
        "title": "Kth Smallest Element in BST",
        "description": "Find kth smallest node.\n\n| Test Case | Input                            | Output   |\n|-----------|----------------------------------|----------|\n| 1         | [3,1,4,null,2], k=1             | 1        |\n| 2         | [5,3,6,2,4,null,7], k=2         | 3        |\n| 3         | [5,3,6,2,4,null,7], k=3         | 4        |\n| 4         | [5,3,6,2,4,null,7], k=4         | 5        |\n| 5         | [1,2], k=1                      | 1        |\n| 6         | [1,2,3], k=2                    | 2        |\n| 7         | [3,1,4,null,2], k=2             | 2        |\n| 8         | [5,3,6,2,4,null,7], k=5         | 6        |\n| 9         | [1], k=1                        | 1        |\n| 10        | [2,1], k=1                      | 1        |\n| 11        | [2,1], k=2                      | 2        |\n| 12        | [7,3,9,2,4,8,10], k=4          | 4        |\n| 13        | [7,3,9,2,4,8,10], k=5          | 7        |\n| 14        | [7,3,9,2,4,8,10], k=6          | 8        |\n| 15        | [7,3,9,2,4,8,10], k=7          | 9        |\n| 16        | [7,3,9,2,4,8,10], k=8          | 10       |\n| 17        | [10,5,15,3,7,12], k=3          | 5        |\n| 18        | [10,5,15,3,7,12], k=2          | 3        |\n| 19        | [10,5,15,3,7,12], k=5          | 7        |\n| 20        | [10,5,15,3,7,12], k=4          | 5        |\n| 21        | [10,5,15,3,7,12], k=6          | 10       |\n| 22        | [10,5,15,3,7,12], k=1          | 3        |\n| 23        | [1,2,3,4,5,6,7,8,9], k=5       | 5        |\n| 24        | [1,2,3,4,5,6,7,8,9], k=7       | 7        |\n| 25        | [1,2,3,4,5,6,7,8,9], k=8       | 8        |\n| 26        | [1,2,3,4,5,6,7,8,9], k=3       | 3        |\n| 27        | [1,2,3,4,5,6,7,8,9], k=2       | 2        |\n| 28        | [10,5,15,3,7,12], k=1          | 3        |\n| 29        | [4,2,7,1,5], k=4               | 4        |\n| 30        | [4,2,7,1,5], k=5               | 7        |\n| 31        | [4,2,7,1,5], k=3               | 2        |\n| 32        | [4,2,7,1,5], k=2               | 1        |\n| 33        | [1,2,3], k=3                   | 3        |\n| 34        | [1,3,5,2,4,6], k=3             | 3        |\n| 35        | [3,1,4,null,2], k=3            | 3        |\n| 36        | [3,1,4,null,2], k=4            | 4        |\n| 37        | [3,1,4,null,2], k=2            | 2        |\n| 38        | [3,1,4,null,2], k=1            | 1        |\n| 39        | [2,1,3], k=2                   | 2        |\n| 40        | [3,1,4,null,2], k=1            | 1        |",
        "example": {
          "input": "[3,1,4,null,2], k=1",
          "output": "1",
          "explanation": "The 1st smallest element in the BST is 1."
        },
        "answer": "def kthSmallest(root, k):\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            return root.val\n        root = root.right"
      },
      {
        "id": 32,
        "title": "BST to Greater Sum Tree",
        "description": "Transform BST node's value to sum of greater values.\n\n| Test Case | Input                                                           | Output         |\n|-----------|-----------------------------------------------------------------|----------------|\n| 1         | [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]                | [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]    |\n| 2         | [10,5,15,3,7,12], k=1                                           | [42,42,42,42,42,42]           |\n| 3         | [5,3,7,1,4], k=2                                                 | [15,15,14,15,15]               |\n| 4         | [5,3,6,2,4,null,7], k=4                                          | [30,31,21,30,35]              |\n| 5         | [1,2,3,4,5,6,7], k=5                                            | [31,30,25,15,10,12,1]         |\n| 6         | [2,1,3], k=1                                                     | [5,4,3]                        |\n| 7         | [7,3,9,2,4,8,10], k=3                                            | [40,42,31,29,32,28]           |\n| 8         | [1,2,3,4,5,6,7,8,9], k=9                                        | [45,39,30,24,18,13,7]         |\n| 9         | [10,5,15,3,7,12], k=4                                            | [40,39,38,34,33,32]           |\n| 10        | [4,2,7,1,5], k=1                                                 | [10,9,7,4]                     |\n| 11        | [10,5,15,3,7,12], k=2                                            | [33,32,29,19,19,12]           |\n| 12        | [4,2,7,1,3], k=5                                                 | [30,32,21,15]                 |\n| 13        | [5,3,6,2,4,null,7], k=1                                          | [30,36,31,36,35]              |\n| 14        | [3,2,6,1,5], k=1                                                 | [30,30,30,30]                 |\n| 15        | [6,3,8,2,5], k=2                                                 | [29,30,30,30,30]              |\n| 16        | [10,5,15,3,7,12], k=3                                            | [25,25,29,30]                 |\n| 17        | [3,1,6,2,4], k=2                                                 | [15,15,21]                     |\n| 18        | [3,2,7,1,5], k=3                                                 | [31,30,32]                     |\n| 19        | [1,3,2,5,6,4], k=4                                               | [31,30,32]                     |\n| 20        | [5,3,8,4,6], k=3                                                 | [31,30,28]                     |\n| 21        | [6,3,8,1,5], k=1                                                 | [27,28]                        |\n| 22        | [10,5,15,3,7,12], k=5                                            | [41,39,30,25]                 |\n| 23        | [6,3,8,2,5], k=4                                                 | [31,29]                        |\n| 24        | [6,3,8,2,5], k=3                                                 | [30]                           |\n| 25        | [5,3,6,2,4,null,7], k=3                                          | [30]                           |\n| 26        | [5,2,7,1,4], k=2                                                 | [30]                           |\n| 27        | [10,2,7,1,3], k=3                                                 | [30]                           |\n| 28        | [6,5,9,4,7,2], k=2                                                 | [30]                           |\n| 29        | [1,2,3], k=3                                                     | [30]                           |\n| 30        | [1,3,2,5], k=2                                                     | [30]                           |",
        "example": {
          "input": "[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]",
          "output": "[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]",
          "explanation": "The tree is transformed such that each node's value is updated to the sum of all greater values."
        },
        "answer": "def bstToGst(root):\n    total = 0\n    def reverse_inorder(node):\n        nonlocal total\n        if not node: return\n        reverse_inorder(node.right)\n        total += node.val\n        node.val = total\n        reverse_inorder(node.left)\n    reverse_inorder(root)\n    return root"
      },
      {
        "id": 33,
        "title": "Two Sum IV - Input is a BST",
        "description": "Check if there exist two elements in BST such that their sum is equal to the given value.\n\n| Test Case | Input                                  | Output | Notes  |\n|-----------|----------------------------------------|--------|--------|\n| 1         | [5,3,6,2,4,null,7], k=9               | True   |        |\n| 2         | [5,3,6,2,4,null,7], k=5               | True   |        |\n| 3         | [5,3,6,2,4,null,7], k=12              | True   |        |\n| 4         | [5,3,6,2,4,null,7], k=14              | False  |        |\n| 5         | [7,3,9,2,4,8,10], k=8                | True   |        |\n| 6         | [7,3,9,2,4,8,10], k=11               | True   |        |\n| 7         | [7,3,9,2,4,8,10], k=17               | True   |        |\n| 8         | [10,5,15,3,7,12], k=20               | False  |        |\n| 9         | [7,3,9,2,4,8,10], k=16               | False  |        |\n| 10        | [10,5,15,3,7,12], k=18               | True   |        |\n| 11        | [3,1,4,null,2], k=5                  | True   |        |\n| 12        | [3,1,4,null,2], k=6                  | False  |        |\n| 13        | [5,3,6,2,4,null,7], k=8              | True   |        |\n| 14        | [3,1,4,null,2], k=3                  | True   |        |\n| 15        | [3,1,4,null,2], k=4                  | False  |        |\n| 16        | [7,3,9,2,4,8,10], k=15              | True   |        |\n| 17        | [10,5,15,3,7,12], k=6               | False  |        |\n| 18        | [10,5,15,3,7,12], k=7               | True   |        |\n| 19        | [7,3,9,2,4,8,10], k=6               | True   |        |\n| 20        | [7,3,9,2,4,8,10], k=9               | False  |        |\n| 21        | [10,5,15,3,7,12], k=4               | False  |        |\n| 22        | [3,1,4,null,2], k=2                  | True   |        |\n| 23        | [3,1,4,null,2], k=1                  | True   |        |\n| 24        | [7,3,9,2,4,8,10], k=12              | False  |        |\n| 25        | [7,3,9,2,4,8,10], k=20              | False  |        |\n| 26        | [10,5,15,3,7,12], k=21              | False  |        |\n| 27        | [5,3,6,2,4,null,7], k=7             | True   |        |\n| 28        | [5,3,6,2,4,null,7], k=8             | False  |        |\n| 29        | [3,1,4,null,2], k=3                  | True   |        |\n| 30        | [5,3,6,2,4,null,7], k=4             | True   |        |\n| 31        | [3,1,4,null,2], k=7                  | False  |        |\n| 32        | [5,3,6,2,4,null,7], k=11             | False  |        |\n| 33        | [3,1,4,null,2], k=8                  | False  |        |\n| 34        | [10,5,15,3,7,12], k=9               | True   |        |\n| 35        | [7,3,9,2,4,8,10], k=11             | True   |        |\n| 36        | [7,3,9,2,4,8,10], k=14             | False  |        |\n| 37        | [3,1,4,null,2], k=1                  | True   |        |\n| 38        | [5,3,6,2,4,null,7], k=9             | False  |        |\n| 39        | [7,3,9,2,4,8,10], k=20             | False  |        |\n| 40        | [5,3,6,2,4,null,7], k=10            | False  |        |",
        "example": {
          "input": "[5,3,6,2,4,null,7], k=9",
          "output": "True",
          "explanation": "There exist two elements (2 and 7) whose sum is equal to 9."
        },
        "answer": "def findTarget(root, k):\n    seen = set()\n    def dfs(node):\n        if not node: return False\n        if k - node.val in seen:\n            return True\n        seen.add(node.val)\n        return dfs(node.left) or dfs(node.right)\n    return dfs(root)"
      },
      {
        "id": 34,
        "title": "Minimum Absolute Difference in BST",
        "description": "Find the minimum absolute difference between values of any two nodes.\n\n| Test Case | Input                         | Output   |\n|-----------|-------------------------------|----------|\n| 1         | [4,2,6,1,3]                   | 1        |\n| 2         | [1,0,48,null,null,12,49]      | 1        |\n| 3         | [1,2]                         | 1        |\n| 4         | [1,3,5,2,4]                   | 1        |\n| 5         | [7,3,10,1,5,8,12]             | 1        |\n| 6         | [1,1]                         | 0        |\n| 7         | [1,3,5,2,4,7,6,8]             | 1        |\n| 8         | [2,1,3]                       | 1        |\n| 9         | [1,10,15,6,8,7]               | 1        |\n| 10        | [5,3,8,2,4,7,6]               | 1        |\n| 11        | [1,5,3,8,7]                   | 2        |\n| 12        | [3,2,6,1,4]                   | 1        |\n| 13        | [4,1,6]                       | 2        |\n| 14        | [5,3,8,2,4,6]                 | 1        |\n| 15        | [8,3,10,1,6]                  | 2        |\n| 16        | [7,2,6,1,5,3,9]               | 1        |\n| 17        | [4,2,7,1,3]                   | 1        |\n| 18        | [6,3,8,2,4,7]                 | 1        |\n| 19        | [3,2,1,4]                     | 1        |\n| 20        | [9,7,11,6,8]                  | 1        |\n| 21        | [5,1,10,2,4]                  | 1        |\n| 22        | [1,2,3,4,5]                   | 1        |\n| 23        | [10,5,8,3,7,11]               | 1        |\n| 24        | [12,5,15,10,6]                | 1        |\n| 25        | [4,1,5,3,2]                   | 1        |\n| 26        | [3,2,1,4,6]                   | 1        |\n| 27        | [6,2,8,1,4]                   | 1        |\n| 28        | [4,2,7,3,5,1]                 | 1        |\n| 29        | [2,3,4,1]                     | 1        |\n| 30        | [3,5,7,1,2]                   | 2        |\n| 31        | [6,4,9,3,5,8]                 | 1        |\n| 32        | [5,4,10,3,8,7]                | 1        |\n| 33        | [7,3,10,2,8]                  | 2        |\n| 34        | [2,4,1,3,5]                   | 1        |\n| 35        | [10,3,6,1,5]                  | 1        |\n| 36        | [9,4,7,3,2]                   | 1        |\n| 37        | [3,2,5,1,4]                   | 1        |\n| 38        | [7,4,6,2,1]                   | 1        |\n| 39        | [4,3,6,2,7]                   | 1        |\n| 40        | [1,5,3,7,2]                   | 2        |",
        "example": {
          "input": "[4,2,6,1,3]",
          "output": "1",
          "explanation": "The minimum absolute difference between any two nodes is 1 (between 2 and 3)."
        },
        "answer": "def getMinimumDifference(root):\n    prev = None\n    min_diff = float('inf')\n    def inorder(node):\n        nonlocal prev, min_diff\n        if not node: return\n        inorder(node.left)\n        if prev is not None:\n            min_diff = min(min_diff, node.val - prev)\n        prev = node.val\n        inorder(node.right)\n    inorder(root)\n    return min_diff"
      },
      
{
  "id": 35,
  "title": "Recover BST",
  "description": "Two elements swapped by mistake; recover the tree.\n\n| Test Case | Input                        | Output         |\n|-----------|------------------------------|----------------|\n| 1         | [1,3,null,null,2]            | [3,1,null,null,2] |\n| 2         | [2,3,1]                      | [3,2,1]          |\n| 3         | [4,2,6,1,3,5,7]              | [4,3,6,1,2,5,7]  |\n| 4         | [3,1,4,null,null,2]           | [3,2,4,null,null,1] |\n| 5         | [1,2,3]                      | [3,2,1]          |\n| 6         | [2,3,1,4,5]                  | [3,2,1,4,5]      |\n| 7         | [5,4,8,2,6,7]                | [5,6,8,2,4,7]    |\n| 8         | [1,3,2]                      | [3,1,2]          |\n| 9         | [3,1,4,2]                    | [3,2,4,1]        |\n| 10        | [5,3,4,2,6]                  | [5,4,3,2,6]      |\n| 11        | [4,2,5,1,3]                  | [4,3,5,1,2]      |\n| 12        | [3,1,2]                      | [3,2,1]          |\n| 13        | [4,2,6,1,5,3,7]              | [4,3,6,1,2,5,7]  |\n| 14        | [1,2,3,4]                    | [3,2,1,4]        |\n| 15        | [2,1,3,4]                    | [3,2,1,4]        |\n| 16        | [6,4,8,3,5,7,9]              | [6,4,8,3,5,7,9]  |\n| 17        | [3,1,4,6,2]                  | [3,2,4,6,1]      |\n| 18        | [5,3,8,2,7]                  | [5,7,8,2,3]      |\n| 19        | [7,4,10,3,8]                 | [7,4,8,3,10]     |\n| 20        | [6,2,4,1,5]                  | [6,2,4,1,5]      |\n| 21        | [3,2,4,1]                    | [3,4,2,1]        |\n| 22        | [1,5,3,6,4]                  | [1,3,5,6,4]      |\n| 23        | [2,1,3,4]                    | [3,2,1,4]        |\n| 24        | [4,1,6,3,7]                  | [4,3,6,1,7]      |\n| 25        | [5,2,3,4,6]                  | [5,3,6,2,4]      |\n| 26        | [4,2,6,1,7]                  | [4,7,6,1,2]      |\n| 27        | [2,3,1,4]                    | [3,2,1,4]        |\n| 28        | [3,4,2]                      | [3,2,4]          |\n| 29        | [4,3,5,1,7]                  | [4,7,5,1,3]      |\n| 30        | [6,3,5,2,7]                  | [6,5,7,3,2]      |",
  "example": {
    "input": "[1,3,null,null,2]",
    "output": "[3,1,null,null,2]",
    "explanation": "The swapped nodes 3 and 1 are corrected to restore the BST."
  },
  "answer": "def recoverTree(root):\n    first = second = prev = None\n    def inorder(node):\n        nonlocal first, second, prev\n        if not node: return\n        inorder(node.left)\n        if prev and node.val < prev.val:\n            if not first:\n                first = prev\n            second = node\n        prev = node\n        inorder(node.right)\n    inorder(root)\n    first.val, second.val = second.val, first.val"
},
{
  "id": 36,
  "title": "Trim a BST",
  "description": "Trim the BST so that all elements lie in [low, high].\n\n| Test Case | Input                         | Output         |\n|-----------|-------------------------------|----------------|\n| 1         | [1,0,2], low=1, high=2         | [1,null,2]      |\n| 2         | [3,2,4,1], low=2, high=3       | [3,2]           |\n| 3         | [1,2,3,4], low=2, high=3       | [2,3]           |\n| 4         | [5,3,6,2,4], low=3, high=5     | [5,3,4]         |\n| 5         | [10,5,20,15,25], low=5, high=15| [10,5,15]       |\n| 6         | [1,0,2], low=0, high=2         | [0,1,2]         |\n| 7         | [4,2,6,1,3], low=3, high=4     | [4,3]           |\n| 8         | [5,3,6,2,4], low=0, high=7     | [5,3,6,2,4]     |\n| 9         | [8,4,10,1,6,null,14], low=6, high=10 | [8,6,10]   |\n| 10        | [7,3,10,2,5], low=2, high=5    | [5,3,2]         |\n| 11        | [5,3,7,2,4], low=3, high=6     | [5,3]           |\n| 12        | [1,4,5], low=1, high=4         | [1,4]           |\n| 13        | [6,3,8,2,5,7], low=4, high=6   | [5,6]           |\n| 14        | [9,4,10,2,6], low=4, high=9    | [4,6,9]         |\n| 15        | [1,3,5,2,4], low=2, high=4     | [3,2,4]         |\n| 16        | [3,2,5,1,4], low=2, high=5     | [3,2,5]         |\n| 17        | [5,3,6,2,4], low=2, high=6     | [5,3,6,2,4]     |\n| 18        | [7,2,6,1,5], low=2, high=6     | [7,2,6,5]       |\n| 19        | [6,3,8,2,5], low=2, high=6     | [6,3,5]         |\n| 20        | [1,2,3,4], low=1, high=3       | [1,2,3]         |\n| 21        | [3,5,1,4,6], low=2, high=5     | [3,5,4]         |\n| 22        | [6,2,8,1,3,7], low=2, high=7   | [6,2,3,7]       |\n| 23        | [10,5,20,15,25], low=10, high=20 | [10,15]      |\n| 24        | [9,5,12,3,7], low=6, high=12   | [9,7,12]        |\n| 25        | [8,4,10,2,6], low=4, high=8    | [8,4,6]          |\n| 26        | [3,2,5,1], low=1, high=5       | [3,2,5,1]       |\n| 27        | [4,2,6,1,5,8], low=2, high=5   | [4,2,5]         |\n| 28        | [7,3,8,2,5,9], low=2, high=6   | [5,3]           |\n| 29        | [5,3,7,2,6], low=3, high=7     | [5,3,7,6]       |\n| 30        | [10,5,15,7,20], low=6, high=15 | [10,7,15]       |",
  "example": {
    "input": "[1,0,2], low=1, high=2",
    "output": "[1,null,2]",
    "explanation": "The tree is trimmed so that only values between 1 and 2 remain."
  },
  "answer": "def trimBST(root, low, high):\n    if not root:\n        return None\n    if root.val < low:\n        return trimBST(root.right, low, high)\n    if root.val > high:\n        return trimBST(root.left, low, high)\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n    return root"
},
{
  "id": 37,
  "title": "Convert BST to Sorted DLL",
  "description": "Convert BST into sorted doubly linked list.\n\n| Test Case | Input             | Output      |\n|-----------|-------------------|-------------|\n| 1         | [4,2,5,1,3]       | [1,2,3,4,5] |\n| 2         | [2,1,3]           | [1,2,3]     |\n| 3         | [5,3,6,2,4]       | [2,3,4,5,6] |\n| 4         | [7,3,15,null,null,9,20] | [3,7,9,15,20] |\n| 5         | [1,2,3]           | [1,2,3]     |\n| 6         | [10,5,20,15,25]   | [5,10,15,20,25] |\n| 7         | [1,2]             | [1,2]       |\n| 8         | [1]               | [1]         |\n| 9         | [5,3,7]           | [3,5,7]     |\n| 10        | [10,5,2,1]        | [1,2,5,10]  |\n| 11        | [2,1,3,0]         | [0,1,2,3]   |\n| 12        | [5,4,6]           | [4,5,6]     |\n| 13        | [3,2,5,1]         | [1,2,3,5]   |\n| 14        | [9,4,12]          | [4,9,12]    |\n| 15        | [3,2,5,1,4]       | [1,2,3,4,5] |\n| 16        | [5,3,6,2,4,7]     | [2,3,4,5,6,7] |\n| 17        | [7,3,15,9]        | [3,7,9,15]  |\n| 18        | [8,4,12,2,6]      | [2,4,6,8,12] |\n| 19        | [4,2,5,1,3]       | [1,2,3,4,5] |\n| 20        | [9,3,8,2,5]       | [2,3,5,8,9] |\n| 21        | [4,1,7,2]         | [1,2,4,7]   |\n| 22        | [6,2,8,1,5]       | [1,2,5,6,8] |\n| 23        | [3,1,5,2,4]       | [1,2,3,4,5] |\n| 24        | [1,2,3,4]         | [1,2,3,4]   |\n| 25        | [1,3,5,2]         | [1,2,3,5]   |\n| 26        | [5,2,6,1,3]       | [1,2,3,5,6] |\n| 27        | [7,4,9]           | [4,7,9]     |\n| 28        | [4,2,6]           | [2,4,6]     |\n| 29        | [8,5,10]          | [5,8,10]    |\n| 30        | [5,3,7]           | [3,5,7]     |\n| 31        | [4,2,7,1,3,6]     | [1,2,3,4,6,7] |\n| 32        | [9,4,12]          | [4,9,12]    |\n| 33        | [3,1,4,2]         | [1,2,3,4]   |\n| 34        | [10,6,12]         | [6,10,12]   |\n| 35        | [3,1,5,2]         | [1,2,3,5]   |",
  "example": {
    "input": "[4,2,5,1,3]",
    "output": "[1,2,3,4,5]",
    "explanation": "The BST is converted into a sorted doubly linked list in ascending order."
  },
  "answer": "def treeToDoublyList(root):\n    if not root:\n        return None\n    first = last = None\n    def helper(node):\n        nonlocal first, last\n        if node:\n            helper(node.left)\n            if last:\n                last.right = node\n                node.left = last\n            else:\n                first = node\n            last = node\n            helper(node.right)\n    helper(root)\n    last.right = first\n    first.left = last\n    return first"
},
{
  "id": 38,
  "title": "Inorder Successor in BST",
  "description": "Find the inorder successor of a given node.\n\n| Test Case | Input             | Output |\n|-----------|-------------------|--------|\n| 1         | [2,1,3], p=1      | 2      |\n| 2         | [4,2,6,1,3], p=1  | 2      |\n| 3         | [5,3,7], p=3      | 5      |\n| 4         | [3,2,5,1,4], p=4  | 5      |\n| 5         | [6,2,8,1,3], p=3  | 6      |\n| 6         | [10,5,20,15,25], p=15 | 20  |\n| 7         | [2,1,3], p=3      | null   |\n| 8         | [5,3,7,2,4], p=3  | 4      |\n| 9         | [3,1,5,2], p=1    | 2      |\n| 10        | [10,5,20], p=5    | 10     |\n| 11        | [7,3,15,9], p=9   | 15     |\n| 12        | [8,4,12,2,6], p=4 | 6      |\n| 13        | [1,0,2], p=2      | null   |\n| 14        | [6,2,8,1,3], p=1  | 2      |\n| 15        | [9,3,8,2,5], p=5  | 8      |\n| 16        | [10,5,15,2], p=2  | 5      |\n| 17        | [3,1,4,2], p=1    | 2      |\n| 18        | [5,3,6,2,4], p=4  | 5      |\n| 19        | [4,2,6], p=6      | null   |\n| 20        | [7,2,6,1,5], p=5  | 6      |\n| 21        | [5,2,6,1,4], p=2  | 4      |\n| 22        | [8,4,12,2,6], p=6 | 8      |\n| 23        | [3,1,4,2], p=2    | 3      |\n| 24        | [6,4,8,2,5], p=5  | 6      |\n| 25        | [3,1,5], p=3      | 5      |\n| 26        | [9,3,10,1,4], p=1 | 3      |\n| 27        | [5,3,7], p=7      | null   |\n| 28        | [4,2,5,1,3], p=3  | 4      |\n| 29        | [6,3,8,2,5], p=3  | 5      |\n| 30        | [10,5,20,15,25], p=20 | 25   |",
  "example": {
    "input": "[2,1,3], p=1",
    "output": "2",
    "explanation": "The inorder successor of node 1 in the BST is 2."
  },
  "answer": "def inorderSuccessor(root, p):\n    successor = None\n    while root:\n        if p.val < root.val:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    return successor"
},
{
  "id": 39,
  "title": "BST Iterator",
  "description": "Implement an iterator over a BST.\n\n| Test Case | Input                         | Output               |\n|-----------|-------------------------------|----------------------|\n| 1         | [7,3,15,null,null,9,20]        | [3,7,9,15,20]         |\n| 2         | [1,null,2,2]                  | [2]                   |\n| 3         | [10,5,20,15,25]               | [5,10,15,20,25]       |\n| 4         | [5,3,6,2,4]                   | [2,3,4,5,6]           |\n| 5         | [4,2,6,1,3]                   | [1,2,3,4,6]           |\n| 6         | [2,1,3]                       | [1,2,3]               |\n| 7         | [8,3,10,1,6,null,14]          | [1,3,6,8,10,14]       |\n| 8         | [9,4,12]                      | [4,9,12]              |\n| 9         | [6,2,8,1,3]                   | [1,2,3,6,8]           |\n| 10        | [7,3,15,9,20]                 | [3,7,9,15,20]         |\n| 11        | [4,2,6]                       | [2,4,6]               |\n| 12        | [3,2,4,1,5]                   | [1,2,3,4,5]           |\n| 13        | [6,3,8,2,7]                   | [2,3,6,7,8]           |\n| 14        | [7,3,15]                      | [3,7,15]              |\n| 15        | [10,5,20]                     | [5,10,20]             |\n| 16        | [5,2,6,1,4]                   | [1,2,4,5,6]           |\n| 17        | [1,3,5,2,4]                   | [1,2,3,4,5]           |\n| 18        | [8,4,12,2,6]                  | [2,4,6,8,12]          |\n| 19        | [3,1,4,2]                     | [1,2,3,4]             |\n| 20        | [5,3,7]                       | [3,5,7]               |\n| 21        | [3,1,6,2,4]                   | [1,2,3,4,6]           |\n| 22        | [9,2,12,5]                    | [2,5,9,12]            |\n| 23        | [8,4,6,2,7]                   | [2,4,6,7,8]           |\n| 24        | [5,3,7,2]                     | [2,3,5,7]             |\n| 25        | [9,3,6,1,4,5]                 | [1,3,4,5,6,9]         |\n| 26        | [6,3,8,2,7]                   | [2,3,6,7,8]           |\n| 27        | [10,5,20,15,25]               | [5,10,15,20,25]       |\n| 28        | [2,1,3]                       | [1,2,3]               |\n| 29        | [5,3,7,2,4]                   | [2,3,4,5,7]           |\n| 30        | [6,2,8,1,3]                   | [1,2,3,6,8]           |\n",
  "example": {
    "input": "[7,3,15,null,null,9,20]",
    "output": "[3,7,9,15,20]",
    "explanation": "Iterator returns elements in ascending order when calling next."
  },
  "answer": "class BSTIterator:\n    def __init__(self, root):\n        self.stack = []\n        self._leftmost_inorder(root)\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n    def next(self):\n        top = self.stack.pop()\n        if top.right:\n            self._leftmost_inorder(top.right)\n        return top.val\n    def hasNext(self):\n        return len(self.stack) > 0"
},
{
  "id": 40,
  "title": "Find Mode in BST",
  "description": "Find all the elements that appear most frequently.\n\n| Test Case | Input                         | Output         |\n|-----------|-------------------------------|----------------|\n| 1         | [1,null,2,2]                  | [2]            |\n| 2         | [3,2,4,1,5]                   | [2,4]          |\n| 3         | [10,5,20,15,25]               | [20]           |\n| 4         | [5,3,6,2,4]                   | [4]            |\n| 5         | [4,2,6,1,3]                   | [4,2]          |\n| 6         | [2,1,3]                       | [1,2,3]        |\n| 7         | [8,3,10,1,6,null,14]          | [1,3,6,8,10,14] |\n| 8         | [9,4,12]                      | [4,12]         |\n| 9         | [6,2,8,1,3]                   | [3,6]          |\n| 10        | [7,3,15,9,20]                 | [3,7,9,15,20]  |\n| 11        | [4,2,6]                       | [6]            |\n| 12        | [3,2,4,1,5]                   | [2,4]          |\n| 13        | [6,3,8,2,7]                   | [2,3,7]        |\n| 14        | [7,3,15]                      | [7,3]          |\n| 15        | [10,5,20]                     | [10,5]         |\n| 16        | [5,2,6,1,4]                   | [5]            |\n| 17        | [1,3,5,2,4]                   | [3,5]          |\n| 18        | [8,4,12,2,6]                  | [2,8]          |\n| 19        | [3,1,4,2]                     | [1,2,4]        |\n| 20        | [5,3,7]                       | [7]            |\n| 21        | [3,1,6,2,4]                   | [4,6]          |\n| 22        | [9,2,12,5]                    | [2,5]          |\n| 23        | [8,4,6,2,7]                   | [6]            |\n| 24        | [5,3,7,2]                     | [2,5,7]        |\n| 25        | [9,3,6,1,4,5]                 | [1,5]          |\n| 26        | [6,3,8,2,7]                   | [3,7]          |\n| 27        | [10,5,20,15,25]               | [15]           |\n| 28        | [2,1,3]                       | [2]            |\n| 29        | [5,3,7,2,4]                   | [2,4]          |\n| 30        | [6,2,8,1,3]                   | [6]            |\n",
  "example": {
    "input": "[1,null,2,2]",
    "output": "[2]",
    "explanation": "The most frequent element in the BST is 2."
  },
  "answer": "def findMode(root):\n    from collections import Counter\n    counter = Counter()\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        counter[node.val] += 1\n        inorder(node.right)\n    inorder(root)\n    max_count = max(counter.values())\n    return [k for k, v in counter.items() if v == max_count]"
},
{
  "id": 41,
  "title": "Closest Value in BST",
  "description": "Find the value in the BST that is closest to the target.\n\n| Test Case | Input                            | Output |\n|-----------|----------------------------------|--------|\n| 1         | [4,2,5,1,3], target=3.714        | 4      |\n| 2         | [1], target=4                    | 1      |\n| 3         | [4,2,5,1,3], target=2.1          | 2      |\n| 4         | [6,2,8,0,4,7,9], target=5        | 4      |\n| 5         | [5,3,7,2,4], target=3.5          | 4      |\n| 6         | [5,2,8,null,3], target=4         | 3      |\n| 7         | [10,5,15,3,7,13,18], target=16   | 15     |\n| 8         | [10,5,15], target=13             | 15     |\n| 9         | [5,3,6,2,4], target=3.9          | 4      |\n| 10        | [5,3,6,2,4], target=2.5          | 2      |\n| 11        | [5], target=5                    | 5      |\n| 12        | [2,1,3], target=1.8              | 2      |\n| 13        | [2,1,3], target=1.1              | 1      |\n| 14        | [1,null,3], target=2.8           | 3      |\n| 15        | [1,null,3], target=2.2           | 3      |\n| 16        | [3,1,4,null,2], target=2.7       | 3      |\n| 17        | [3,1,4,null,2], target=2.1       | 2      |\n| 18        | [4,2,5,1,3], target=3.3          | 3      |\n| 19        | [4,2,5,1,3], target=1.9          | 2      |\n| 20        | [8,4,10,2,6,null,14], target=13  | 14     |\n| 21        | [4,2,6,1,3], target=2.6          | 3      |\n| 22        | [6,2,8,null,4,7,9], target=6.8   | 7      |\n| 23        | [6,2,8,null,4,7,9], target=9.1   | 9      |\n| 24        | [6,2,8,null,4,7,9], target=1.9   | 2      |\n| 25        | [10,5,15,3,7,null,18], target=17 | 18     |\n| 26        | [4,2,5,1,3], target=0            | 1      |\n| 27        | [7,3,10,1,5], target=6           | 5      |\n| 28        | [8,3,10,1,6], target=5           | 6      |\n| 29        | [8,3,10,1,6], target=7           | 6      |\n| 30        | [6,4,9,3,5,8,10], target=7.5     | 8      |",
  "example": {
    "input": "[4,2,5,1,3], target=3.714",
    "output": "4",
    "explanation": "3.714 is closest to 4 in the BST."
  },
  "answer": "def closestValue(root, target):\n    closest = root.val\n    while root:\n        if abs(root.val - target) < abs(closest - target):\n            closest = root.val\n        root = root.left if target < root.val else root.right\n    return closest"
},
{
  "id": 42,
  "title": "Range Sum of BST",
  "description": "Return the sum of values of all nodes with a value in the inclusive range [low, high].\n\n| Test Case | Input                                 | Output |\n|-----------|---------------------------------------|--------|\n| 1         | [10,5,15,3,7,null,18], low=7, high=15 | 32     |\n| 2         | [10,5,15,3,7,13,18,1,null,6], low=6, high=10 | 23 |\n| 3         | [7,3,15,2,5,null,18], low=5, high=15  | 27     |\n| 4         | [4,2,7,1,3,6,9], low=2, high=6        | 17     |\n| 5         | [5,3,8,1,4,6,10], low=4, high=9       | 28     |\n| 6         | [6,4,8,2,5,7,9], low=4, high=8        | 33     |\n| 7         | [5,2,8,1,3,6,10], low=3, high=6       | 18     |\n| 8         | [10], low=5, high=15                  | 10     |\n| 9         | [10], low=11, high=15                 | 0      |\n| 10        | [10], low=1, high=9                   | 0      |\n| 11        | [1,null,2], low=1, high=2             | 3      |\n| 12        | [5,3,7], low=3, high=7                | 15     |\n| 13        | [15,10,20,5,13,18,25], low=10, high=20| 76     |\n| 14        | [4,2,6,1,3,5,7], low=3, high=6        | 18     |\n| 15        | [8,3,10,1,6,null,14], low=6, high=10  | 24     |\n| 16        | [3,2,4,1], low=1, high=3              | 6      |\n| 17        | [7,4,10,2,5,8,12], low=5, high=10     | 33     |\n| 18        | [2,1,3], low=2, high=3                | 5      |\n| 19        | [5,3,8,null,4], low=4, high=8         | 17     |\n| 20        | [6,3,8,2,4,7,9], low=3, high=7        | 28     |\n| 21        | [9,5,12,3,7], low=6, high=12          | 28     |\n| 22        | [4,2,6,1,3,5,7], low=1, high=7        | 28     |\n| 23        | [4,2,6,1,3,5,7], low=2, high=5        | 14     |\n| 24        | [6,2,8,null,4,7,9], low=6, high=8     | 21     |\n| 25        | [8,4,10,2,6], low=4, high=8           | 18     |\n| 26        | [10,5,20,15,25], low=15, high=25      | 60     |\n| 27        | [10,5,15,3,7], low=3, high=7          | 15     |\n| 28        | [1,null,3], low=2, high=4             | 3      |\n| 29        | [3,2,5,1,4], low=3, high=4            | 7      |\n| 30        | [3,1,5,null,2,4,6], low=2, high=5     | 17     |",
  "example": {
    "input": "[10,5,15,3,7,null,18], low=7, high=15",
    "output": "32",
    "explanation": "Only nodes 7, 10, and 15 are in range."
  },
  "answer": "def rangeSumBST(root, low, high):\n    if not root:\n        return 0\n    if root.val < low:\n        return rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return rangeSumBST(root.left, low, high)\n    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high)"
},
{
  "id": 43,
  "title": "Balance a BST",
  "description": "Return a balanced BST.\n\n| Test Case | Input                    | Output             |\n|-----------|--------------------------|--------------------|\n| 1         | [1,null,2,null,3,null,4] | [2,1,3,null,null,null,4] |\n| 2         | [2,1,3,null,null,null,4] | [2,1,3,null,null,null,4] |\n| 3         | [3,1,null,null,2]        | [2,1,3]            |\n| 4         | [4,3,null,2,null,1]      | [2,1,3,null,null,null,4] |\n| 5         | [5,3,8,2,4,6,10]         | [5,3,8,2,4,6,10]   |\n| 6         | [10,5,15,3,7,13,18]      | [10,5,15,3,7,13,18]|\n| 7         | [1]                      | [1]                |\n| 8         | [2,1,null]               | [1,null,2]         |\n| 9         | [3,null,4,null,5]        | [4,3,5]            |\n| 10        | [7,3,10,2,5]             | [5,3,7,2,null,null,10] |\n| 11        | [6,3,9,1,4,8,10]         | [6,3,9,1,4,8,10]   |\n| 12        | [8,4,null,2,null,1]      | [2,1,4,null,null,null,8] |\n| 13        | [9,5,11,4,7,10,12]       | [9,5,11,4,7,10,12] |\n| 14        | [5,3,null,2,null,1]      | [2,1,5,null,null,3]|\n| 15        | [10,5,null,3,null,1]     | [3,1,10,null,null,5]|\n| 16        | [2,1,3,null,null,null,4] | [2,1,3,null,null,null,4]|\n| 17        | [3,2,null,1]             | [2,1,3]            |\n| 18        | [4,2,6,1,3,5,7]          | [4,2,6,1,3,5,7]    |\n| 19        | [1,null,3,null,5]        | [3,1,5]            |\n| 20        | [15,10,20,5,13,18,25]    | [15,10,20,5,13,18,25]|\n| 21        | [2,null,4,null,6]        | [4,2,6]            |\n| 22        | [6,2,8,1,4,7,9]          | [6,2,8,1,4,7,9]    |\n| 23        | [3,null,5,null,7]        | [5,3,7]            |\n| 24        | [7,4,null,2,null,1]      | [2,1,4,null,null,null,7]|\n| 25        | [12,8,16,6,10,14,18]     | [12,8,16,6,10,14,18]|\n| 26        | [10,null,12,null,14]     | [12,10,14]         |\n| 27        | [2,1,null,null,null,null,3] | [2,1,3]          |\n| 28        | [1,null,2,null,3,null,4] | [2,1,3,null,null,null,4]|\n| 29        | [3,2,null,1]             | [2,1,3]            |\n| 30        | [9,6,13,5,8,11,15]       | [9,6,13,5,8,11,15] |",
  "example": {
    "input": "[1,null,2,null,3,null,4]",
    "output": "[2,1,3,null,null,null,4]",
    "explanation": "The unbalanced tree is transformed into a height-balanced BST."
  },
  "answer": "def balanceBST(root):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    def build(l, r):\n        if l > r:\n            return None\n        m = (l + r) // 2\n        node = TreeNode(vals[m])\n        node.left = build(l, m-1)\n        node.right = build(m+1, r)\n        return node\n    inorder(root)\n    return build(0, len(vals)-1)"
},
{
  "id": 44,
  "title": "Next Greater Element in BST",
  "description": "Given a BST and a target node, return the in-order successor (next greater node).\n\n| Test Case | Input (BST, target)         | Output |\n|-----------|------------------------------|--------|\n| 1         | [2,1,3], 1                    | 2      |\n| 2         | [2,1,3], 2                    | 3      |\n| 3         | [2,1,3], 3                    | null   |\n| 4         | [5,3,6,2,4,null,null,1], 1    | 2      |\n| 5         | [5,3,6,2,4,null,null,1], 2    | 3      |\n| 6         | [5,3,6,2,4,null,null,1], 3    | 4      |\n| 7         | [5,3,6,2,4,null,null,1], 4    | 5      |\n| 8         | [5,3,6,2,4,null,null,1], 5    | 6      |\n| 9         | [5,3,6,2,4,null,null,1], 6    | null   |\n| 10        | [20,10,30,5,15,25,35], 15     | 20     |\n| 11        | [20,10,30,5,15,25,35], 25     | 30     |\n| 12        | [20,10,30,5,15,25,35], 30     | 35     |\n| 13        | [20,10,30,5,15,25,35], 35     | null   |\n| 14        | [10,5,15,3,7,13,18], 7        | 10     |\n| 15        | [10,5,15,3,7,13,18], 10       | 13     |\n| 16        | [10,5,15,3,7,13,18], 13       | 15     |\n| 17        | [10,5,15,3,7,13,18], 18       | null   |\n| 18        | [1,null,2,null,3,null,4], 2   | 3      |\n| 19        | [1,null,2,null,3,null,4], 4   | null   |\n| 20        | [4,2,6,1,3,5,7], 4            | 5      |\n| 21        | [4,2,6,1,3,5,7], 5            | 6      |\n| 22        | [4,2,6,1,3,5,7], 6            | 7      |\n| 23        | [4,2,6,1,3,5,7], 7            | null   |\n| 24        | [3,1,5,null,2,4,6], 3         | 4      |\n| 25        | [3,1,5,null,2,4,6], 2         | 3      |\n| 26        | [3,1,5,null,2,4,6], 4         | 5      |\n| 27        | [3,1,5,null,2,4,6], 6         | null   |\n| 28        | [8,3,10,1,6,null,14], 6       | 8      |\n| 29        | [8,3,10,1,6,null,14], 10      | 14     |\n| 30        | [8,3,10,1,6,null,14], 14      | null   |",
  "example": {
    "input": "[2,1,3], target = 1",
    "output": "2",
    "explanation": "The in-order successor of 1 is 2 in the BST."
  },
  "answer": "def inorderSuccessor(root, p):\n    successor = None\n    while root:\n        if p.val < root.val:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    return successor"
},
{
  "id": 45,
  "title": "Preorder Traversal BST Check",
  "description": "Given an array, determine if it can represent the preorder traversal of a binary search tree (BST).\n\n| Test Case | Input                        | Output |\n|-----------|-------------------------------|--------|\n| 1         | [5,2,1,3,6]                   | true   |\n| 2         | [5,2,6,1,3]                   | false  |\n| 3         | [8,5,1,7,10,9,12]             | true   |\n| 4         | [8,5,10,1,7,9,12]             | false  |\n| 5         | [7,4,1,5,10,8,12]             | true   |\n| 6         | [7,10,4,1,5,8,12]             | false  |\n| 7         | [10,5,1,7,40,50]              | true   |\n| 8         | [10,5,1,40,7,50]              | false  |\n| 9         | [2,1,3]                       | true   |\n| 10        | [2,3,1]                       | false  |\n| 11        | [1,2,3,4,5]                   | true   |\n| 12        | [5,4,3,2,1]                   | true   |\n| 13        | [5,1,4,2,3]                   | true   |\n| 14        | [5,1,3,4,2]                   | false  |\n| 15        | [3,2,1,4,5]                   | true   |\n| 16        | [3,4,5,2,1]                   | false  |\n| 17        | [10,9,8,7,6]                  | true   |\n| 18        | [10,9,7,6,8]                  | true   |\n| 19        | [10,7,9,6,8]                  | true   |\n| 20        | [10,7,6,9,8]                  | false  |\n| 21        | [8,6,5,7,10,9,11]             | true   |\n| 22        | [8,6,10,5,7,9,11]             | false  |\n| 23        | [5,3,2,4,8,6,9]               | true   |\n| 24        | [5,3,8,2,4,6,9]               | false  |\n| 25        | [6,4,2,5,9,7,10]              | true   |\n| 26        | [6,4,9,2,5,7,10]              | false  |\n| 27        | [1]                           | true   |\n| 28        | [2,1]                         | true   |\n| 29        | [2,3]                         | true   |\n| 30        | [3,2,4,1]                     | true   |",
  "example": {
    "input": "[5,2,1,3,6]",
    "output": "true",
    "explanation": "The array represents the valid preorder traversal of a BST: root 5, left subtree [2,1,3], right subtree [6]."
  },
  "answer": "def isValidPreorder(preorder):\n    stack = []\n    root = float('-inf')\n    for value in preorder:\n        if value < root:\n            return False\n        while stack and value > stack[-1]:\n            root = stack.pop()\n        stack.append(value)\n    return True"
}      
   ]
  }
  